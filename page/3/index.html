<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>持续学习者————Just Do It！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:type" content="website">
<meta property="og:title" content="持续学习者————Just Do It！">
<meta property="og:url" content="http://droidman.net/page/3/index.html">
<meta property="og:site_name" content="持续学习者————Just Do It！">
<meta property="og:description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:locale" content="en,ZH">
<meta property="article:author" content="OuyangWenyuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Objective-c">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Unity3d">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="Program">
<meta property="article:tag" content="Mac OS">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="Window">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="xcode">
<meta property="article:tag" content="IDEA">
<meta property="article:tag" content="eclicpse">
<meta property="article:tag" content="blender">
<meta property="article:tag" content="MVC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="持续学习者————Just Do It！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">持续学习者————Just Do It！</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学无止境————不怕你不会，就怕你不学！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://droidman.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2022-01-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/01/2022-01-01/" class="article-date">
  <time datetime="2022-01-01T01:30:02.000Z" itemprop="datePublished">2022-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/01/01/2022-01-01/">粒子系统基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、粒子系统基础属性<br>Unity 的粒子系统（Particle System）包含许多属性和功能，下面是一些常见的属性及其用途：</p>
<p>发射模块（Emission Module）：控制粒子的发射速率、发射角度、初始速度等，可以用来控制粒子的产生方式和速度。</p>
<p>形状模块（Shape Module）：定义了粒子发射的区域形状，可以是球体、盒子、圆锥等，也可以通过贴图来定义不规则的发射形状。</p>
<p>大小模块（Size over Lifetime）：控制粒子大小随时间变化的曲线，可以实现粒子从产生到消失过程中大小渐变的效果。</p>
<p>颜色模块（Color over Lifetime）：控制粒子颜色随时间变化的曲线，可以实现粒子从产生到消失过程中颜色渐变的效果。</p>
<p>旋转模块（Rotation over Lifetime）：控制粒子旋转角度随时间变化的曲线，可以实现粒子自旋转的效果。</p>
<p>纹理动画（Texture Sheet Animation）：通过设置纹理帧数和播放模式，实现粒子的纹理帧动画效果。</p>
<p>碰撞模块（Collision Module）：定义了粒子与碰撞器之间的交互效果，如碰撞后的反弹、消失等行为。</p>
<p>外部力场（External Forces）：允许外部力场对粒子系统施加影响，如重力、风等。</p>
<p>Start Lifetime（开始寿命）：定义了粒子的初始生命周期，即粒子被发射后存在的时间。</p>
<p>Start Speed（初始速度）：确定了粒子被发射时的初速度，影响了粒子移动的距离和速度。</p>
<p>Start Size（初始大小）：设定了粒子被发射时的初始大小，可以影响粒子的显示效果。</p>
<p>Start Color（初始颜色）：确定了粒子被发射时的初始颜色。</p>
<p>Start Rotation（初始旋转）：定义了粒子被发射时的初始旋转角度。</p>
<p>这些属性共同决定了粒子的初始状态，而在粒子系统中，还可以通过曲线或颜色过渡等方式来调整粒子在生命周期内的变化情况，比如：</p>
<p>Size over Lifetime（大小随生命周期变化）：控制了粒子在生命周期内大小的变化，可以实现粒子渐变消失的效果。</p>
<p>Color over Lifetime（颜色随生命周期变化）：控制了粒子在生命周期内颜色的变化，可以实现颜色渐变消失的效果。</p>
<p>二、自定义脚本操作粒子系统<br>1.自定义脚本获取组件</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ParticleController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> ParticleSystem particleSystem; <span class="comment">// 粒子系统组件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        particleSystem = GetComponent&lt;ParticleSystem&gt;(); <span class="comment">// 获取粒子系统组件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在空格键按下时播放粒子效果</span></span><br><span class="line">            PlayParticleEffect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayParticleEffect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        particleSystem.Play(); <span class="comment">// 播放粒子效果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了一个名为 ParticleController 的脚本类，用于控制粒子系统。在 Start 方法中，通过 GetComponent 方法获取当前对象上的 ParticleSystem 组件，以便在后续代码中对其进行操作。</p>
<p>在 Update 方法中，检测到用户按下空格键时，调用 PlayParticleEffect 方法来播放粒子效果。PlayParticleEffect 方法中，我们调用 ParticleSystem 的 Play 方法来启动粒子效果。</p>
<p>使用以上代码，可以将该脚本组件添加到场景中的一个游戏对象上，并将粒子系统组件拖拽到脚本组件的相应字段中。然后，在运行游戏时按下空格键，就能播放粒子效果了。</p>
<p>2.脚本实现火焰效果</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Frame</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> maxParticles = <span class="number">1000f</span>; <span class="comment">// 最大粒子数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> emissionRate = <span class="number">300f</span>; <span class="comment">// 发射速率</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> lifetime = <span class="number">1f</span>; <span class="comment">// 粒子生命周期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> startSize = <span class="number">0.2f</span>; <span class="comment">// 初始大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> endSize = <span class="number">0.01f</span>; <span class="comment">// 结束大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> startSpeed = <span class="number">1f</span>; <span class="comment">// 初始速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> endSpeed = <span class="number">0f</span>; <span class="comment">// 结束速度</span></span><br><span class="line">    <span class="keyword">public</span> Color startColor = <span class="keyword">new</span> Color(<span class="number">1f</span>, <span class="number">0.5f</span>, <span class="number">0f</span>); <span class="comment">// 初始颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color endColor = <span class="keyword">new</span> Color(<span class="number">1f</span>, <span class="number">0f</span>, <span class="number">0f</span>); <span class="comment">// 结束颜色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ParticleSystem particleSystem; <span class="comment">// 粒子系统组件</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        particleSystem = GetComponent&lt;ParticleSystem&gt;(); <span class="comment">// 获取粒子系统组件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置粒子系统属性</span></span><br><span class="line">        <span class="keyword">var</span> main = particleSystem.main;</span><br><span class="line">        main.maxParticles = (<span class="keyword">int</span>)maxParticles;</span><br><span class="line">        main.startLifetime = lifetime;</span><br><span class="line">        main.startSize = startSize;</span><br><span class="line">        main.startSpeed = startSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置粒子发射器属性</span></span><br><span class="line">        <span class="keyword">var</span> emission = particleSystem.emission;</span><br><span class="line">        emission.rateOverTime = emissionRate;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置粒子形状属性</span></span><br><span class="line">        <span class="keyword">var</span> shape = particleSystem.shape;</span><br><span class="line">        shape.shapeType = ParticleSystemShapeType.Cone;</span><br><span class="line">        shape.angle = <span class="number">30f</span>;</span><br><span class="line">        shape.radius = <span class="number">0.1f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置粒子渲染器属性</span></span><br><span class="line">        <span class="keyword">var</span> renderer = particleSystem.GetComponent&lt;ParticleSystemRenderer&gt;();</span><br><span class="line">        renderer.material = <span class="keyword">new</span> Material(Shader.Find(<span class="string">"Particles/Additive"</span>));</span><br><span class="line">        renderer.material.color = startColor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在空格键按下时播放粒子效果</span></span><br><span class="line">            PlayParticleEffect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PlayParticleEffect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        particleSystem.Play(); <span class="comment">// 播放粒子效果</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用协程在一定时间后停止粒子效果</span></span><br><span class="line">        StartCoroutine(StopParticleEffect());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">StopParticleEffect</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params">lifetime</span>)</span>; <span class="comment">// 等待一段时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 停止粒子效果并清空粒子</span></span><br><span class="line">        particleSystem.Stop();</span><br><span class="line">        particleSystem.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，我们创建了一个名为 FlameEffect 的脚本类，用于控制火焰粒子效果。我们定义了一些公共的属性变量，可以在 Inspector 界面中进行设置，以便调整粒子系统的各项属性。</p>
<p>在 Start 方法中，我们通过 GetComponent 方法获取当前对象上的 ParticleSystem 组件，并设置其各项属性，包括最大粒子数、粒子生命周期、大小、速度、颜色等。</p>
<p>在 Update 方法中，我们检测到用户按下空格键时，调用 PlayParticleEffect 方法来播放粒子效果。PlayParticleEffect 方法中，我们调用 ParticleSystem 的 Play 方法来启动粒子效果，并使用协程在一定时间后停止粒子效果。</p>
<p>StopParticleEffect 方法中，我们使用 WaitForSeconds 方法等待粒子生命周期的时间后，停止粒子效果并清空粒子。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2022/01/01/2022-01-01/" data-id="cmd1cywba000416z8h5x8dqn5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Particle-System/" rel="tag">Particle System</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2021-01-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/01/2021-01-01/" class="article-date">
  <time datetime="2021-01-01T00:27:05.000Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/01/2021-01-01/">C#扩展方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>扩展方法<br>C#在3.0版本中引入了“扩展方法”，既有静态方法的优点，又使调用它们的代码的可读性得到了提高。在使用扩展方法时，可以像调用实例方法那样调用静态方法。</p>
<p>扩展方法声明<br>必须在一个非嵌套的、非泛型的静态类中（所以必须是一个静态方法）。<br>至少有一个参数。<br>第一个参数必须附加this关键字做前缀。<br>第一个参数不能有其他任何修饰符（如ref或out）。<br>第一个参数的类型不能是指针类型。<br>如何使用<br>扩展方法参数可以给该参数的类型增加一个方法，简单点说就是在A类中写一个方法，B类中也会拥有这个方法。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static class A</span><br><span class="line">&#123;</span><br><span class="line">    public static void Foo(this B s)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainClass</span><br><span class="line">&#123;</span><br><span class="line">	static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        B b &#x3D; new B();</span><br><span class="line">        &#x2F;&#x2F; 使用B类的对象调用A类中定义的Foo方法</span><br><span class="line">        b.Foo();          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中对象b可以直接调用Foo方法，因为这个方法已经被扩展到B类中了。</p>
<p>举个例子<br>我想做一个用于辅助Transform类的工具类（TransformHelper），其中有一个方法是要递归查找子对象中的某个变换组件，这时候就可以通过 <strong>this参数（扩展方法）</strong>来给Transform类添加此方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F;变换组件助手类</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public static class TransformHelper</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 递归查找变换组件</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;cuurentTF&quot;&gt;当前对象&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;childName&quot;&gt;要查找的子节点名称&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">    public static Transform FindChildByName(this Transform cuurentTF, string childName)</span><br><span class="line">    &#123;</span><br><span class="line">        Transform child &#x3D; cuurentTF.Find(childName);</span><br><span class="line"></span><br><span class="line">        if (child !&#x3D; null) return child;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; cuurentTF.childCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            child &#x3D; FindChildByName(cuurentTF.GetChild(i), childName);</span><br><span class="line">            if (child !&#x3D; null) return child;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 游戏主窗口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class UIMainWindow : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 用静态类的方式调用方法</span><br><span class="line">        TransformHelper.FindChildByName(transform, &quot;ButtonGameStart&quot;).GetComponent&lt;Button&gt;().onClick.AddListener(OnGameStartButtonClick);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 直接使用变化组件调用方法，注意，此时不用要再传第一个参数了，因为第一个参数已经成为默认的this了。</span><br><span class="line">        transform.FindChildByName(&quot;ButtonGameStart&quot;).GetComponent&lt;Button&gt;().onClick.AddListener(OnGameStartButtonClick);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本原则<br>C#只支持扩展方法，不支持扩展属性、扩展事件、扩展操作符等。<br>扩展方法（第一个参数前面是this的方法）必须在非泛型的静态类中声明，扩展方法必须有一个参数，而且只有第一个参数使用this标记。<br>C#编译器查找静态类中的扩展方法时，要求这些静态类本身必须具有文件作用域。<br>C#编译要求“导入”扩展方法。（静态方法可以任意命名，C#编译器在寻找方法时，需要花费时间进行查找，需要检查文件作用域中的所有的静态类，并扫描它们的所有静态方法来查找一个匹配）。<br>多个静态类可以定义相同的扩展方法。<br>用一个扩展方法扩展一个类型时，同时也扩展了派生类型。<br>调用方法时无需传递第一个参数，默认指定调用方法的对象（this）为第一个参数。<br>扩展方法的优劣分析<br>刚接触到扩展方法时，内心总觉得这是不合理的，因为扩展方法可能导致每个类都可能有新的、隐藏的、未知的方法，首先从内存的角度考虑就是不合理的（问题1），其次在代码的可维护性和易用性两方面考虑也是颇具困难的（问题2）。</p>
<p>比如我将方法扩展到泛型中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static string FindKey&lt;T&gt;(this T obj, FindHandler&lt;T&gt; handler)</span><br><span class="line">&#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照正常的理解，会以为所有类型，或者说所有引入这个类的类型都会加入FindKey方法，但实际上并不是这样的，或者说并不完全是这样的。虽然这些方法可以使用对象直接调用，但实际上被调用的还是最初的那个静态方法，而不是重新写入到泛型T类中的方法。</p>
<p>为什么这么说呢？</p>
<p>因为在扩展方法中会使用ExtensionAttribute这个Attribute。一旦使用this关键字标记了某个静态方法的第一个参数，编译器就会在内部向该方法应用一个定制的attribute，这个attribute会在最终生成的文件的元数据中持久性的存储下来，此属性在System.Core dll程序集中。</p>
<p>任何静态类只要包含了至少一个扩展方法，它的元数据中也会应用这个attribute，任何一个程序集包含了至少一个符合上述特点的静态类，它的元数据也会应用这个attribute。如果代码用了一个不存在的实例方法，编译器会快速的扫描引用的所有程序集，判断它们哪些包含了扩展方法，然后，在这个程序集中，可以扫描包含了扩展方法的静态类。</p>
<p>如果同一个命名空间中的两个类含有扩展类型相同的方法，就没有办法做到只用其中一个类中的扩展方法。为了通过类型的简单名称（没有命名空间前缀）来使用类型，可以导入该类型所有在的命名空间，但这样做的时候，你没有办法阻止那个命名空间中的扩展方法也被导入进来。</p>
<p>回到最初提出的问题：</p>
<p>问题1：是不是每个对象都加入了这个扩展方法？<br>这个问题其实并未发生，因为C#使用的方式不是给每个对象加一个方法，而是另外提供了一个扩展方法的列表，在使用时通过列表找到被扩展的静态方法然后调用，也就是说方法还是只有那一个方法，并没有大范围的占据方法区。</p>
<p>问题2：代码的可维护性和易用性上是否受到了影响？<br>这个问题其实是存在的，如果开发团队不能有效的控制扩展方法的定义，将会出现局部代码无法溯源或者扩展功能影响主场景功能的问题，导致代码可读性差，语义不明确等问题。但如果开发团队能够有效的控制扩展方法的创建，并提供专门的扩展方法维护及使用方案，开发效率也会有些许提升。</p>
<p>总结<br>扩展方法可以说是一把双刃剑，用好了锋利无比，用不好也有可能会自伤，但总得来说还是功大于过，特别适合具有经验的团队使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2021/01/01/2021-01-01/" data-id="cmd1cywb9000316z8080og4dt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C#</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/31/2020-01-31/" class="article-date">
  <time datetime="2020-01-31T12:53:32.000Z" itemprop="datePublished">2020-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/31/2020-01-31/">三消游戏的一些算法总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>•    &quot;如何表示消除游戏的棋盘？&quot;
•    &quot;怎样检测相邻的相同元素？&quot;

•    &quot;如何实现消除后自动补全棋盘效果？
•    &quot;如何实现消除后自动生成新元素效果？&quot;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消除游戏棋盘表示</span><br><span class="line">	int[,] board &#x3D; new int[8, 8]; &#x2F;&#x2F; 0表示空位，1-6表示不同颜色</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 检测相邻相同元素</span><br><span class="line">	bool HasMatch(int[,] grid, int x, int y) &#123;</span><br><span class="line">	    int color &#x3D; grid[x, y];</span><br><span class="line">	    &#x2F;&#x2F; 检查水平方向</span><br><span class="line">	    if (x &gt; 0 &amp;&amp; grid[x-1, y] &#x3D;&#x3D; color &amp;&amp; x &lt; grid.GetLength(0)-1 &amp;&amp; grid[x+1, y] &#x3D;&#x3D; color)</span><br><span class="line">	        return true;</span><br><span class="line">	    &#x2F;&#x2F; 检查垂直方向</span><br><span class="line">	    if (y &gt; 0 &amp;&amp; grid[x, y-1] &#x3D;&#x3D; color &amp;&amp; y &lt; grid.GetLength(1)-1 &amp;&amp; grid[x, y+1] &#x3D;&#x3D; color)</span><br><span class="line">	        return true;</span><br><span class="line">	    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

•    &quot;如何实现三消游戏中的特殊连锁反应效果？&quot;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连锁反应节点</span><br><span class="line">public class ChainNode &#123;</span><br><span class="line">    public Vector2Int Position;</span><br><span class="line">    public ChainNode Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理连锁反应</span><br><span class="line">void ProcessChain(ChainNode head) &#123;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        RemoveTile(head.Position);</span><br><span class="line">        ApplySpecialEffect(head.Position);</span><br><span class="line">        head &#x3D; head.Next;</span><br><span class="line">        yield return new WaitForSeconds(0.3f); &#x2F;&#x2F; 动画间隔</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>“如何检测棋盘上的所有可消除组合？”</p>
<p>“怎样实现特殊消除效果（如L型/T型消除）？”<br>// 检测所有匹配项<br>List<Vector2Int> FindAllMatches(int[,] grid) {<br>    var matches = new List<Vector2Int>();<br>    int width = grid.GetLength(0);<br>    int height = grid.GetLength(1);</p>
<pre><code>// 水平检测
for (int y = 0; y &lt; height; y++) {
    for (int x = 0; x &lt; width - 2; x++) {
        if (grid[x, y] &gt; 0 &amp;&amp; 
            grid[x, y] == grid[x+1, y] &amp;&amp; 
            grid[x, y] == grid[x+2, y]) {
            matches.Add(new Vector2Int(x, y));
            matches.Add(new Vector2Int(x+1, y));
            matches.Add(new Vector2Int(x+2, y));
        }
    }
}

// 垂直检测（类似逻辑）
// ...

return matches.Distinct().ToList();</code></pre><p>}</p>
<p>问题：”如何实现随着玩家水平变化的难度系统？”</p>
<p>public class DifficultyAdjuster {<br>    private float playerSuccessRate;<br>    private int gamesPlayed;</p>
<pre><code>public int GetAdjustedLevel(int baseLevel) {
    float difficultyFactor = Mathf.Clamp(1.5f - playerSuccessRate, 0.5f, 2f);
    return Mathf.RoundToInt(baseLevel * difficultyFactor);
}

public void UpdateSuccess(bool levelPassed) {
    gamesPlayed++;
    playerSuccessRate = (playerSuccessRate * (gamesPlayed - 1) + (levelPassed ? 1 : 0)) / gamesPlayed;
}</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/31/2020-01-31/" data-id="cmcvp1llh000g0mz86wwianfo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-30" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/30/2020-01-30/" class="article-date">
  <time datetime="2020-01-30T12:53:28.000Z" itemprop="datePublished">2020-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/30/2020-01-30/">洗牌算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原理：遍历所有牌（52+大小王），每张牌随机一个小于54的数，交换当前遍历的index和随机数对应数组下标的值。random 方法为伪随机，并非等概率随机。<br>c#实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">　　private static void Shuffle ()  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F; 扑克牌初始化   </span><br><span class="line">    List&lt;string&gt; allCard &#x3D; new List&lt;string&gt;();  </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 54; i++) &#123;  </span><br><span class="line">         allCard.Add(i); </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 定义随机数  </span><br><span class="line">    Random random &#x3D; new Random ();  </span><br><span class="line">    &#x2F;&#x2F; 从数组的最后一个数开始递减  </span><br><span class="line">    for (int i &#x3D; allCard.Count - 1; i &gt; 0; i--) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 随机下标  </span><br><span class="line">        int index &#x3D; random.Next (0, i);  </span><br><span class="line">        &#x2F;&#x2F; 随机出来的数与最后位置的数交换  </span><br><span class="line">        string temp &#x3D; allCard [i];  </span><br><span class="line">        allCard [i] &#x3D; allCard [index];  </span><br><span class="line">        allCard [index] &#x3D; temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    foreach (string item in allCard) &#123;  </span><br><span class="line">        Console.WriteLine (item);  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>获取牌类型：数组值除以13是否大于4，是则是大小王，否则为普通牌<br>c#实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">　　for (int i &#x3D; 0; i &lt; allCard.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (allCard [i] &#x2F; 13 &gt; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        if (allCard [i] % 4 &#x3D;&#x3D; 1)</span><br><span class="line">           &#123;</span><br><span class="line">                &#x2F;&#x2F;小王</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">                &#x2F;大王</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;cardType为0时为黑桃，以次类推，cardNum代表A到K，可以以cardType_cardNum作为牌图片索引。</span><br><span class="line">        int cardType &#x3D; allCard [i] &#x2F; 13;</span><br><span class="line">        int cardNum &#x3D; allCard [i] % 13;</span><br><span class="line">    &#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/30/2020-01-30/" data-id="cmcw1g2uo002wz4z83n43fb4f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-29" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/29/2020-01-29/" class="article-date">
  <time datetime="2020-01-29T12:53:23.000Z" itemprop="datePublished">2020-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/29/2020-01-29/">unity 性能优化之CPU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>影响性能的因素：对于一个游戏来说，有两种主要的计算资源：CPU和GPU，它们会互相合作，来让我们的游戏可以在预期的帧率和分辨率下工作。CPU负责其中的帧率，GPU主要负责分辨率相关的一些东西。本篇会介绍CPU的优化技巧~</p>
<p>CPU：</p>
<p>作用：计算。主要是在蒙皮骨骼计算，布料模拟，顶点动画，粒子模拟等，还有在各种顶点变换、光照、贴图混合等。在每次绘图前，我们都需要先准备好顶点数据（位置、法线、颜色、纹理坐标等），然后调用一系列API把它们放到GPU可以访问到的指定位置，最后，我们需要调用_glDraw<em>命令，来告诉GPU进行渲染。而调用_glDraw</em>命令的时候，就是一次Draw Call。影响CPU效率的因素主要有DrawCall、物理组件、GC、代码，CPU过高会影响帧率，卡顿、发热严重，游戏性能就会下降。</p>
<p>性能开销：引擎模块性能开销和自身代码性能开销。其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。其中渲染模块、UI模块和加载模块，往往占据了游戏CPU性能开销的Top3。</p>
<p>优化：<br>DrawCalls：Draw Call是渲染模块优化方面的重中之重，一般来说，Draw Call越高，则渲染模块的CPU开销越大。<br>Drawcall batching：Unity在运行时可以将一些物体进行合并，从而用一个批次调用来渲染他们。对于使用同一个材质的物体，它们之间的不同仅仅在于顶点数据的差别，即使用的网格不同而已。我们可以把这些顶点数据合并在一起，再一起发送给GPU，就可以完成一次批处理。Unity中有两种批处理方式：一种是动态批处理，一种是静态批处理。但不论静态批次还是动态批次都要求对象的材质是共享的，即不同材质的对象是无法进行批次的。而且要注意的一点：如果在脚本中调用材质时，使用Renderer.material会造成材质的拷贝，而使用Renderer.sharedMaterial来调用则不会拷贝材质。对于动态批处理来说，好消息是一切处理都是自动的，不需要我们自己做任何操作，而且物体是可以移动的，但坏消息是，限制很多，可能一不小心我们就会破坏了这种机制，导致Unity无法批处理一些使用了相同材质的物体。对于静态批处理来说，好消息是自由度很高，限制很少，坏消息是可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了。</p>
<p>Unity进行动态批处理对模型的要求很多：<br>1.动态批处理仅支持小于900顶点的网格物体，如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。而且未来顶点值有可能会变，不要依赖这个数据。<br>2.一般来说，所有对象都必须需要使用同一个缩放尺度（可以是(1, 1, 1)、(1, 2, 3)、(1.5, 1.4, 1.3)等等，但必须都一样）。但如果是非统一缩放（即每个维度的缩放尺度不一样，例如(1, 2, 1)），那么如果所有的物体都使用不同的非统一缩放也是可以批处理的。<br>3.拥有lightmap的物体含有额外（隐藏）的材质属性，使用lightmap的物体不会批处理。多通道的shader会妨碍批处理操作。接受实时阴影的物体也不会批处理。<br>4.时刻警惕透明物体，透明对象要得到正确的渲染效果，就必须从后往前渲染（这里不讨论使用深度的方法），这意味着，透明物体几乎一定会造成overdraws。尽可能把多张小纹理合并到一张大纹理（Atlas图集）中是一个好主意。“Generate Mip Maps”会为同一张纹理创建出很多不同大小的小纹理，构成一个纹理金字塔。而在游戏中可以根据距离物体的远近，来动态选择使用哪一个纹理。这是因为，在距离物体很远的时候，就算我们使用了非常精细的纹理，但肉眼也是分辨不出来的，这种时候完全可以使用更小、更模糊的纹理来代替，而这大量可以节省访问的像素的数目。但它的缺点是，由于需要为每一个纹理建立一个图像金字塔，因此它会需要占用更多的内存。“Max Size”决定了纹理的长宽值，如果我们使用的纹理本身超过了这个最大值，Unity会对其进行缩小来满足这个条件。这里再重复一点，所有纹理的长宽比最好是正方形，而且长度值最好是2的整数幂。这是因为有很多优化策略只有在这种时候才可以发挥最大效用。</p>
<p>物理组件：从性能优化的角度考虑，物理组件能少用还是少用为好。1.设置一个合适的Fixed Timestep（物理计算频率）。2.就是不要使用网格碰撞器（mesh collider）。</p>
<p>GC优化：GC能释放内存，但会加重CPU的负担，因此对于GC的优化目标就是尽量少的触发GC。GC不是用来处理引擎的assets（纹理啦，音效啦等等）的内存释放的，GC也主要是针对Mono的对象来说的，而它管理的也是Mono的托管堆。引用类型，比如类的实例，字符串，数组等会被分配到托管堆。GC触发：首先是堆的内存不足时，会自动调用GC。其次，编程人员手动的调用GC。</p>
<p>UI模块：</p>
<p>1.使用图集：合理拆分UI图集，区分公共图集（常驻）和非公共图集。太大容易造成冗余加载，容易导致内存占用过大，导致内存显存交换开销。太小有容易导致显存碎片影响效率。</p>
<p>2.使用九宫格降低图片大小。使用镜像图片，镜像片图片使用链接：<a href="https://zhuanlan.zhihu.com/p/25995971" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25995971</a></p>
<p>3.layout group, canvas group组件，任何子节点变了父节点都会用getcompent找到laygroup</p>
<p>4.不需要交互的UI的Raycast target关了。</p>
<p>5.尽量不用UI特效。</p>
<p>加载模块：场景切换时的主要性能开销主要体现在两个方面，前一场景的场景卸载和下一场景的场景加载。</p>
<p>1.场景卸载：destory:引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑.Resources.UnloadUnusedAssets:一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。</p>
<p>2.场景加载：资源加载：其加载效率主要取决于资源的加载方式（Resource.Load或AssetBundle加载）、加载量（纹理、网格、材质等资源数据的大小）和资源格式（纹理格式、音频格式等）等等。Instantiate实例化：在Instantiate实例化时，引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力。场景加载尽量使用使用加载的方式。</p>
<p>代码优化：<br>1.字符串连接的处理。因为将两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被GC当做垃圾回收。字符串的链接使用StringBuilder进行链接。<br>2.尽量不要使用foreach，而是使用for。foreach其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来24 Bytes的垃圾。那么循环10次就是240Bytes。<br>3.不要直接访问gameobject的tag属性。比如if (go.tag == “human”)最好换成if (go.CompareTag (“human”))。因为访问物体的tag属性会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。<br>4.使用对象“池”，以实现空间的重复利用。<br>5.最好不用LINQ的命令，因为它们会分配临时的空间，同样也是GC收集的目标。而且我很讨厌LINQ的一点就是它有可能在某些情况下无法很好的进行AOT编译。比如“OrderBy”会生成内部的泛型类“OrderedEnumerable”。这在AOT编译时是无法进行的，因为它只是在OrderBy的方法中才使用。所以如果你使用了OrderBy，那么在IOS平台上也许会报错。<br>6.最好不要频繁使用GetComponent，尤其是在循环中（频繁的调用GetComponent方法会造成CPU的开销，但是对GC几乎没有影响。GetComponent只会在EDITOR模式返回NULL时会造成额外的堆内存分配）。<br>7.善于使用OnBecameVisible()（当renderer(渲染器)在任何相机上可见时调用OnBecameVisible）和OnBecameInVisible(),来控制物体的update()函数的执行以减少开销。<br>8.使用内建的数组，比如用Vector3.zero而不是new Vector(0, 0, 0);<br>9.对于方法的参数的优化：善于使用ref关键字。值类型的参数，是通过将实参的值复制到形参，来实现按值传递到方法，也就是我们通常说的按值传递。复制嘛，总会让人感觉很笨重。比如Matrix4x4这样比较复杂的值类型，如果直接复制一份新的，反而不如将值类型的引用传递给方法作为参数。</p>
<p>10.如果可以避免使用浮点型(float)，尽量使用整形(int)，尽量少用复杂的数学函数比如 Sin 和 Cos 等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/29/2020-01-29/" data-id="cmcw2gdw10005hnz870xkbbd0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-28" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/28/2020-01-28/" class="article-date">
  <time datetime="2020-01-28T12:53:13.000Z" itemprop="datePublished">2020-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/28/2020-01-28/">Unity 性能优化之GPU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GPU：负责整个渲染流水线。它会从处理CPU传递过来的模型数据开始，进行Vertex Shader、Fragment Shader等一系列工作，最后输出屏幕上的每个像素。因此它的性能瓶颈包括顶点、像素、显存等因素有关。<br>GPU的瓶颈主要存在在如下的方面：<br>1.像素分辨率，可以简单的理解为图形处理单元每秒渲染的像素数量，可以在unity的Player Settings中设置降低分辨率。<br>2.像素的复杂度，比如动态阴影，光照，复杂的shader等等<br>3.几何体的复杂度（顶点数量）<br>4.GPU的显存带宽：存储带宽是指GPU在其特定的内存上的读写速率</p>
<p>优化：<br>1减少绘制的数目：尽可能减少模型中三角形的数目，尽可能重用顶点，对于GPU来说，它本质上只关心有多少个顶点。因此，尽可能减少顶点的数目其实才是我们真正对需要关心的事情。移除不必要的Hard Edge以及纹理衔接，即避免Smoothing splits和UV splits。遮挡剔除是用来消除躲在其他物件后面看不到的物件，这代表资源不会浪费在计算那些看不到的顶点上，进而提升性能。控制绘制顺序，主要原因是为了最大限度的避免overdraws，也就是同一个位置的像素可以需要被绘制多变。在Unity中，那些Shader中被设置为“Geometry” 队列的对象总是从前往后绘制的，而其他固定队列（如“Transparent”“Overla”等）的物体，则都是从后往前绘制的。这意味这，我们可以尽量把物体的队列设置为“Geometry” 。减少实时光照，使用Lightmaps，使用God Rays，使用mobile版的shader。。 LOD技术有点类似于Mipmap技术，不同的是，LOD是对模型建立了一个模型金字塔，根据摄像机距离对象的远近，选择使用不同精度的模型。它的好处是可以在适当的时候大量减少需要绘制的顶点数目。它的缺点同样是需要占用更多的内存，而且如果没有调整好距离的话，可能会造成模拟的突变。</p>
<p>2.LOD：LOD（level of detail）技术可以用来减少较远网格的复杂度，通过减少需要渲染的顶点数量同时不影响游戏的表现效果。菜单Component-Rendering-LODGroup。</p>
<p>3.优化显存带宽：主要途径是减少贴图的内存占用来提高游戏的性能，贴图压缩 贴图压缩可以极大的减少贴图在磁盘和内存中的占用率。如果游戏的内存是我们的限制因素，则压缩贴图可以提高游戏的性能。使用mipmap，MipMap会占用内存，但能提高图片渲染的质量（比压缩要好）。</p>
<p>4.游戏中的图像特效会极大的造成像素问题，特别是有多个图像特效。如果游戏受到像素的影响同时又采用了图像特效，则最好对图像特效进行优化，比如用优化后的爆炸特效来替代优化前的爆炸特效。特别是在同一个相机上有多个图像特效，这会造成多个shader pass，这种情况下最好将多个图像特效合并在一个shader pass中。如果这样设置都不能解决问题，则最好考虑是否能不用图像特效，特别是在低端机上。</p>
<p>5.如果游戏中的模型网格没有使用法线贴图，则可以在导入设置的时候剔除切线顶点来减少顶点数量。</p>
<p>6.警惕透明物体。GUI大多数被设置成半透明，尽量减少窗口中GUI所占的面积。如果实在无能为力，可以把GUI绘制和三维场景的绘制交给不同的摄像机，而其中负责三维场景的摄像机的视角范围尽量不要和GUI重叠。</p>
<p>7.减少实时光照。使用光照贴图Lightmaps；使用雾和体积光God Rays；使用mobile版的shader。</p>
<p>8.遮挡剔除：顾名思义就是被遮挡看不见的地方不渲染，例如墙后的物体。遮挡剔除可以CPU计算也可以GPU计算。Unity自带了OcclusiongCulling</p>
<p>9.降低渲染的分辨率：缩小Framebuff分辨率，减少ps开销和内存显存，但是会模糊，王者荣耀等很多主流游戏在Android上都降了分辨率。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/28/2020-01-28/" data-id="cmcw1g2un002vz4z8d80x9xqa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-27" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/27/2020-01-27/" class="article-date">
  <time datetime="2020-01-27T12:52:51.000Z" itemprop="datePublished">2020-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/27/2020-01-27/">2020-01-27</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 见识  读书笔记<br>date: 2020-01-27 20:52:51<br>tags: 读书笔记</p>
<hr>
<p>作者：吴军<br>作者简介：吴军毕业于清华大学计算机系（本科）和清华大学电子工程系（硕士），<br>于1993-1996年在清华任讲师，于1996年起在美国约翰霍普金斯大学攻读博士，<br>并于2002年获得计算机科学博士学位。吴军博士曾经担任谷歌资深研究员，<br>设计了谷歌中、日、韩搜索算法以及谷歌的自然语音分析器。<br>2011-2012年担任腾讯负责搜索和搜索广告等业务的副总裁，<br>后回到谷歌负责计算机自动问答项目。著有《数学之美》、《浪潮之巅》和《文明之光》。</p>
<p>10月20日<br>这本书总结一句话就是：你最终能走多远取决于你的见识<br>命运是什么？<br>作者对命运提出了自己的见解。他认为要想命好，需要信命和认命。<br>信命是知道自己有所不能，认命则似孔子所云，“不逾矩”。<br>他认为命取决于两个因素：环境的因素和我们对于未来走向规定的方向（独特的看问题的方法和行事方式）；<br>决定命运的还包括我们的习惯、行为和背后的思维方式。<br>让我想起来另一伟人的名言（撒切尔夫人，还是伊丽莎白女皇？）：<br>注意你的想法，因为它决定你的言辞和行为。<br>注意你的言辞和行动，因为它能主导你的行为。<br>注意你的行为，因为它能改变你的习惯。<br>注意你的习惯，因为它能塑造你的性格。<br>注意你的性格，因为它能决定你的命运。</p>
<p>10月26日<br>幸福是什么？<br>幸福是目的，成功是手段<br>作者认为幸福的本源有俩个，基因的传承和影响力</p>
<p>人生就像一条河，每个人都希望自己的这条河更宽更深更长，要做到更深，只能靠自己的休闲和对世界的理解，<br>要做到更宽，则要和一些志同道合的人在一起共同做一些事情。</p>
<p>世界观是什么？<br>作者认为，世界观是人类的本能，是人们认识世界的方法论，是人们认识世界的基础。<br>我们必须承认，任何社会都是分层次的，所谓好一点的社会不过是有一个上下层之间的通道，<br>让人员可以流动而已，没有一个国家，一个社会会过两年就把现在的金字塔打碎，然后再随机建造一个，<br>所以逆袭者的目标无非是在金字塔上往上走几层。虽然我们抱怨社会阶层固化，但往下的通道永远非常宽，<br>只要稍微不努力或者多抱怨几句，就能外下走几层，相反，往上的通道即便再宽，往上走也是一件辛苦的事，<br>有时需要一辈子或者几代人的努力才能完成。</p>
<p>婚姻是什么？<br>只有聪明的人才会欣赏聪明的人，从优生学来说，母亲的智力水平对孩子的智力水平影响力比父亲更大<br>找一个好的配偶，对自己的投资和职业都有帮助<br>除了迷人，有气质，聪明，一个女生自己对恋爱和未来家庭的看法也很重要。<br>完美的爱情并不意味着完美的婚姻，世界上没有什么老实和不老实的男人之分，只有对你好和不好之分。维持长久的婚姻靠对方老实是没有用的。<br>精英家庭：父母成熟，首先自己要不断进步，大气，开朗，不斤斤计较，不倚老卖老，学习的愿望很强烈，愿意尝试新的东西，接受新鲜事物。</p>
<p>11月26日 天气阴<br>Study as if you were to live forerver,live as if you were to die tomorrow.<br>生也有崖，知也无涯，提醒自己少做无用的事，做好有用事情，找到无关紧要的事情，然后下决心把那些事情放弃掉。</p>
<p>首先要能够跳出思维定式，换一个角度来判断一件事情的重要性，其次，敢于舍弃。</p>
<p>我们需要记住幸福生活才是根本，其他都不过是达成这个目的的手段而已，如果我们能够每天出门的时候想到<br>‘责任’，‘荣誉’，‘从容’，‘镇定’，就能比18世纪的贵族过的更好。</p>
<p>任何时候都不要屈服于恐惧和压力，只要你们充满自信，任何时候你们都是强大的，是不可战胜的。</p>
<p>10月28日 天气阴<br>见识是什么？<br>见识需要突破自我设限的那堵墙，有时是狭隘的自我认识抑或是膨胀的自我认识。</p>
<p>教育观/管理观<br>故善者因之，其次利导之，其次教诲之，其次整齐之，最下者与之争。<br>很多时候，成败与否取决于见识的高低，而不是自己简单的努力，见识的高低，取决于我们的环境。</p>
<p>父母的见识其实才是起跑线，人生的学习何时都不晚。</p>
<p>善于把过去看似没有什么大用的经历，变成日后成功的财富。<br>如果我们有足够的耐心，有好的办法，有持之以恒的努力，或许运气会降临到我们头上的。如果努力了，运气没有来，<br>我们要宽慰自己：问心无愧是我们唯一稳得的报酬，我能能做的不过是尽人事听天命而已。</p>
<p>11月1日 天气阴<br>关于企业经营<br>1、把产品做成牙刷培养用户每天使用习惯。可靠和稳定；<br>2、从本质种寻找商业模式，提供有用的内容，内容不一定是自己生产的。<br>3、薪火相传，公司的基因，把成熟的果实交个他人看管自己负责最需要支持，最需要资源的新业务。</p>
<p>11月2日 天气阴<br>关于投资，<br>不做自己看不懂的事情<br>不要做空股票<br>永远不要用杠杆投资，人的一生不需要俩次富有<br>关于销售<br>销售的本质：把钱收回来<br>持续的生意是让顾客买的东西用光，做生意必须照顾人的面子<br>如果我们能够照顾别人的面子，生意就能做好，事情就能做好；<br>如果我们为别人提供价值，而不是一味的推销，我们的产品，甚至我们自己，就会受欢迎。</p>
<p>11月3日 天气阴<br>拒绝伪工作者，效率的高低不取决于开始了多少工作，而在于完成了多少工作。<br>怎样防止员工成为伪工作者，首先管理者要让员工站在做什么事情能够让公司最大获益的高度去工作，其次管理者要让员工明白，他们积极工作，最大的受益方是自己。<br>伪工作特征<br>既不能为公司带来较大收益，也不能给用户带来价值的改进和升级。<br>明明可以通过学习一种新技能更有效的工作，切偏偏要守着过去的旧工具<br>做事情前不认真思考，做事时通过简单的试错方法盲目找答案<br>做产品不讲究质量，不认真测试，上线后不停的修补，总是在花费很多的时间和精力找漏洞和打补丁。<br>不注重用有限的资源解决95%的问题，而是大部分时间和精力用于纠结不重要的5%的问题<br>每次开会找大量不必要的人旁听，或者总是去参加那些不必要的会议。</p>
<p>11月4日 天气阴<br>10000小时的定律误区：<br>1、简单重复<br>2、习惯性失败<br>3、在自己的世界里精进，对外界越排斥<br>4、狗熊掰棒子，没有积累效应，第二次的努力时要最大限度的用第一次努力的结果。</p>
<p>确立 ‘愿景 – 目标（战略） –道路（战术）‘<br>即使不中听的话，也要试着找到其中合理之处。<br>凡事做记录，这样可以避免狗熊掰棒子<br>OKR–目标关键结果<br>做好最后的1%，不要狗尾续貂</p>
<p>11月26日 天气晴<br>工作时大家谋生的手段，职业时我们一辈子都要从事的事业，对待自己的职业，需要专业的态度，<br>一切以工作目标的达成为目的，永远要明确工作不是为了公司或者他人，而是为了自己的职业发展。</p>
<p>把自己仅仅当成一个单位的过客，而不是主人，心态的变化，造成不求上进，浪费时间，注重长期收益，<br>把一件事情放到两三年的时间周期来规划和对待，这时我们对他的态度就不会不同。<br>被语言暴力激怒后就乱了章法。<br>疏于沟通，大部分时间，提前打招呼总是一个良好的，职业的做事方式。<br>第一份工作应该让自己快速成长，养成良好的职业习惯，最短的时间内了解全行业。</p>
<p>五级工程师的职业发展<br>1、初级工程师：能够独立解决问题，完成工程工作<br>2、中级工程师：能够指导和带领其他人一同完成更有影响力的工作<br>3、高级工程师：能够独立并设计和完成产品，并且在市场上获得成功<br>4、资深工程师：能够设计和实现别人不能做出的产品，别人无法完成的工作<br>5、首席工程师：能够开创一个产业</p>
<p>基层员工要抬起头，管理层要弯下腰。<br>善于沟通的人会理解对方的提问和目的，然后提供有用的信息<br>关注细节</p>
<p>技术不是万能的，凡事做到50分靠常识，50-90分靠技术，任何事情做到90分后单纯靠技术就很难提高了，要靠艺术。</p>
<p>11月27日 天气晴<br>商业的本质<br>商业的本质就是让人多花钱而不是省钱。<br>经营和管理的秘诀—不给选择<br>第三眼美女新产品在市场哈桑成功的三阶段<br>第一眼，科技（产品）敏感型但是有瑕疵<br>第二眼，高端消费型<br>第三眼，推广型</p>
<p>11月28日 天气晴<br>理性的投资观<br>1、钱时上帝存在你那里的，不是给你的，回头还要还给他<br>钱只有花出去的才是你的，钱的本质就是对各种资源（自然资源和社会资源）的所有权和使用权的量化度量。<br>让钱发挥最大的效能，最好的办法就是利用他把今天过好。<br>钱和任何东西，都是为了让你生活的更好，而不是给你带来麻烦<br>钱时挣出来的，不是省出来的，而挣钱的效率取决于一个人的气度<br>给钱花不光，但是可以迅速投光</p>
<p>风险意识<br>生活还总给你任何事情都是有风险，都要有风险的意识，远防垃圾人<br>任何好的投资，都要建立在控制风险意识的基础上</p>
<p>投资的行为要围绕目的进行，针对时保值，养老等不同目的设置投资方式，还要制定可行的目标。<br>选择投资对象的考量原则<br>回报和风险<br>流动性：存款的流动性最好，股票次之，债券再次，房市最差<br>准入成本，股票买卖要手续费，买卖房子要交手续费和税费。</p>
<p>投资总的误区，贵重的金属是好的投资，只有经济危机和战乱时才会升值。<br>专业的人士理财一定比我们自己做的好，管理基金的人和投资的人有利益冲突。<br>在股市花时间研究的人越多，回报就越高。<br>只要有人买股票就会不断涨。<br>哪怕我买的股票亏了钱，只要我不卖，就没有损失。</p>
<p>围绕投资目的进行资产配置，<br>如果投资为了长期稳定性的增值，那么投资的效果主要取决于资产的配置，而非那一只股票的选择，或哪一次投资机会的把握。</p>
<p>11月1日 天气晴<br>好好说话<br>说话做事是要达到目的，怎么说服人，事实比口才更重要，不要证明比对方高明，要让大家去正视事实。</p>
<p>一个人成功与否不仅仅取决于个人能力，还要靠他的调动资源的能力，聪明的人总是善于借力的。<br>如何做好演讲，能够把一件事情讲透，3-5哥要点提到即可。<br>我们是谁，过去几年做了什么。<br>我们能提供什么核心价值，核心竞争力。<br>我们的投资哲学，方法论。<br>我们对要做的事业的看法，对行业的了解。<br>我们对所谓的趋势的看法，趋势来源于事实的积累。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/27/2020-01-27/" data-id="cmcw2gdvz0003hnz86k4u13hu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-26" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/26/2020-01-26/" class="article-date">
  <time datetime="2020-01-26T12:52:44.000Z" itemprop="datePublished">2020-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/26/2020-01-26/">Unity 性能优化之UGUI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、界面制作<br>1.在UI界面中，因为一个Canvas下的所有UI元素都是合在一个Mesh中的，过大的Mesh在更新时开销很大，所以一般建议每个较复杂的UI界面，都自成一个Canvas(可以是子Canvas)，在UI界面很复杂时，甚至要划分更多的子Canvas。同时还要注意动态元素和静态元素的分离，因为动态元素会导致Canvas的mesh的更新。最后，Canvas又不能细分的太多，因为会导致Draw Call的上升。</p>
<p>2.UWA性能检测报告中的Shared UI Mesh：<br>Shared UI Mesh作为静态全局变量，由底层直接维护，其大小与当前场景中所有激活的UI元素所生成的网格数相关。一般来说当界面上UI元素较多，或者文字较多时该值都会较高，在使用UI/Effect/shadow和UI/Effect/Outline时需要注意该值，因为这两个Effect会明显增加文字所带来的网格数。</p>
<p>3.打包图集：设计UI时要考虑重用性，如一些边框、按钮等，这些作为共享资源，放在1<del>3张大图集中，称为重用图集；其它非重用UI按照功能模块进行划分，每个模块使用1</del>2张图集，为功能图集；对于一些UI，如果同时用到功能图集与重用图集，但是其功能图集剩下的“空位”较多，则可以考虑将用到的重用图集中的元素单独拎出来，合入功能图集中，从而做到让UI只依赖于功能图集。也就是通过一定的冗余，来达到性能的提升。</p>
<p>4.把Packing Tag相同的源纹理文件，打到同一个AssetBundle中（设置一样的AssetBundle Name），从而避免Atlas的冗余。同时这样打包可以让依赖它的Canvas的打包更加自由，即不需要把依赖它的Canvas都打在一个AssetBundle中，在更新时直接更新Atlas所在的AssetBundle即可。</p>
<p>5.ScrollRect在滚动的时候，会产生Canvas.SendwillRenderCanvases:<br>ScrollRect在滚动时，会产生OnTransformChanged的开销，这是UI元素在移动时触发的，但通常这不会触发Canvas.SendWillRenderCanvases。<br>如果观察到Canvas.SendWillRenderCanvases耗时较高，可以检查下ScrollRect所在的Canvas是否开启了Pixel Perfect的选项，该选项的开启会导致UI元素在发生位移时，其长宽会被进行微调（为了对其像素），而ScrollRect中通常有较多的UI元素，从而产生较高的Canvas.SendWillRenderCanvases开销。因此可以尝试关闭Pixel Perfect看效果是否可以接受，或者尝试在滚动过程中暂时关闭Pixel Perfect等方式来消除其开销。</p>
<p>6.在整体游戏内存压力不大的情况下，常用界面可以预先在加载在场景（Scene）中，对加载完成的界面进行缓存，确保下一次打开时不会再卡顿。</p>
<p>7.少用mask：Mask对于uGUI性能来说是噩梦一般的存在，因为很可能因为这个东西，导致Drawcall数量成倍增长。Mask实现的具体原理是一个Drawcall来创建Stencil mask(来做像素剔除)，然后画所有子UI，再在最后一个Drawcall移掉Stencil mask。这头尾两个Drawcall无法跟其他UI操作进行Batch，所以表面上看加个Mask就会多2个Drawcall，而且Mask中的UI元素无法与其他batch，所以很多原本可以合并的UI就无法合并了，从而增加DrawCall</p>
<p>8.关注相邻对象的合批问题，通过重新排列可绘制对象的顺序、调整对象的位置以消除不可见的重叠空间等方式减少DC</p>
<p>9.合理利用子Canvas处理一个界面过大、动静分离等问题，但要注意不同Canvas不会合批</p>
<p>10.关闭不需要的Raycast Target，仅在必须接收指针事件的UI组件上启用“ Raycast Target”设置。Graphic Raycaster会检测将“ Raycast Target”设置为true的所有Graphic组件。对于每个Raycast Target，Raycaster都会执行一组测试。</p>
<p>二、网格<br>1.如果修改的是Image组件上的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的（即Canvas.BuildBatch操作，同时也会有Canvas.SendWillRenderCanvases的开销）。而通过修改顶点色来实现UI元素变色的好处在于，修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call。</p>
<p>2.在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。</p>
<p>3.在 UGUI 中，Batch是以Canvas为单位的，即在同一个Canvas下的UI元素最终都会被Batch到同一个Mesh中。而在Batch前，UGUI会根据这些UI元素的材质（通常就是Atlas）以及渲染顺序进行重排，在不改变渲染结果的前提下，尽可能将相同材质的UI元素合并在同一个SubMesh中，从而把DrawCall降到最低。而Batch的操作只会在UI元素发生变化时才进行，且合成的Mesh越大，操作的耗时也就越大。<br>因此，尽可能把频繁变化（位置，颜色，长宽等）的UI元素从复杂的Canvas中分离出来，从而避免复杂的Canvas频繁重建。在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将动态UI元素与静态UI元素分离后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。而静态UI元素所在的Canvas则不会出现网格更新和重建的开销。</p>
<p>4.多人同屏的时候，人物移动会使得头顶上的名字Mesh重组，从而导致较为严重的卡顿：<br>如果是用UGUI开发的，当头顶文字数量较多时，确实很容易引起性能问题，可以考虑从以下几点入手进行优化：<br>尽可能避免使用UI/Effect，特别是Outline，会使得文本的Mesh增加4倍，导致UI重建开销明显增大；<br>拆分Canvas，将屏幕中所有的头顶文字进行分组，放在不同的Canvas下，一方面可以降低更新的频率（如果分组中没有文字移动，该组就不会重建），另一方面可以减小重建时涉及到的Mesh大小（重建是以Canvas为单位进行的）；<br>降低移动中的文字的更新频率，可以考虑在文字移动的距离超过一个阈值时才真正进行位移，从而可以从概率上降低Canvas更新的频率。</p>
<p>三、界面切换：<br>1.把被覆盖的界面 SetActive(False)，但发现后续 SetActive(True) 的时候会有 GC.Alloc 产生。这种情况下，希望既降低 Batches 又降低 GC Alloc 的话<br>可以尝试通过添加一个 Layer 如 OutUI， 且在 Camera 的 Culling Mask 中将其取消勾选（即不渲染该 Layer）。从而在 UI 界面切换时，直接通过修改 Canvas 的 Layer 来实现“隐藏”。但需要注意事件的屏蔽，禁用动态的 UI 元素等等。这种做法的优点在于切换时基本没有开销，也不会产生多余的 Draw Call，但缺点在于“隐藏时”依然还会有一定的持续开销（通常不太大），而其对应的 Mesh 也会始终存在于内存中（通常也不太大）。<br>2.GC Alloc 并不是由Instantiate 直接引起的，而是因为被实例化出来的组件会进行 OnEnable 操作，而在 OnEnable 操作中产生了 GC，<br>因此，我们不建议通过 Instantiate/Destroy 来处理切换频繁的 UI 界面，而是通过 SetActive(true/false)，甚至是直接移动 UI 的方式，以避免反复地造成堆内存开销。</p>
<p>3.全屏界面下的3d对象，可以通过隐藏3d对象父节点或隐藏3d相机减少消耗。对于能看到一小部分3d对象的界面，可以通过屏幕截图的方式保存一个备份并显示在界面底部，从而释放底下的3d资源。</p>
<p>4.合并图片（例如道具框和道具底图），透明度为0的对象任然会消耗渲染资源，这种对象尽量隐藏掉。</p>
<p>四、加载相关<br>加载UI预制的时候，如果把特效放到预制里，会导致加载非常耗时：<br>UI和特效（粒子系统）的加载开销在多数项目中都占据较高的CPU耗时。UI界面的实例化和加载耗时主要由以下几个方面构成：</p>
<p>纹理资源加载耗时，UI界面加载的主要耗时开销，因为在其资源加载过程中，时常伴有大量较大分辨率的Atlas纹理加载，我们在之前的Unity加载模块深度分析之纹理篇有详细讲解。对此，我们建议研发团队在美术质量允许的情况下，尽可能对UI纹理进行简化，从而加快UI界面的加载效率。</p>
<p>UI网格重建耗时，UI界面在实例化或Active时，往往会造成Canvas（UGUI）或Panel（NGUI）中UIDrawCall的变化，进而触发网格重建操作。当Canvas或Panel中网格量较大时，其重建开销也会随之较大。<br>UI相关构造函数和初始化操作开销，这部分是指UI底层类在实例化时的ctor开销，以及OnEnable和OnDisable的自身开销。<br>上述2和3主要为引擎或插件的自身逻辑开销，因此，我们应该尽可能避免或降低这两个操作的发生频率。我们的建议如下：<br>在内存允许的情况下，对于UI界面进行缓存。尽可能减少UI界面相关资源的重复加载以及相关类的重复初始化；<br>根据UI界面的使用频率，使用更为合适的切换方式。比如移进移出或使用Culling Layer来实现UI界面的切换效果等，从而降低UI界面的加载耗时，提升切换的流畅度。<br>对于特效（特别是粒子特效）来说，我们暂时并没有发现将UI界面和特效耦合在一起，其加载耗时会大于二者分别加载的耗时总和。因此，我们仅从优化粒子系统加载效率的角度来回答这个问题。粒子系统的加载开销，就目前来看，主要和其本身组件的反序列化耗时和加载数量相关。对于反序列化耗时而言，这是Unity引擎负责粒子系统的自身加载开销，开发者可以控制的空间并不大。对于加载数量，则是开发者需要密切关注的，因为在我们目前看到的项目中，不少都存在大量的粒子系统加载，有些项目的数量甚至超过1000个，如下图所示。因此，建议研发团队密切关注自身项目中粒子系统的数量使用情况。一般来说，建议我们建议粒子系统使用数量的峰值控制在400以下。</p>
<p>unload(false)卸载AssetBundle并不会销毁其加载的资源 ，是必须调用 Resources.UnloadUnusedAssets才行。<br>五、字体<br>Font.CacheFontForText主要是指生成动态字体Font Texture的开销, 一次性打开UI界面中的文字越多，其开销越大。如果该项占用时间超过2s，那么确实是挺大的，这个消耗也与已经生成的Font Texture有关系。简单来说，它主要是看目前Font Texture中是否有地方可以容下接下来的文字，如果容不下才会进行一步扩大Font Texture，从而造成了性能开销。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/26/2020-01-26/" data-id="cmcw2gdvx0001hnz84zj71ts4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-25" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/25/2020-01-25/" class="article-date">
  <time datetime="2020-01-25T12:52:40.000Z" itemprop="datePublished">2020-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/25/2020-01-25/">Unity AssetBundle 官方文档整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、为什么要使用AssetBundle</p>
<p>AssetBundle是Unity推荐的资源管理方式，热更新必须使用此方式。</p>
<p>二、AssetBundle是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">First is the actual file on disk. This we call the AssetBundle archive, or just archive for short in this document. </span><br><span class="line">The archive can be thought of as a container, like a folder, that holds additional files inside of it. </span><br><span class="line">These additional files consist of two types; the serialized file and resource files. The serialized file contains your assets broken out into their individual objects and written out to this single file.</span><br><span class="line">The resource files are just chunks of binary data stored separately for certain assets (textures and audio) to allow us to load them from disk on another thread efficiently.</span><br><span class="line"></span><br><span class="line">Second is the actual AssetBundle object you interact with via code to load assets from a specific archive. </span><br><span class="line">This object contains a map of all the file paths of the assets you added to this archive to the objects that belong to that asset that need to be loaded when you ask for it.</span><br></pre></td></tr></table></figure>
<p>1.如上，第一部分是我们在unity里看到的，生成出来的ab包文件，你可以理解成一种特殊的文件夹。我们将chariot打成ab包”animation_2d_chariot.unity3d“，然后用UnityStudio解压”animation_2d_chariot.unity3d“后的结构大概是下面这样子的</p>
<p>他所包含的资源列表如下：</p>
<p>你也可以通过.mainfest文件查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: 0</span><br><span class="line">CRC: 2785811640</span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 05555bf8d49a3c8fc690e4913454de28</span><br><span class="line">  TypeTreeHash:</span><br><span class="line">    serializedVersion: 2</span><br><span class="line">    Hash: 0317c6c2e1c00c8e914e7d09d8b3e9b0</span><br><span class="line">HashAppended: 0</span><br><span class="line">ClassTypes:</span><br><span class="line">- Class: 1</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 4</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 21</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 28</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 48</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 114</span><br><span class="line">  Script: &#123;fileID: 11500000, guid: 24fd26203f8ea48f1b25f24fc3663d1c, type: 3&#125;</span><br><span class="line">- Class: 114</span><br><span class="line">  Script: &#123;fileID: 11500000, guid: c93168c4c5e9f49bfa80fc75bd465a40, type: 3&#125;</span><br><span class="line">- Class: 114</span><br><span class="line">  Script: &#123;fileID: 11500000, guid: a6791178c999f426a8618ef42eac4275, type: 3&#125;</span><br><span class="line">- Class: 115</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 212</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">- Class: 213</span><br><span class="line">  Script: &#123;instanceID: 0&#125;</span><br><span class="line">Assets:</span><br><span class="line">- Assets&#x2F;Data&#x2F;animation&#x2F;2d&#x2F;chariot&#x2F;chariot_5.prefab</span><br><span class="line">- Assets&#x2F;Data&#x2F;animation&#x2F;2d&#x2F;chariot&#x2F;chariot_6.prefab</span><br><span class="line">Dependencies:</span><br><span class="line">- F:&#x2F;ALClient&#x2F;Assets&#x2F;Temp&#x2F;data&#x2F;shader.unity3d</span><br></pre></td></tr></table></figure>
<p>2.第二部分是脚本中使用的，例如通过unity api AssetBundle.LoadFromFile可以从指定路径加载一个AssetBundle 对象，这个要加载的对象就是上面我们说的unity里面的Asset（你可以理解成AssetBundle是一种特殊的资源，如prefabs），通过这个脚本的AssetBundle,我们可以加载出unity的AssetBundle所包含的文件</p>
<p>三、如何生成AssetBundle文件？</p>
<p>生成AssetBundle文件分两步，第一步标记你要生成AssetBundle的文件，你可以在unity面板直接指定AB包名字，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">To assign a given Asset to an AssetBundle, follow these steps:</span><br><span class="line"></span><br><span class="line">Select the asset you want to assign to a bundle from your Project View</span><br><span class="line">Examine the object in the inspector</span><br><span class="line">At the bottom of the inspector</span><br><span class="line">, you should see a section to assign AssetBundles and Variants:</span><br><span class="line">The left-hand drop down assigns the AssetBundle while the right-hand drop down assigns the variant</span><br><span class="line">Click the left-hand drop down where it says “None” to reveal the currently registered AssetBundle names</span><br><span class="line">Click “New…” to create a new AssetBundle</span><br><span class="line">Type in the desired AssetBundle name. Note that AssetBundle names do support a type of folder structure depending on what you type. To add sub folders, separate folder names by a “&#x2F;”. For example: AssetBundle name “environment&#x2F;forest” will create a bundle named forest under an environment sub folder</span><br><span class="line">Once you’ve selected or created an AssetBundle name, you can repeat this process for the right hand drop down to assign or create a Variant name, if you desire. Variant names are not required to build the AssetBundles</span><br><span class="line"></span><br><span class="line">1.选中该Project中要导出ab包的文件。2在Inspect底部设置AssetBundle</span><br></pre></td></tr></table></figure>


<p>但是一般不推荐这种手撸的方法（大项目动辄几万个文件。。。），一般使用脚本动态进行设置，如下，主要就是针对你要导出的文件、文件夹调用AssetImporter.SetAssetBundleNameAndVariant方法动态设置ab包，你可以进一步封装，例如文件夹xxx目录下的所有文件都设置成单独的ab包或者只有子目录设置ab包等等，这种方法会比手撸效率高很多，只需要设置一次需要导出abbb包的文件，然后在每次打包都调用指定的方法进行ab包设置就好了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置单个文件（或目录）的ABName</span><br><span class="line">    private static void ImportSingleFile(string Path, string abName)</span><br><span class="line">    &#123;</span><br><span class="line">        AssetImporter importer &#x3D; AssetImporter.GetAtPath(Path);</span><br><span class="line"></span><br><span class="line">        if (importer &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            Debugger.LogError(&quot;[路径错误] path:&#123;0&#125;&quot;, Path);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        abName &#x3D; abName.Replace (&#39;\\&#39;, &#39;_&#39;).Replace (&#39;&#x2F;&#39;,&#39;_&#39;);</span><br><span class="line">        importer.SetAssetBundleNameAndVariant(abName, BaseDef.AB_SUFFIX);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第二步，调用unity的生成ab包的接口（依赖第一步设置完的ab包名字和属性）</p>
<p>BuildPipeline.BuildAssetBundles(string outputPath, BuildAssetBundleOptions assetBundleOptions, BuildTarget targetPlatform);</p>
<p>outputPath：输出路径<br>assetBundleOptions：压缩模式等，unity提供三种压缩模式，官方说明：<a href="https://docs.unity3d.com/Manual/AssetBundles-Building.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/AssetBundles-Building.html</a></p>
<p>BuildAssetBundleOptions.None:LZMA格式压缩，使用的时候要整包解压到内存，最大的压缩比（意味着压缩后的文件最小），但第一次的加载需要更长的时间，unity会将解压后的LZMA重新压缩成LZ4格式并保存在硬盘里，意味着第二次加载将会拥有和LZ4压缩相同的加速度，unity推荐在下载时使用（如热更、高清资源），这样可以节省用户流量，加快下载速度</p>
<p>BuildAssetBundleOptions.UncompressedAssetBundle：不压缩，最大的文件，最快的加载速度<br>BuildAssetBundleOptions.ChunkBasedCompression：LZ4压缩，使用的时候不需要整包解压，即只解压当前需要的块，这是unity推荐的压缩方式（母包）</p>
<p>Using ChunkBasedCompression has comparable loading times to uncompressed bundles with the added benefit of reduced size on disk.<br>如果觉得lz4的压缩格式导致包体过大，可以将一部分ab包在压缩成lzma（将要压缩的ab包放在文件夹Temp，再将Temp压缩成LZMA格式，只在用户初次进入游戏时整个解压就好了），相当于压缩了两次</p>
<p>targetPlatform：目标平台android/ios等</p>
<p>四、AssetBundle如何分组？</p>
<p>AssetBundle 数量太少：<br>　　会增加运行时内存使用，因为可能加载了当前功能不需要使用的资源<br>　　会增加加载时间，虽然lz4压缩格式不需要整包解压，但还是会把文件头加载进来的<br>　　需要下载大量数据，包体太大，导致细分度不够，可能其中一个对象更新了会导致其他对象也更新，对热更不友好。</p>
<p>有太多的 AssetBundle:<br>　　会增加构建的时间<br>　　会加大开发的复杂性<br>　　会增加总的加载时间：一个大文件的解压时间和多个小文件的解压时间 ，文件总大小一致的话，肯定是大文件快</p>
<p>官方说明：<a href="https://docs.unity3d.com/Manual/AssetBundles-Preparing.html" target="_blank" rel="noopener">https://docs.unity3d.com/Manual/AssetBundles-Preparing.html</a></p>
<p>1.按逻辑实体（功能）分组，例如英雄界面相关的预知体一个包，副本界面相关的预制体打一个包，对热更支持最高</p>
<p>2.按类型分组，例如音效、shader、本地化文件等都单独打1-n个包，对热更版本不友好，因为包体相对会被比较大</p>
<p>3.不相干(concurrent)内容分组，将需要同时加载和使用内容分组到同一个 AssetBundle 的策略。这种策略最常用在强本地相关属性的内容上，也就是说内容很少或者基本不可能在应用特定的位置或者时间之外出现，例如某个副本关卡用到的独特的资源、模型等</p>
<p>官方的分组建议如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Regardless of the strategy you follow, here are some additional tips that are good to keep in mind across the board:</span><br><span class="line"></span><br><span class="line">1.Split frequently updated objects into AssetBundles separate from objects that rarely change</span><br><span class="line">2.Group objects that are likely to be loaded simultaneously. Such as a model, its textures, and its animations</span><br><span class="line">3.If you notice multiple objects across multiple AssetBundles are dependant on a single asset from a completely different AssetBundle, move the dependency to a separate AssetBundle. </span><br><span class="line">If several AssetBundles are referencing the same group of assets in other AssetBundles, it may be worth pulling those dependencies into a shared AssetBundle to reduce duplication.</span><br><span class="line">4.If two sets of objects are unlikely to ever be loaded at the same time, such as Standard and High Definition assets, be sure they are in their own AssetBundles.</span><br><span class="line">6.Consider splitting apart an AssetBundle if less that 50% of that bundle is ever frequently loaded at the same time</span><br><span class="line">7.Consider combining AssetBundles that are small (less that 5 to 10 assets) but whose content is frequently loaded simultaneously</span><br><span class="line">8.If a group of objects are simply different versions of the same object, consider AssetBundle Variants</span><br></pre></td></tr></table></figure>
<p>1.把经常更新的资源放在一个单独的包里面，跟不经常更新的包分离<br>2.把需要同时加载的资源放在一个包里面，如同一个功能模块。如果两个对象不太可能同时加载，比如一个纹理的高清和标清版本，可以将他们分配到不同的 AssetBundle 中<br>3.可以把其他包共享的资源放在一个单独的包里面，例如UI界面里面会有很多按钮、弹窗，而这些资源一般是所有界面通用的，那就可以把它们打1-3个图集<br>4.控制ab包体的大小，太大了，热更的话，要更新很大的文件，太小的话，io次数会很高，对性能不好</p>
<p>五、如何加载AssetBundle？</p>
<p>1.从包含AssetBundle数据的bytes 里读取</p>
<p>2.本地加载最快的接口，如果是lzma的压缩格式，会先解压到内存里（占用内存）</p>
<p>3.从网络加载（也可以从本地加载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator InstantiateObject()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        string uri &#x3D; &quot;file:&#x2F;&#x2F;&#x2F;&quot; + Application.dataPath + &quot;&#x2F;AssetBundles&#x2F;&quot; + assetBundleName;        </span><br><span class="line">　　　　 UnityEngine.Networking.UnityWebRequest request &#x3D; UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0);</span><br><span class="line">        yield return request.Send();</span><br><span class="line">        AssetBundle bundle &#x3D; DownloadHandlerAssetBundle.GetContent(request);</span><br><span class="line">        GameObject cube &#x3D; bundle.LoadAsset&lt;GameObject&gt;(&quot;Cube&quot;);</span><br><span class="line">        GameObject sprite &#x3D; bundle.LoadAsset&lt;GameObject&gt;(&quot;Sprite&quot;);</span><br><span class="line">        Instantiate(cube);</span><br><span class="line">        Instantiate(sprite);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>六、如何从AssetBundle中加载文件？</p>
<p>同步加载单个对象：T objectFromBundle = bundleObject.LoadAsset<T>(assetName);</p>
<p>异步加载单个对象：</p>
<p>AssetBundleRequest request = loadedAssetBundleObject.LoadAssetAsync<GameObject>(assetName);<br>yield return request;<br>var loadedAsset = request.asset;<br>同步加载ab包里的所有对象：Unity.Object[] objectArray = loadedAssetBundle.LoadAllAssets();</p>
<p>异步加载ab包里的所有对象：</p>
<p>AssetBundleRequest request = loadedAssetBundle.LoadAllAssetsAsync();<br>yield return request;<br>var loadedAssets = request.allAssets;<br>七、如何使用AssetBundleManifest，什么叫做依赖包？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetBundles can become dependent on other AssetBundles if one or more of the UnityEngine.Objects contains a reference to a UnityEngine.Object located in another bundle. A dependency does not occur if the UnityEngine.Object contains a reference to a UnityEngine.Object that is not contained in any AssetBundle. In this case, a copy of the object that the bundle would be dependent on is copied into the bundle when you build the AssetBundles. If multiple objects in multiple bundles contain a reference to the same object that isn’t assigned to a bundle, every bundle that would have a dependency on that object will make its own copy of the object and package it into the built AssetBundle.</span><br><span class="line"></span><br><span class="line">Should an AssetBundle contain a dependency, it is important that the bundles that contain those dependencies are loaded before the object you’re attempting to instantiate is loaded. Unity will not attempt to automatically load dependencies.</span><br><span class="line"></span><br><span class="line">Consider the following example, a Material in Bundle 1 references a Texture in Bundle 2:</span><br><span class="line"></span><br><span class="line">In this example, before loading the Material from Bundle 1, you would need to load Bundle 2 into memory. It does not matter which order you load Bundle 1 and Bundle 2, the important takeaway is that Bundle 2 is loaded before loading the Material from Bundle 1. In the next section, we’ll discuss how you can use the AssetBundleManifest objects we touched on in the previous section to determine, and load, dependencies at runtime.</span><br></pre></td></tr></table></figure>
<p>ab包依赖情况有以下两种：</p>
<p>1.ab包引用到另一个ab包里面的资源，即ab包依赖了另一个ab包，例如Bundle1材质A引用了Bundle2的贴图B，那么Bundle1就是依赖Bundle2的，在加载材质A前，你必须先加载Bundle2到内存，unity不会自动加载依赖项。也就是说在你使用某个ab包时，必须先加载他依赖的ab包。</p>
<p>2.ab包引用到另一个不再任何ab包里的资源，例如Bundle1材质A引用了贴图B，而贴图B没有打进任何ab包里，那么最终打ab包时，unity会拷贝一份贴图B到Bundle1，如果有n个Bundle都引用了贴图B，那么这n个Bundle里都会有贴图的拷贝，会造成资源冗余。</p>
<p>AssetBundleManifest文件包含了所有ab包的依赖关系，在使用ab包前，你需要先加载AssetBundleManifest文件，在通过AssetBundleManifest获取ab包的依赖ab包，AssetBundleManifest的加载：</p>
<p>AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);<br>AssetBundleManifest manifest = assetBundle.LoadAsset<AssetBundleManifest>(“AssetBundleManifest”);<br>获取依赖包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AssetBundle assetBundle &#x3D; AssetBundle.LoadFromFile(manifestFilePath);</span><br><span class="line">AssetBundleManifest manifest &#x3D; assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);</span><br><span class="line">string[] dependencies &#x3D; manifest.GetAllDependencies(&quot;assetBundle&quot;); &#x2F;&#x2F;Pass the name of the bundle you want the dependencies for.</span><br><span class="line">foreach(string dependency in dependencies)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>七、如何判断AssetBundle是否还被引用？</p>
<p>ab包的引用主要作用有两点：1.缓存ab包，卸载无用的ab包，避免内存泄漏 2.判断ab包的依赖包是否已经被加载</p>
<p>核心点是引用技术，每个AssetBundle都会维护一个引用计数，当该ab包被加载、被依赖时引用计数加1，当依赖包被卸载、加载的资源被卸载时，引用计数减1，当引用计数为0超过一段时间（一般为几分钟）时，认为该ab包已经无用了，卸载该ab包。</p>
<p>以下是一个简单的示例（不涉及到从ab包里加载资源），简单说明引用计数的用法，这个例子分两部分，一个是缓存的ab包实体类AssetBundleCache，该类维护一个自己的引用计数，一个是缓存的控制类ABCachePool，该类用于维护ab包的引用、卸载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AssetBundle缓存</span><br><span class="line">public class AssetBundleCache</span><br><span class="line">&#123;</span><br><span class="line">    string m_name;          &#x2F;&#x2F; AssetBundle name</span><br><span class="line">    int m_referencedCount;  &#x2F;&#x2F; 引用计数</span><br><span class="line">    float m_unloadTime;     &#x2F;&#x2F; 释放时间</span><br><span class="line"></span><br><span class="line">    public AssetBundleCache(string name, AssetBundle ab, int refCount)</span><br><span class="line">    &#123;</span><br><span class="line">        m_name &#x3D; name;</span><br><span class="line">        Bundle &#x3D; ab;</span><br><span class="line">        ReferencedCount &#x3D; refCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; AssetBundle</span><br><span class="line">    public AssetBundle Bundle</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">        private set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否常驻，通用资源的ab包不卸载</span><br><span class="line">    public bool Persistent</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">        set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string BundleName</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return m_name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 引用计数</span><br><span class="line">    public int ReferencedCount</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return m_referencedCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            m_referencedCount &#x3D; value;</span><br><span class="line">            if (m_referencedCount &lt;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                m_unloadTime &#x3D; Time.realtimeSinceStartup;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                m_unloadTime &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (m_referencedCount &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogWarningFormat(&quot;AssetBundleCache reference count &lt; 0, name:&#123;0&#125;, referencecount:&#123;1&#125;&quot;, m_name, m_referencedCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否可以删除</span><br><span class="line">    public bool IsCanRemove</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 常驻资源</span><br><span class="line">            if (Persistent) return false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 非常驻，并且引用计数为0</span><br><span class="line">            if (!Persistent &amp;&amp; ReferencedCount &lt;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 缓存时间到</span><br><span class="line">    public bool IsTimeOut</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return Time.realtimeSinceStartup - m_unloadTime &gt;&#x3D; Config.Instance.AssetCacheTime;&#x2F;&#x2F;这个时间自己定义</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;卸载ab包</span><br><span class="line">    public void Unload()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Bundle !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            Bundle.Unload(false);</span><br><span class="line">            Bundle &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">public class ABCachePool</span><br><span class="line">&#123;</span><br><span class="line">    #region Instance</span><br><span class="line">    private static ABCachePool m_Instance;</span><br><span class="line">    public static ABCachePool Instance</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return m_Instance ?? (m_Instance &#x3D; new ABCachePool()); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #endregion</span><br><span class="line">    Dictionary&lt;string, AssetBundleCache&gt; m_AssetBundleCaches &#x3D; new Dictionary&lt;string, AssetBundleCache&gt;();  &#x2F;&#x2F; 缓存队列</span><br><span class="line">    HashSet&lt;string&gt; m_persistentABs &#x3D; new HashSet&lt;string&gt;();</span><br><span class="line"></span><br><span class="line">    public Dictionary&lt;string, AssetBundleCache&gt; AssetBundleCaches</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return m_AssetBundleCaches;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;只有在退出游戏时会调用这个接口</span><br><span class="line">    public void ClearAllCache()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach(KeyValuePair&lt;string, AssetBundleCache&gt; keyval in m_AssetBundleCaches)</span><br><span class="line">        &#123;</span><br><span class="line">            keyval.Value.Unload();</span><br><span class="line">        &#125;</span><br><span class="line">        m_AssetBundleCaches.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;是否存在ab包缓存</span><br><span class="line">    public bool IsExistCache(string abName)</span><br><span class="line">    &#123;</span><br><span class="line">        return m_AssetBundleCaches.ContainsKey (abName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 引用这个bundle</span><br><span class="line">    public AssetBundleCache ReferenceCacheByName(string abName)</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundleCache cache &#x3D; null;</span><br><span class="line">        m_AssetBundleCaches.TryGetValue (abName, out cache);</span><br><span class="line">        if(cache!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            ++cache.ReferencedCount;</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取ABCache 不增加引用</span><br><span class="line">    public AssetBundleCache GetABCacheByName(string abName)</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundleCache cache &#x3D; null;</span><br><span class="line">        m_AssetBundleCaches.TryGetValue (abName, out cache);</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public AssetBundleCache AddCache(string abName, AssetBundle bundle, int refCount)</span><br><span class="line">    &#123;</span><br><span class="line">        if(m_AssetBundleCaches.ContainsKey (abName))</span><br><span class="line">        &#123;</span><br><span class="line">            Debugger.LogWarning (&quot;AssetBundleCache already contains key:&#123;0&#125;, it will be cover by new value.&quot;, abName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AssetBundleCache cache &#x3D; new AssetBundleCache (abName, bundle, refCount);</span><br><span class="line">        m_AssetBundleCaches [abName] &#x3D; cache;</span><br><span class="line"></span><br><span class="line">        if(m_persistentABs.Contains (abName))</span><br><span class="line">        &#123;</span><br><span class="line">            cache.Persistent &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; immediate 只有场景是立刻卸载</span><br><span class="line">    public AssetBundleCache UnReferenceCache(string abName, bool immediate &#x3D; false)</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundleCache cache &#x3D; null;</span><br><span class="line">        if (!m_AssetBundleCaches.TryGetValue(abName, out cache))</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(cache.Persistent)</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        --cache.ReferencedCount;</span><br><span class="line"></span><br><span class="line">        if (immediate &amp;&amp; cache.IsCanRemove)</span><br><span class="line">        &#123;</span><br><span class="line">            RemoveCache (abName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void RemoveCache(string abName)</span><br><span class="line">    &#123;</span><br><span class="line">        AssetBundleCache cache &#x3D; m_AssetBundleCaches [abName];</span><br><span class="line">        cache.Unload ();</span><br><span class="line">        m_AssetBundleCaches.Remove(abName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private List&lt;string&gt; m_lstRm &#x3D; new List&lt;string&gt;();</span><br><span class="line">    &#x2F;&#x2F; 清除无引用的AssetBundle缓存</span><br><span class="line">    public void ClearNoneRefCache(bool mustTimeout)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach(KeyValuePair&lt;string, AssetBundleCache&gt; keyval in m_AssetBundleCaches)</span><br><span class="line">        &#123;</span><br><span class="line">            AssetBundleCache item &#x3D; keyval.Value;</span><br><span class="line">            &#x2F;&#x2F; 只清除引用计数为0的</span><br><span class="line">            if (item.IsCanRemove &amp;&amp; (!mustTimeout || item.IsTimeOut))</span><br><span class="line">            &#123;</span><br><span class="line">                m_lstRm.Add(keyval.Key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0; i&lt;m_lstRm.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            RemoveCache(m_lstRm[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m_lstRm.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 常驻ab包设置</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;arrAB&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void SetPersistentABs(string[] arrAB)</span><br><span class="line">    &#123;</span><br><span class="line">        m_persistentABs.Clear();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; arrAB.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string strAB &#x3D; FileHelper.GenBundlePath (arrAB[i]);</span><br><span class="line">            m_persistentABs.Add(strAB);</span><br><span class="line"></span><br><span class="line">            AssetBundleCache abCache;</span><br><span class="line">            m_AssetBundleCaches.TryGetValue(strAB, out abCache);</span><br><span class="line">            if (abCache!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                abCache.Persistent &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>八、如何卸载AssetBundle？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Most projects should use AssetBundle.Unload(true) and adopt a method to ensure that Objects are not duplicated. Two common methods are:</span><br><span class="line"></span><br><span class="line">Having well-defined points during the application’s lifetime at which transient AssetBundles are unloaded, such as between levels or during a loading screen.</span><br><span class="line"></span><br><span class="line">Maintaining reference-counts for individual Objects and unload AssetBundles only when all of their constituent Objects are unused. This permits an application to unload &amp; reload individual Objects without duplicating memory.</span><br><span class="line"></span><br><span class="line">If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</span><br><span class="line"></span><br><span class="line">Eliminate all references to an unwanted Object, both in the scene and in code. After this is done, call Resources.UnloadUnusedAssets.</span><br><span class="line"></span><br><span class="line">Load a scene non-additively. This will destroy all Objects in the current scene and invoke Resources.UnloadUnusedAssets automatically.</span><br></pre></td></tr></table></figure>
<p>AssetBundle.Unload可以卸载一个AssetBundle，下面会说到这个方法</p>
<p>Resources.UnloadUnusedAssets会卸载所有不被引用的资源，具体如下图所示</p>
<p> 九、注意事项</p>
<p>1.AssetBundle.Unload(bool unloadAllLoadedObjects)</p>
<p>unloadAllLoadedObjects为true时会卸载所有从这个ab包里加载的对象（不包括instantiation对象），例如材质M加载自Bundle1，当Bundle1调用Unload（true）时，材质M也会被删除，对象会在场景中显示红色（缺失）</p>
<p>unloadAllLoadedObjects为false时不会卸载从这个ab包里加载的对象，但会断开和这个对象的联系，例如材质M加载自Bundle1，当Bundle1调用Unload（false）时，材质M不会被删除，当用户再次加载Bundle1的时候不会重新建立和材质M的联系，而是会重新创建一份引用，造成材质M的冗余，如下图，内存里会存在两个材质M，冗余了一份</p>
<p> 关于true跟false，unity官方时间以使用true的，这样不会造成冗余，但是你必须清楚的知道什么时候可以卸载这个ab包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Most projects should use AssetBundle.Unload(true) and adopt a method to ensure that Objects are not duplicated. Two common methods are:</span><br><span class="line"></span><br><span class="line">Having well-defined points during the application’s lifetime at which transient AssetBundles are unloaded, such as between levels or during a loading screen.</span><br><span class="line"></span><br><span class="line">Maintaining reference-counts for individual Objects and unload AssetBundles only when all of their constituent Objects are unused. This permits an application to unload &amp; reload individual Objects without duplicating memory.</span><br><span class="line"></span><br><span class="line">If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways:</span><br><span class="line"></span><br><span class="line">Eliminate all references to an unwanted Object, both in the scene and in code. After this is done, call Resources.UnloadUnusedAssets.</span><br><span class="line"></span><br><span class="line">Load a scene non-additively. This will destroy all Objects in the current scene and invoke Resources.UnloadUnusedAssets automatically.</span><br></pre></td></tr></table></figure>
<p>2.一个没有被分配到任何ab包中的资源A，任何引用资源A的ab包都会产生一份资源A的拷贝，这会导致游戏的ab包大小变大（资源A冗余了），如果这两个ab包都被加载到内存，那么还会导致内存里存在两份完全一样资源A。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Any Object that is not explicitly assigned in an AssetBundle will be included in all AssetBundles that contain 1 or more Objects that reference the untagged Object.</span><br><span class="line"></span><br><span class="line">If two different Objects are assigned to two different AssetBundles, but both have references to a common dependency Object, then that dependency Object will be copied into both AssetBundles. </span><br><span class="line">The duplicated dependency will also be instanced, meaning that the two copies of the dependency Object will be considered different Objects with a different identifiers. </span><br><span class="line">This will increase the total size of the application’s AssetBundles. This will also cause two different copies of the Object to be loaded into memory if the application loads both of its parents.</span><br></pre></td></tr></table></figure>
<p>解决这个问题的最优解是：把所有ab包引用的资源都打到ab包里，即ab包不引用任何不再ab包里的资源，但是这样做需要程序在加载ab包时，确认该ab包的所有依赖包都已经加载完成了（ab包缓存、ab依赖包加载）</p>
<p>3.图集：首先我们需要大概知道图集在AssetBundle里是以什么形式存在的。如下图所示，一个图集的ab包里包含了这个图集的图片资源以及图集的信息（下图的SpriteAtlasTexture-ui_atlas_elf-1024x1024-fmt12）</p>
<p>需要注意的是：</p>
<p>1.如果一个图集包含的Sprite资源被包含在多个AssetBundle里，那么所有包含该图集的Sprite的ab包都会有一份图集信息（SpriteAtlasTexture-ui_atlas_elf-1024x1024-fmt12），从上图我们看到，这个文件还是很大的</p>
<p>2.如果一个图集包含的Sprite资源不再任何ab包里，那么图集信息（SpriteAtlasTexture-ui_atlas_elf-1024x1024-fmt12）也不会在任何的ab包里</p>
<p>综上，如果图集分散到多个ab包，会造成资源冗余，会增大包体大小，运行时也会浪费内存，如果不分配到ab包里又无法热更，那么唯一的做法就是一个图集打一个ab包（把相同图集的Sprite放在同一个文件夹，这个文件夹只包含该图集的sprite，在把这个文件夹打成ab包）</p>
<p>4.减少同时加载的AB数量（这个是纯逻辑控制），使用AssetBundle.LoadFromFile接口。使用WWW加载会生成一个新的线程，在移动平台线程多了会导致游戏崩溃，尽量使用UnityWebRequest</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/25/2020-01-25/" data-id="cmcw2gdvj0000hnz84ohm71i2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity%EF%BC%8CAssetBundle/" rel="tag">Unity，AssetBundle</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2019-10-04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/04/2019-10-04/" class="article-date">
  <time datetime="2019-10-04T12:49:12.000Z" itemprop="datePublished">2019-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/10/04/2019-10-04/">常用的Bash 命令 整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>常用的Bash 命令 整理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">current_time = $(date <span class="string">"+%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">replace_str_in_file</span></span>()&#123;</span><br><span class="line">    sed -i <span class="string">"s/<span class="variable">$1</span>/<span class="variable">$2</span>/g"</span> <span class="variable">$3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">replace_str_in_file <span class="string">'result.displayType= "YourName"'</span> <span class="string">'result.displayType="$&#123;DISPLAY_NAME&#125;"'</span> applocalInfo.lua </span><br><span class="line"></span><br><span class="line">wget 下载整站</span><br><span class="line">wget -r -p -np -k https://raw.githubusercontent.com/</span><br><span class="line"></span><br><span class="line">通过ssh备份</span><br><span class="line">tar zcvf - back/ | ssh root@www.jb51.net tar xzf - -C /root/back/</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span></span><br><span class="line">pstree -ap 10277 |grep -oP <span class="string">'[0-9]&#123;4,6&#125;'</span>|xargs <span class="built_in">kill</span> -9</span><br><span class="line"></span><br><span class="line">导出最后一列非空数据</span><br><span class="line">awk -f <span class="string">"|"</span> <span class="string">'&#123;if($NF!="")print $NF&#125;'</span></span><br><span class="line"></span><br><span class="line">行前或行后插入</span><br><span class="line">sed <span class="string">'p;s/^.*$/----/'</span> file</span><br><span class="line">awk <span class="string">'&#123;print $0;print "----"&#125;'</span> file</span><br><span class="line"></span><br><span class="line">sed <span class="string">'s/^/new/g'</span> file</span><br><span class="line">sed <span class="string">'s/$/new/g'</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成sshkey 并上传服务器</span></span><br><span class="line">ssh-keygen -y -f ~/.ssh/id_rsa &amp;&amp;　cat ~/.ssh/id_rsa.pub | ssh root@host <span class="string">"cat - &gt;&gt; ~/.ssh/authorized_keys"</span></span><br><span class="line"></span><br><span class="line">简单列出当前目录文件</span><br><span class="line">python -m SimpleHTTPServer </span><br><span class="line">python3 -m http.server</span><br><span class="line"></span><br><span class="line">查看内存使用情况</span><br><span class="line">ps aux --sort=rss |sort -k 6 -rn</span><br><span class="line"></span><br><span class="line">查看ip</span><br><span class="line">ifconfig |awk -F<span class="string">"[ ]+|[:]"</span> <span class="string">'NR==2 &#123;print $4&#125;'</span></span><br><span class="line"></span><br><span class="line">查找并杀进程</span><br><span class="line">pgrep nginx|xargs <span class="built_in">kill</span> </span><br><span class="line">pidof nginx|xargs <span class="built_in">kill</span></span><br><span class="line"></span><br><span class="line">删除注释</span><br><span class="line">sed -i <span class="string">'s/#.*$//g'</span> filename</span><br><span class="line"></span><br><span class="line">查看代码，除掉注释和空行</span><br><span class="line">egrep -v <span class="string">"^#|^$"</span>  filename</span><br><span class="line">sed <span class="string">'/#.*$/d; /^ *$/d'</span></span><br><span class="line"></span><br><span class="line">按大小列出文件</span><br><span class="line">ls|xargs du -h|sort -rn </span><br><span class="line"><span class="comment">#不递归下级目录使用du -sh</span></span><br><span class="line"></span><br><span class="line">在somefile.sh 文件里加上<span class="built_in">set</span>+x <span class="built_in">set</span>-x</span><br><span class="line">1. 用 &amp;&amp; || 简化<span class="keyword">if</span> <span class="keyword">else</span></span><br><span class="line">判断是否为空文件</span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="variable">$file</span> ]]; <span class="keyword">then</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"not empty"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">获取文件大小</span><br><span class="line"><span class="built_in">stat</span> -c %s <span class="variable">$file</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stat</span> --<span class="built_in">printf</span>=<span class="string">'%s\n'</span> <span class="variable">$file</span></span><br><span class="line"></span><br><span class="line">wc -c <span class="variable">$file</span></span><br><span class="line"></span><br><span class="line">rsync 备份</span><br><span class="line">rsync -r -t -v /source_folder /destination_folder</span><br><span class="line"></span><br><span class="line">rsync -r -t -v /source_folder [user@host:/destination_folder</span><br><span class="line"></span><br><span class="line">为所有txt文件加上.bak</span><br><span class="line">rename <span class="string">'.txt'</span> <span class="string">'.txt.bak'</span> *.txt</span><br><span class="line">去掉所有的bak</span><br><span class="line">rename <span class="string">'*.bak'</span> <span class="string">''</span> *.bak</span><br><span class="line"></span><br><span class="line">空格替换成下划线</span><br><span class="line">find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'s/ /_/g'</span> &#123;&#125; \;</span><br><span class="line">文件名改成大写</span><br><span class="line">find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'y/a-z/A-Z/'</span> &#123;&#125; \;</span><br><span class="line">文件名改成小写</span><br><span class="line">find path -<span class="built_in">type</span> f -<span class="built_in">exec</span> rename <span class="string">'y/A-Z/a-z/'</span> &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"><span class="comment"># for while 循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=0; i &lt; 10; i++)); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> $(cat a.txt); <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$line</span>; <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *.txt; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$f</span>; <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line ; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$line</span>; <span class="keyword">done</span> &lt; a.txt </span><br><span class="line"></span><br><span class="line">cat a.txt | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$line</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">删除空行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat a.txt | sed -e <span class="string">'/^$/d'</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">echo</span> <span class="string">"abc"</span>; <span class="built_in">echo</span> <span class="string">""</span>; <span class="built_in">echo</span> <span class="string">"ddd"</span>;) | awk <span class="string">'&#123;if (0 != NF) print $0;&#125;'</span></span><br><span class="line"></span><br><span class="line">字典结构</span><br><span class="line"><span class="function"><span class="title">hput</span></span>() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">eval</span> <span class="string">"hkey_<span class="variable">$1</span>"</span>=<span class="string">"<span class="variable">$2</span>"</span> </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hget</span></span>() &#123; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">eval</span> <span class="built_in">echo</span> <span class="string">'$&#123;'</span><span class="string">"hkey_<span class="variable">$1</span>"</span><span class="string">'&#125;'</span> </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">$ hput k1 aaa</span><br><span class="line"></span><br><span class="line">$ hget k1</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">遍历数组</span><br><span class="line">array=( one two three ) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">获取路径和文件名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ dirname ‘/home/lalor/a.txt<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/home/lalor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ basename ‘/home/lalor/a.txt'</span></span><br><span class="line"></span><br><span class="line">a.txt</span><br><span class="line"></span><br><span class="line">获取文件名和扩展</span><br><span class="line">var=hack.fun.book.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%.*&#125;</span></span><br><span class="line"></span><br><span class="line">hack.fun.book</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%%.*&#125;</span></span><br><span class="line"></span><br><span class="line">hack</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var#.*&#125;</span></span><br><span class="line"></span><br><span class="line">fun.book.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##.*&#125;</span></span><br><span class="line"></span><br><span class="line">txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">清理僵尸进程</span><br><span class="line">ps -eal | awk <span class="string">'&#123; if ($2 == "Z")&#123; print $4&#125;&#125;'</span> | <span class="built_in">kill</span> -9</span><br><span class="line"></span><br><span class="line">创建函数库</span><br><span class="line"></span><br><span class="line">将函数定一个在另一个文件，然后通过<span class="built_in">source</span> 命令加载到当前文件</span><br><span class="line"></span><br><span class="line">在命令行使用函数</span><br><span class="line"></span><br><span class="line">将函数定义在~/.bashrc 中即可</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2019/10/04/2019-10-04/" data-id="cmcvp18en000d0mz83cj7b9ou" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assetbundle/" rel="tag">Assetbundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/" rel="tag">IOC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Particle-System/" rel="tag">Particle System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shader/" rel="tag">Shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" rel="tag">Slot, 老虎机，游戏研究</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UGUI/" rel="tag">UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-C/" rel="tag">Unity, C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" rel="tag">Unity, UI框架, UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity%EF%BC%8CAssetBundle/" rel="tag">Unity，AssetBundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gameframework/" rel="tag">gameframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-server/" rel="tag">http.server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" rel="tag">slot, 老虎机, slot game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity-python/" rel="tag">unity python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlua-lua-framework/" rel="tag">xlua, lua, framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%B1%E5%BF%97/" rel="tag">励志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" rel="tag">物理引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">程序员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/Assetbundle/" style="font-size: 10px;">Assetbundle</a> <a href="/tags/C/" style="font-size: 15.71px;">C#</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 14.29px;">Java</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Particle-System/" style="font-size: 10px;">Particle System</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" style="font-size: 10px;">Slot, 老虎机，游戏研究</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/UGUI/" style="font-size: 11.43px;">UGUI</a> <a href="/tags/Unity/" style="font-size: 18.57px;">Unity</a> <a href="/tags/Unity-C/" style="font-size: 10px;">Unity, C#</a> <a href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" style="font-size: 10px;">Unity, UI框架, UGUI</a> <a href="/tags/Unity%EF%BC%8CAssetBundle/" style="font-size: 10px;">Unity，AssetBundle</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/gameframework/" style="font-size: 10px;">gameframework</a> <a href="/tags/http-server/" style="font-size: 10px;">http.server</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/mysql/" style="font-size: 12.86px;">mysql</a> <a href="/tags/python/" style="font-size: 12.86px;">python</a> <a href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" style="font-size: 10px;">slot, 老虎机, slot game</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/unity/" style="font-size: 17.14px;">unity</a> <a href="/tags/unity-python/" style="font-size: 10px;">unity python</a> <a href="/tags/xlua-lua-framework/" style="font-size: 11.43px;">xlua, lua, framework</a> <a href="/tags/%E5%8A%B1%E5%BF%97/" style="font-size: 10px;">励志</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" style="font-size: 10px;">物理引擎</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 10px;">程序员</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.43px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 20px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/13/2025-07-13/">简单的服务器搭建</a>
          </li>
        
          <li>
            <a href="/2025/07/11/2025-07-11/">框架之日志管理系统</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-12/">unity 一键打包</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-10/">Unity UI框架总结</a>
          </li>
        
          <li>
            <a href="/2025/07/09/2025-07-09/">Unity 打android 包报错总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 OuyangWenyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>