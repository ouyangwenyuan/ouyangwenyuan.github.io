<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>持续学习者————Just Do It！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:type" content="website">
<meta property="og:title" content="持续学习者————Just Do It！">
<meta property="og:url" content="http://droidman.net/page/8/index.html">
<meta property="og:site_name" content="持续学习者————Just Do It！">
<meta property="og:description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:locale" content="en,ZH">
<meta property="article:author" content="OuyangWenyuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Objective-c">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Unity3d">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="Program">
<meta property="article:tag" content="Mac OS">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="Window">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="xcode">
<meta property="article:tag" content="IDEA">
<meta property="article:tag" content="eclicpse">
<meta property="article:tag" content="blender">
<meta property="article:tag" content="MVC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="持续学习者————Just Do It！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">持续学习者————Just Do It！</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学无止境————不怕你不会，就怕你不学！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://droidman.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2017-11-19" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/2017-11-19/" class="article-date">
  <time datetime="2017-11-19T00:43:19.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/2017-11-19/">Unity 小技巧总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>定时重复处理，比如， 启动0.5秒后每隔1秒执行一次 DoSomeThing 函数：<br>1.用InvokeRepeating 函数实现<br>void Start() { InvokeRepeating(“DoSomeThing”, 0.5, 1.0); }<br>CancelInvoke(“你调用的方法”); 停止InvokeRepeating</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">     StartCoroutine(&quot;Repeating&quot;);开始调用</span><br><span class="line">     StopCoroutine(&quot;Repeating&quot;);停止调用</span><br><span class="line">&#125;</span><br><span class="line">IEnumerator Repeating()</span><br><span class="line">    &#123;</span><br><span class="line">        yield return new WaitForSeconds(0.5f);</span><br><span class="line"></span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            yield return new WaitForSeconds(1f);</span><br><span class="line">            DoSomeThing();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>尽量避免每帧处理,可以每隔几帧处理一次<br>比如：<br>void Update() { DoSomeThing(); }</p>
<p>可改为每5帧处理一次：<br>void Update() { if(Time.frameCount % 5 == 0) { DoSomeThing(); } }</p>
<p>主动回收垃圾<br>给某个 GameObject 绑上以下的代码：<br>void Update() { if(Time.frameCount % 50 == 0) { System.GC.Collect(); } }</p>
<p>不要使用SendMessage之类的方法，他比直接调用方法慢了100倍，你可以直接调用或通过C#的委托来实现。</p>
<p>关于渲染队列和Batch的非官方经验总结是，一帧的渲染队列的生成，依次决定于每个渲染物体的：<br>Shader的RenderType tag,<br>Renderer.SortingLayerID,<br>Renderer.SortingOrder,<br>Material.renderQueue（默认值为Shader里的”Queue”）,<br>Transform.z(ViewSpace)（默认为按z值从前到后，但当Queue是“Transparent”的时候，按z值从后到前）。<br>这个渲染队列决定了之后（可能有dirty flag的机制？）渲染器再依次遍历这个渲染队列，“同一种”材质的渲染物体合到一个Batch里。</p>
<p>Unity渲染路径（Rendering Path）种类<br>概述<br>开发者可以在Unity工程的PlayerSettings设置对渲染路径进行3选1：<br>Deferred Lighting，延迟光照路径。3者中最高质量地还原光照阴影。光照性能只与最终像素数目有关，光源数量再多都不会影响性能。<br>Forward Rendering，顺序渲染路径。能发挥出Shader全部特性的渲染路径，当然也就支持像素级光照。最常用、功能最自由，性能与光源数目*受光照物体数目有关，具体性能视乎其具体使用到的Shader的复杂度。<br>Vertex Lit，顶点光照路径。顶点级光照。性能最高、兼容性最强、支持特性最少、品质最差。</p>
<p>unity 点击2D物体<br>1.给物体添加对应的2D碰撞体，例如Box Collider 2D;<br>2.Update检测鼠标是否点下；<br>3.如果鼠标点下，创建一条射线，通过Physics2D.Raycast获取点击时鼠标处的对象；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 mousePos = Input.mousePosition;</span><br><span class="line">        Ray ray = Camera.main.ScreenPointToRay(mousePos);</span><br><span class="line">        RaycastHit2D hit = Physics2D.Raycast(ray.origin, ray.direction);</span><br><span class="line">        <span class="keyword">if</span> (hit.collider != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(hit.collider.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从游戏开始到当前帧经历的时间 Time.realtimeSinceStartup;<br>从游戏开始到当前帧经历的帧总数 Time.frameCount;</p>
<p>计算FPS：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_countFrame += <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> time = Time.realtimeSinceStartup;</span><br><span class="line">    <span class="keyword">if</span> (time - _lastTime &gt;= <span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _fps = (<span class="keyword">float</span>)(_countFrame/(time - _lastTime));</span><br><span class="line">        Debug.Log(<span class="string">"FPS: "</span> + _countFrame);</span><br><span class="line">        _countFrame = <span class="number">0</span>;</span><br><span class="line">        _lastTime = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到当前帧鼠标的位移量：Input.GetAxis()</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>) &amp;&amp; _isRotation)&#123;</span><br><span class="line">        <span class="keyword">float</span> x = Input.GetAxis(<span class="string">"Mouse X"</span>)*<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">float</span> y = Input.GetAxis(<span class="string">"Mouse Y"</span>)*<span class="number">10</span>;</span><br><span class="line">        Debug.Log(<span class="string">"x: "</span> + x + <span class="string">" y: "</span> + y);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>对象跟随鼠标运动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vector3 wp &#x3D; Camera.main.WorldToScreenPoint(transform.position);</span><br><span class="line">Vector3 sp &#x3D; Input.mousePosition;</span><br><span class="line">sp.z &#x3D; wp.z;</span><br><span class="line"></span><br><span class="line">if (Input.GetMouseButton(0))</span><br><span class="line">&#123;</span><br><span class="line">transform.position &#x3D; Camera.main.ScreenToWorldPoint(sp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>协同程序的开启与终止：<br>       在Unity3D中，使用MonoBehaviour.StartCoroutine方法即可开启一个协同程序，也就是说该方法必须在MonoBehaviour或继承于MonoBehaviour的类中调用。<br>       在Unity3D中，使用StartCoroutine(string methodName)和StartCoroutine(IEnumerator routine)都可以开启一个线程。区别在于使用字符串作为参数可以开启线程并在线程结束前终止线程，相反使用IEnumerator 作为参数只能等待线程的结束而不能随时终止(除非使用StopAllCoroutines()方法)；另外使用字符串作为参数时，开启线程时最多只能传递一个参数，并且性能消耗会更大一点，而使用IEnumerator 作为参数则没有这个限制。<br>        在Unity3D中，使用StopCoroutine(string methodName)来终止一个协同程序，使用StopAllCoroutines()来终止所有可以终止的协同程序，但这两个方法都只能终止该MonoBehaviour中的协同程序。<br>        还有一种方法可以终止协同程序，即将协同程序所在gameobject的active属性设置为false，当再次设置active为ture时，协同程序并不会再开启；如是将协同程序所在脚本的enabled设置为false则不会生效。这是因为协同程序被开启后作为一个线程在运行，而MonoBehaviour也是一个线程，他们成为互不干扰的模块，除非代码中用调用，他们共同作用于同一个对象，只有当对象不可见才能同时终止这两个线程。然而，为了管理我们额外开启的线程，Unity3D将协同程序的调用放在了MonoBehaviour中，这样我们在编程时就可以方便的调用指定脚本中的协同程序，而不是无法去管理，特别是对于只根据方法名来判断线程的方式在多人开发中很容易出错，这样的设计保证了对象、脚本的条理化管理，并防止了重名。</p>
<p>ＵＧＵＩ空格导致换行：将空格转换为全角空格，半角空格会使Text自动换行。</p>
<p>实现text显示不同颜色的字，如我是程序员小白，其中程序员为红色，其余自为黑色。使用透明颜色标签&lt;color=#0000ff00&gt;111</color>，其中的１１１不会显示在Text上但会占据格子，作用类似于空格，通过这个标签的颜色值可以改变相应的字体颜色。</p>
<p>unity 编辑状态下暂停：</p>
<p>1.Debug.Break();或者UnityEditor.EditorApplication.isPaused = false;</p>
<p>2.使用编辑器类：EditorApplication.ExecuteMenuItem(“Edit/Play”);<br>3.UnityEditor.EditorApplication.isPlaying = false;</p>
<p>问题：<br>unity中通过Application.dataPath + “/Resources/Config/xxx”)作为将要读取文件的路径时，在编辑器上正常运行，但在打包后却无法正确读取文件<br>解决：<br>这是因为不同平台Application.dataPath所指定的路径不一样，editor模式下代表的是Asset,打包后对应的路径是打包时生成的文件夹“xxx_data”，这是需要把对应的文件拷贝到“xxx_data”文件夹下，例如打包后文件路径“E:\Unity\TowerDefense\Build\塔防_Data\Resources\Config”对应编辑器下的“E:\Unity\TowerDefense\Assets\Resources\Config”。</p>
<p>问题：<br>UNITY 无法导入视频解决方法<br>解决<br>1.unity 导入视频时无法转换成movieTexture， 这时候unity会提示影片导入失败，这时候需要安转QuickTime Player，这个软件可以把unity的影片转换成unity能用的材质。<br>2.QuickTime 无法正常运行时并且提示 “please install apple application support”时，打开下载的QuickTime安装包，选择安装“apple application support.msi”,安装选择“修复”。<br>3.unity支持的影片格式有.mov .mpg .mpeg .mp4 .avi .asf。<br>4.成功导入的影片会生成一个对应的Movie Audio，这个文件是该影片的声音文件。</p>
<p>问题：Scroll Rect中滑动事件是通过EventTrigger响应，所以当item也是通过EventTrigger响应点击事件时，就会遮挡住后面的Scroll Rect的滑动事件。<br>UGUI的ScrollRect组件会和放在它上面的button或者toggle等组件有事件响应的冲突，具体体现为上面的组件会遮挡下面的响应，在button或者toggle等组件上出现只能点击不能滑动的效果，要想滑动必须点旁边才行。<br>解决：<br>（1）.Button: Button.onClick.AddListener(delegate () {ButtonOnClick(Button.gameObject); }); onClick回调函数 是继承自UnityEngine.Events.UnityAction.委托。由于同一个点击事件通过不同的事件模块去响应，很好的处理了item挡住Scroll Rect 事件的问题。委托格式为不带任何参数和返回的函数。<br>这里的Button是指你要按下的那个按钮，ButtonOnClick是该按钮按下时要触发的事件。<br>第二种解决方案是：不用按钮，1.新建一个继承MonoBehaviour和IPointerClickHandler接口的脚本（例如ClickObject），2.这个脚本实现public void OnPointerClick(PointerEventData eventData)方法：3.创建一个名为Panel_IPointer的空对象，这个空对象就是你的按钮。并且将ClickObject脚本附加到对象上。这时候点击这个对象就会调用OnPointerClick方法。<br>第三种：创建一个Image（例如名为Btn），Btn对象添加EventTrigger组件，” Add New” -&gt; 选择” PointerClick”。将Btn对象拖拽到触发者位置。然后点击”No Function”选择我们要触发的OnTestClick事件。<br>（2）toggle：使用isOn的方法，例如if（toggle.ison）{debug.log(“click”)};</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/11/19/2017-11-19/" data-id="cmcw1g2re000kz4z8gp1mdesz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-11-18" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/18/2017-11-18/" class="article-date">
  <time datetime="2017-11-18T00:43:14.000Z" itemprop="datePublished">2017-11-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/18/2017-11-18/">Unity 物理引擎 学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>刚体：</p>
<p>刚体是模拟物理效果的对象。添加了刚体组件的游戏物体，会受重力影响，可以被玩家四处推动，或者直接用脚本添加力给对象来让他四处移动。通常情况下，对同一物体，要么通过刚体操纵，要么通过变换（transform）操纵。但添加刚体组件之后直接通过Transform组件更改物体位置，它和其他对象的碰撞可能出问题（除非Is Kinematic 选项被选中，选中该选项，则没法通过物理模拟来改变物体运动状态）。应避免同时使用两种方式。正确地方法应该是通过施加力或者扭矩来移动刚体。</p>
<p>属性：</p>
<p>Mass 质量：物体的质量(任意单位)。建议一个物体的质量不要多于或少于其他单位的100倍。<br>Drag 阻力：移动时物体受到的空气阻力。0表示没有,极大时物体立即停止运动。<br>Angular Drag：角阻力 当受扭力旋转时物体受到的空气阻力。0表示没有，极大时物体立即停止旋转。<br>Use Gravity 是否使用重力<br>Is Kinematic 是否是运动学：若激活，该物体不再受物理引擎驱动，而只能通过transform来操作。适用于模拟运动的平台或者模拟与铰链关节连接的刚体。<br>Interpolate 插值<br>当你发现刚体运动时抖动，可以尝试下面的选项。<br>None 无 不应用插值。<br>Interpolate 内插值 基于上一帧的变换来平滑本帧变换。<br>Extrapolate 外插值 基于下一帧的预估变换来平滑本帧变换。</p>
<p>Collision Detection 碰撞检测模式。用于避免高速物体穿过其他物体，却未触发碰撞。<br>Discrete 离散</p>
<p>离散碰撞检测。使用离散碰撞检测模式来与场景中其他碰撞器进行碰撞检测。其他物体与它的碰撞检测，也会应用这种模式。适用于普通碰撞（这是默认的模式）。<br>Continuous 连续<br>连续碰撞检测。使用离散碰撞检测来检测与动态碰撞器（刚体）的碰撞，使用连续碰撞检测来检测与静态网格（非刚体）的碰撞检测。采用连续动态碰撞检测模式的刚体碰见这类物体也将采用连续碰撞检测模式。而与其他刚体将采用离散碰撞检测模式。这种模式适用于那些采用动态连续碰撞模式的物体碰撞的物体。（这对物理表现有很大的影响，如果你不关心与高速物体的碰撞，那么就让其为默认的离散模式。）<br>Continuous Dynamic    动态连续<br>连续动态碰撞检测。使用连续动态碰撞检测模式来检测与连续模式和连续动态模式的物体间的碰撞。也适用于与静态网格（非刚体）的碰撞检测。而与之碰撞的其他模式的物体，采用的是离散动态碰撞检测模式。适用于高速物体。<br>Constraints 约束 对刚体运动的约束。 限制刚体在某些维度上的移动或|和旋转。</p>
<p>Freeze Position 冻结位置，刚体在世界中沿所选X，Y，Z轴的移动，将无效。<br>Freeze Rotation 冻结旋转，刚体在世界中沿所选的X,Y,Z轴的旋转，将无效。<br>velocity:刚体的速度向量,最好不要直接修改它，可以通过它的大小判断撞击的强度。</p>
<p>方法：<br>Rigibody.AddForce(Vector3)，在物体的中心点位置添加一个Vector3的力，使物体朝该Vector3方向运动，运动速度为该向量的模。<br>Rigibody.AddTorque(Vector3)，在物体中心添加一个力矩Vector3，力矩可以使物体旋转，刚体将绕着torque轴旋转。<br>Rigibody.AddForceAtPosition(Vector3,Vector3),在物体某个位置添加一个力，对于真实的效果，位置应大约在刚体表面的范围。<br>Rigibody.AddExplosionForce（float forceStrength，Vector3 postion，float range）,在某个位置添加一个大小为float，半径为range的爆炸力（向爆炸范围内各个方向的对象施加一个力），用来模拟爆炸效果。爆炸力将随着到刚体的距离线形衰减。。</p>
<p>提示：两个刚体 (Rigidbody) 的相对质量 (Mass) 确定它们在互相碰撞时的反应方式。<br>使一个刚体 (Rigidbody) 的 质量 (Mass) 大于另一个刚体 (Rigidbody) 不会使其在自由落体过程中下落得更快。请使用阻力 (Drag) 实现此目的。<br>较小阻力 (Drag)值会使对象看起来较重。较高值会使对象看起来较轻。阻力 (Drag) 的典型值介于 0.001（实心金属块）与 10（羽毛）之间。<br>如果直接处理对象的变换 (Transform) 组件 (Component) ，但是仍需要物理，请附加刚体 (Rigidbody) 并将其设为运动学 (Kinematic)。<br>如果通过其变换 (Transform) 组件 (Component) 移动某个游戏对象 (GameObject)，但是希望接收碰撞体 (Collider)/触发器 (Trigger) 消息，则必须将刚体 (Rigidbody) 附加到移动的对象。<br>不能仅仅通过将其“角阻力”(Angular Drag) 设置为无穷大使对象停止旋转。</p>
<p>碰撞体、触发器<br>发生碰撞条件：两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体，没有碰撞体的刚体会彼此相互穿过。发生碰撞时，当两个物体都是碰撞器（Is Trigger都未勾选）时触发OnCollisionXXX，否则触发OnTriggerxxx。</p>
<p>属性：<br>Is Trigger 是否触发器，勾选后会触发OnTriggerxxx方法，会穿过刚体<br>Material 材质，后面再讲<br>Center 中心点，用于调整碰撞盒的位置<br>Size 大小 在X、Y、Z三维上的碰撞器尺寸。<br>Convex 凸起的 如激活，该网格碰撞器将会和其他网格碰撞器碰撞。凸起的网格碰撞器限制在255个三角形面内。网格碰撞器之间通常不相互碰撞，但如果一个网格碰撞器被标记为凸起的（Convex ），那么它就可以与其他网格碰撞器碰撞。典型的解决方案是，对移动的对象使用基本碰撞器，而对静态环境对象使用网格碰撞器。<br>碰撞方法：<br>OnTriggerEnter( Collider other )当进入触发器<br>OnTriggerExit( Collider other )当退出触发器<br>OnTriggerStay( Collider other )当逗留触发器<br>OnCollisionEnter( Collision collisionInfo ) 当进入碰撞器<br>OnCollisionExit( Collision collisionInfo ) 当退出碰撞器<br>OnCollisionStay( Collision collisionInfo ) 当逗留碰撞器</p>
<p>Static Colliders 静态碰撞器，包含碰撞器但不含刚体的游戏对象。你不要逐帧移动 一个静态碰撞器，移动静态碰撞器将导致PhysX引擎的内部重置，非常耗费资源，而且会造成性能的极大下降。<br> 基于层的碰撞检测：Edit-&gt;Project Settings-&gt;Physics.，打开物理引用界面. 在碰撞矩阵中选择要与其他层相互作用的层，勾选即可.（前提是先设置好层）</p>
<p>物理材质 Physic Material<br>物理材质用来调节碰撞物体的摩擦力和弹力效果。要创建物理材质从菜单栏选择Assets-&gt;Create-&gt;Physic Material。然后从项目视图拖拽物理材质到场景的一个碰撞器上。</p>
<p>属性：<br>Dynamic Friction 动力摩擦力，对象在运动时的摩擦力，取值范围0<del>1，该值越大，物体受到阻力越大，越快停止运动。<br>Static Friction 静态摩擦力，对象被放置在表面时的摩擦力，取值范围0</del>1，该值越大，物体受到阻力越大，开始运动所需力也越大，取值接近0时可模拟冰的效果。<br>Bouncyness 弹力 0值将不反弹。1值反弹将没有任何能量损失。<br>Friction Combine Mode 摩擦力结合模式 ，两个碰撞物体的摩擦力是如何结合起来。<br>Average 使用两个摩擦力的平均值<br>Min 使用两个摩擦力的最小值<br>Max 使用两个摩擦力的最大值<br>Multiply 使用两个摩擦力的乘积</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/11/18/2017-11-18/" data-id="cmcw1g2rd000jz4z873px4boh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" rel="tag">物理引擎</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-11-12" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/12/2017-11-12/" class="article-date">
  <time datetime="2017-11-12T00:43:11.000Z" itemprop="datePublished">2017-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/12/2017-11-12/">AssetBundle加载到内存和释放研究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>AssetBundle运行时加载:<br><img src="/img/assetbundle_load.jpg" alt="img"><br>来自文件就用CreateFromFile(注意这种方法只能用于standalone程序：PC/MAC端）这是最快的加载方法<br>也可以来自Memory,用CreateFromMemory(byte[]),这个byte[]可以来自文件读取的缓冲，www的下载或者其他可能的方式。<br>其实WWW的assetBundle就是内部数据读取完后自动创建了一个assetBundle而已<br>Create完以后，等于把硬盘或者网络的一个文件读到内存一个区域，这时候只是个AssetBundle内存镜像数据块，还没有Assets的概念。<br>Assets加载:<br>用AssetBundle.Load(同Resources.Load) 这才会从AssetBundle的内存镜像里读取并创建一个Asset对象，创建Asset对象同时也会分配相应内存用于存放(反序列化)<br>异步读取用AssetBundle.LoadAsync<br>也可以一次读取多个用AssetBundle.LoadAll，加载完后立即AssetBundle.Unload(false),释放AssetBundle文件本身的内存镜像，但不销毁加载的Asset对象。（这样你不用保存AssetBundle的引用并且可以立即释放一部分内存）<br>AssetBundle.CreateFrom…..：创建一个AssetBundle内存镜像，注意同一个assetBundle文件在没有Unload之前不能再次被使用<br><a href="WWW.AssetBundle：同上，当然要先new一个再">WWW.AssetBundle：同上，当然要先new一个再</a> yield return 然后才能使用<br>AssetBundle.Load(name)：从AssetBundle读取一个指定名称的Asset并生成Asset内存对象，如果多次Load同名对象，除第一次外都只会返回已经生成的Asset对象，也就是说多次Load一个Asset并不会生成多个副本（singleton）。<br>Resources.Load(path;name)：同上,只是从默认的位置加载。<br>Instantiate（object)：Clone一个object的完整结构，包括其所有Component和子物体（详见官方文档）,浅Copy，并不复制所有引用类型。有个特别用法，虽然很少这样用，其实可以用Instantiate来完整的拷贝一个引用类型的Asset,比如Texture等，要拷贝的Texture必须类型设置为Read/Write able。</p>
<p>释放：<br>AssetBundle的释放：<br>AssetBundle.Unload(flase)是释放AssetBundle文件的内存镜像，不包含Load创建的Asset内存对象。<br>AssetBundle.Unload(true)是释放那个AssetBundle文件内存镜像和并销毁所有用Load创建的Asset内存对象。</p>
<p>一个Prefab从assetBundle里Load出来 里面可能包括：Gameobject transform mesh texture material shader script和各种其他Assets。<br>你Instantiate一个Prefab，是一个对Assets进行Clone(复制)+引用结合的过程，GameObject transform 是Clone是新生成的。其他mesh / texture / material / shader 等，这其中有些是纯引用的关系的，包括：Texture和TerrainData，还有引用和复制同时存在的，包括：Mesh/material/PhysicMaterial。引用的Asset对象不会被复制，只是一个简单的指针指向已经Load的Asset对象。所以你Load出来的Assets其实就是个数据源，用于生成新对象或者被引用，生成的过程可能是复制（clone)也可能是引用（指针）<br>当你Destroy一个实例时，只是释放那些Clone对象，并不会释放引用对象和Clone的数据源对象，Destroy并不知道是否还有别的object在引用那些对象。<br>等到没有任何游戏场景物体在用这些Assets以后，这些assets就成了没有引用的游离数据块了，是UnusedAssets了，这时候就可以通过Resources.UnloadUnusedAssets来释放,Destroy不能完成这个任务，AssetBundle.Unload(false)也不行，AssetBundle.Unload(true)可以但不安全，除非你很清楚没有任何对象在用这些Assets了。<br>Destroy:主要用于销毁克隆对象，也可以用于场景内的静态物体，不会自动释放该对象的所有引用。虽然也可以用于Asset,但是概念不一样要小心，如果用于销毁从文件加载的Asset对象会销毁相应的资源文件！但是如果销毁的Asset是Copy的或者用脚本动态生成的，只会销毁内存对象。<br>AssetBundle.Unload(false):释放AssetBundle文件内存镜像<br>AssetBundle.Unload(true):释放AssetBundle文件内存镜像同时销毁所有已经Load的Assets内存对象<br>Reources.UnloadAsset(Object):显式的释放已加载的Asset对象，只能卸载磁盘文件加载的Asset对象<br>Resources.UnloadUnusedAssets:用于释放所有没有引用的Asset对象<br>GC.Collect()强制垃圾收集器立即释放内存 Unity的GC功能不算好，没把握的时候就强制调用一下<br>静态引用和Resources.Load引用对象texture是在instantiate时加载，用到时才会加载，会导致第一次加载卡顿，而assetBundle.Load会把perfab的全部assets都加载，instantiate时只是生成Clone。Unity系统在加载新场景时，所有的内存对象都会被自动销毁，包括你用AssetBundle.Load加载的对象和Instaniate克隆的。<br>但是不包括AssetBundle文件自身的内存镜像，那个必须要用Unload来释放，用.net的术语，这种数据缓存是非托管的。<br>既然加载场景不会释放AssetBundle文件自身的内存镜像，那我们就手动释放。<br>Destroy:主要用于销毁克隆对象，也可以用于场景内的静态物体，不会自动释放该对象的所有引用。虽然也可以用于Asset,但是概念不一样要小心，如果用于销毁从文件加载的Asset对象会销毁相应的资源文件！但是如果销毁的Asset是Copy的或者用脚本动态生成的，只会销毁内存对象。<br>AssetBundle.Unload(false):释放AssetBundle文件内存镜像<br>AssetBundle.Unload(true):释放AssetBundle文件内存镜像同时销毁所有已经Load的Assets内存对象<br>Reources.UnloadAsset(Object):显式的释放已加载的Asset对象，只能卸载磁盘文件加载的Asset对象<br>Resources.UnloadUnusedAssets:用于释放所有没有引用的Asset对象<br>GC.Collect()强制垃圾收集器立即释放内存 Unity的GC功能不算好，没把握的时候就强制调用一下<br>例如：场景A切换到场景B，使用同步加载Application.LoadLevel(sceneName)或者异步加载Application.LoadLevelAsync(sceneName)都可以。<br>我们可以在场景A和场景B之间插入一个清理内存的场景X，场景X就是一个空场景，它的主要作用是承上启下，把场景A留下的资源清理，然在切换到场景B。<br>具体就是在Awake方法里清空内存，Start方法里切换下一个场景，如下：　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void Awake()</span><br><span class="line"> &#123;</span><br><span class="line">        object[] objAry &#x3D; Resources.FindObjectsOfTypeAll();</span><br><span class="line"> </span><br><span class="line">        for (int i &#x3D; 0; i &lt; objAry.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            objAry[i] &#x3D; null;&#x2F;&#x2F;解除资源引用</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;卸载没有被引用的资源</span><br><span class="line">        Resources.UnloadUnusedAssets();</span><br><span class="line"> </span><br><span class="line">        &#x2F;&#x2F;进行垃圾回收</span><br><span class="line">        GC.Collect();</span><br><span class="line">        GC.waitForPendingFinalizers();&#x2F;&#x2F;</span><br><span class="line">        GC.Collect();</span><br><span class="line">&#125;</span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">   StartCoroutine(&quot;AsyncLoadScene&quot;, nextSceneName);</span><br><span class="line">&#125;</span><br><span class="line">IEnumerator AsyncLoadScene(string sceneName)</span><br><span class="line">&#123;</span><br><span class="line">   async &#x3D; Application.LoadLevelAsync(sceneName);</span><br><span class="line">   yield return async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/11/12/2017-11-12/" data-id="cmcw1g2rc000iz4z8apdahavh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-11-11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/11/2017-11-11/" class="article-date">
  <time datetime="2017-11-11T00:43:07.000Z" itemprop="datePublished">2017-11-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/11/2017-11-11/">Lerp线性插值 用法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Unity3D中经常用线性插值函数Lerp()来在两者之间插值，两者之间可以是两个材质之间、两个向量之间、两个浮点数之间、两个颜色之间，其函数原型如下：<br>1.Material.Lerp 插值<br>function Lerp(start : Material, end : Material, t : float) : void<br>在两个材质之间插值</p>
<p>2.Vector2.Lerp 插值<br>static functionLerp (from : Vector2, to : Vector2, t : float) : Vector2<br>两个向量之间的线性插值。按照数字t在form到to之间插值。<br>t是夹在0到1之间。当t=0时，返回from。当t=1时，返回to。当t=0.5时放回from和to之间的平均数。</p>
<p>3.Vector3.Lerp 插值<br>static functionLerp (from : Vector3, to :Vector3, t : float) :Vector3<br>两个向量之间的线性插值。按照数字t在from到to之间插值。</p>
<p>4.Vector4.Lerp 插值<br>static functionLerp (from : Vector4, to : Vector4, t : float) : Vector4<br>两个向量之间的线形插值。按照数字t在from到to之间插值。t是夹在[0…1]之间的值。，当t = 0时，返回from。当t = 1时，返回to。当t = 0.5 返回from和to的平均数。</p>
<p>5.Mathf.Lerp 插值<br>static functionLerp (from : float, to : float, t : float) : float<br>基于浮点数t返回a到b之间的插值，t限制在0～1之间。当t = 0返回from，当t = 1 返回to。当t = 0.5 返回from和to的平均值。</p>
<p>6.Color.Lerp 插值<br>static functionLerp (a : Color, b : Color, t : float) : Color<br>通过t在颜色a和b之间插值。<br>“t”是夹在0到1之间的值。当t是0时返回颜色a。当t是1时返回颜色b。</p>
<p>插值，从字面意思上看，就是在其间插入一个数值，其原理为a=from + (to - from) * t</p>
<p>例如Mathf.Lerp(100.0f, 200.0f,0.2f) = 100 + （200 - 100）*0.2 = 100 + 100 * 0.2 = 120</p>
<p>应用例子：</p>
<p>1.几秒内移动到目标点，其中smooth为移动时间</p>
<p>1<br>2<br>3<br>4<br>5<br>6<br>         public Transform target;<br>         public float smooth = 5.0F;<br>         void Update()<br>         {<br>                   transform.position =Vector3.Lerp(transform.position, target.position, Time.deltaTime * smooth);<br>         }<br>　　2.我们以前所玩的游戏中，主人公身上依附着一只宠物如鹰，主人公移动时，鹰会跟随着飞动，主人公移动得快它就飞行跟动得快，始终不会离开主人公，使用Lerp插值函数就可实现。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/11/11/2017-11-11/" data-id="cmcw1g2r7000gz4z85l5he753" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-11-05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/05/2017-11-05/" class="article-date">
  <time datetime="2017-11-05T00:43:04.000Z" itemprop="datePublished">2017-11-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/05/2017-11-05/">unity Assetbundle 使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文的主要内容是分析5.X版本的AssetBundle机制（包括创建资源包、压缩资源包、加载资源包和从资源包中加载/卸载资源等几个方面）及其关键的API使用方式。<br>AssetBundle是Unity推荐的资源管理方式，官方列举了诸如热更新，压缩，灵活等等优点。</p>
<p>使用步骤<br>一、打包<br>1.通过Editor中的UI为AssetBundle标记资源。而且一个资源和对应的AssetBundle的映射将会在资源数据库（AssetDatabase）中被创建。</p>
<p>2.BuildPipeline.BuildAssetBundles()：我们只需要提供一个输出AssetBundle的地址即可。引擎将自动根据资源的assetbundleName属性（即在上文中UI中设置的值）批量打包，自动建立Bundle以及资源之间的依赖关系。<br>Unity3D为我们提供了唯一的API用来打AssetBundle包。即：BuildPipeline.BuildAssetBundles<br>在脚本中调用BuildPipeline.BuildAssetBundles，U3D将自动根据资源的assetbundleName属性批量打包，自动建立Bundle和资源之间的依赖关系。在资源的Inpector界面最下方可设置该资源的assetbundleName，每个assetbundleName对应一个Bundle，即assetbundleName相同的资源会打在一个Bundle中。如果所依赖的资源设置了不同的assetbundleName，则会自动与之建立依赖关系，避免出现冗余，从而减小Bundle包的大小。当然，除了可以指定assetbundleName，我们还可以在Inpector中设置另一个名字，即variant。在打包时，variant会作为后缀添加在assetbundleName之后。相同assetbundleName，不同variant的Bundle是可以相互替换的。</p>
<p>设置好之后，我们只需要创建一个新的脚本，通过编辑器拓展调用BuildPipeline.BuildAssetBundles方法即可：</p>
<p>BuildPipeline.BuildAssetBundles方法的参数<br>outputPath：输出目录，一般我们设置为  Application.streamingAssetsPath + Bundle的目标路径和Bundle名称<br>targetPlatform：目标平台，在安卓，IOS，PC下，我们需要传入不同的平台标识，以打出不同平台适用的包，注意，Windows平台下打出来的包，不能用于IOS<br>BuildAssetBundleOptions：BuildAssetBundleOptions.CollectDependencies会去查找依赖，BuildAssetBundleOptions.CompleteAssets会强制包含整个资源，BuildAssetBundleOptions.DeterministicAssetBundle会确保生成唯一ID，在打包依赖时会有用到</p>
<p>Unity3D引擎为我们提供了三种压缩策略来处理AssetBundle的压缩，即：LZMA格式、LZ4格式、不压缩。<br>LZMA格式：在默认情况下，打包生成的AssetBundle都会被压缩。在U3D中，AssetBundle的标准压缩格式便是LZMA（LZMA是一种序列化流文件），因此在默认情况下，打出的AssetBundle包处于LZMA格式的压缩状态，在使用AssetBundle前需要先解压缩。<br>使用LZMA格式压缩的AssetBundle的包体积最小（高压缩比），但是相应的会增加解压缩时的时间。<br>LZ4格式： Unity 5.3之后的版本增加了LZ4格式压缩，由于LZ4的压缩比一般，因此经过压缩后的AssetBundle包体的体积较大（该算法基于chunk）。但是，使用LZ4格式的好处在于解压缩的时间相对要短。若要使用LZ4格式压缩，只需要在打包的时候开启BuildAssetBundleOptions.ChunkBasedCompression即可。<br>BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath,<br>BuildAssetBundleOptions.ChunkBasedCompression);<br>不压缩：我们也可以不对AssetBundle进行压缩。没有经过压缩的包体积最大，但是访问速度最快。若要使用不压缩的策略，只需要在打包的时候开启BuildAssetBundleOptions.UncompressedAssetBundle即可。<br>BuildPipeline.BuildAssetBundles(Application.streamingAssetsPath,<br>BuildAssetBundleOptions.UncompressedAssetBundle);</p>
<p>在打包的时候，我们需要对包的大小和数量进行一个平衡，所有资源打成一个包，一个资源打一个包，都是比较极端的做法，他们的问题也很明显，更多情况下我们需要灵活地将他们组合起来<br>打成一个包的缺点是加载了这个包，我们不需要的东西也会被加载进来，占用额外内存，而且不利于热更新 打成多个包的缺点是，容易造成冗余，首先影响包的读取速度，然后包之间的内容可能会有重复，且太多的包不利于资源管理哪些模块打成一个包，哪些模块打成多个包，需要根据实际情况来，例如游戏中每个怪物都需要打成一个包，因为每个怪物之间是独立的，例如游戏的基础UI，可以打成一个包，因为他们在各个界面都会出现<br> PS.想打包进AssetBundle中的二进制文件，文件名的后缀必须为“.bytes”</p>
<p>二、加载<br>首先获取AssetBundle对象，第二从AssetBundle中加载目标资源。在运行时加载AssetBundle对象主要可以分为两大类途径：<br>1.先获取WWW对象，再通过WWW.assetBundle加载AssetBundle对象：<br>public WWW(string url)，直接调用WWW类的构造函数，目标AssetBundle所在的路径作为其参数，构造WWW对象的过程中会加载Bundle文件并返回一个WWW对象，完成后会在内存中创建较大的WebStream（解压后的内容，通常为原Bundle文件的4~5倍大小，纹理资源比例可能更大），因此后续的AssetBundle.LoadAsset可以直接在内存中进行。<br>public static WWW LoadFromCacheOrDownload(string url, int version, uint crc = 0)，WWW类的一个静态方法，调用该方法同样会加载Bundle文件同时返回一个WWW对象，和上一个直接调用WWW的构造函数的区别在于该方法会将解压形式的Bundle内容存入磁盘中作为缓存（如果该Bundle已在缓存中，则省去这一步），完成后只会在内存中创建较小的SerializedFile，而后续的AssetBundle.LoadAsset需要通过IO从磁盘中的缓存获取。LoadFromCacheOrDownload会记录所有Bundle的使用情况，并在适当的时候删除最近很少使用的资源包，它允许存在两个版本号不同但名字一样的资源包，这意味着你更新这个资源包之后，如果没有更新代码中的版本号，你可能取到的会是旧版本的资源包，从而产生其他的一些BUG。另外，当你的磁盘空间不足的时候（硬盘爆了），LoadFromCacheOrDownload只是一个普通的new WWW<br>2.直接加载AssetBundle对象：<br>public static AssetBundle LoadFromFile(string path, uint crc = 0)：新的从文件创建加载AssetBundle方法，loadFromFile方法支持上一节中提到的几个压缩格式，针对LZ压缩格式和未压缩的磁盘上的bundle文件，该方法会直接加载。针对使用默认的LZMA压缩格式压缩的bundle文件，该方法会在幕后先将bundle文件解压后再加载。这是最快的加载AssetBundle的方式。该方法是同步版本，还有异步版本：LoadFromFileAsync。<br>public static AssetBundle LoadFromMemory(byte[] binary, uint crc = 0)：从内存中获取Bundle的二进制数据，同步地创建AssetBundle对象。该方法一般用在经过加密的数据上，经过加密的流数据经过解密之后我们可以调用该方法动态的创建AssetBundle对象。该方法是同步版本，还有异步版本：LoadFromMemoryAsync。<br>三、资源加载<br>LoadAsset：从资源包中加载指定的资源<br>LoadAllAsset：加载当前资源包中所有的资源.<br>LoadAssetAsync：从资源包中异步加载资源<br>在Bundle中加载的Prefab是不能直接使用的，它需要被实例化之后，才能使用，而对于这种Prefab，实例化之后，这个Bundle就可以被释放了<br>GameObject obj = GameObject.Instantiate(bundle.Load(“MyPrefab”)) as GameObject;<br>bundle.Load(“MyPrefab”, typeof(GameObject))加载的时候最好传入资源的类型</p>
<p>四、针对项目的建议<br>由于以上分析的几种加载手段各有各的使用情景和特点。因此建议在我们的项目中按照以下情景使用这些方法：<br>1.随游戏一同发布的AssetBundle（一般位于StreamingAssets文件夹中）：在打AssetBundle包时，使用LZ4压缩格式进行打包（开启BuildAssetBundleOptions.ChunkBasedCompression即可）。<br>2.在运行时需要加载AssetBundle对象时，使用LoadFromFile方法进行加载。<br>这样做的好处是：即可以将AssetBundle文件压缩，又可以兼顾加载速度，且节约内存。<br>3.在打AssetBundle包时，使用默认的LZMA格式压缩。<br>4.使用WWW.LoadFromCacheOrDownload方法下载并缓存AssetBundle包文件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/11/05/2017-11-05/" data-id="cmcw1g2r6000ez4z815vbclgp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Assetbundle/" rel="tag">Assetbundle</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity/" rel="tag">unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-11-04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/04/2017-11-04/" class="article-date">
  <time datetime="2017-11-04T00:43:00.000Z" itemprop="datePublished">2017-11-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/04/2017-11-04/">UGUI适配</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>随着游戏设备越来越多，屏幕的分辨率也越来越多。而针对不同的屏幕分辨率，制作不同的素材是不现实的，所以就需要我们提供一套分辨率自适应的机制，来适配不同屏幕分辨率的设备。这篇博客就来介绍一下UGUI提供的分辨率自适应的机制。<br>游戏中的分辨率自适应主要包括两部分：一是在不同尺寸的屏幕下，整体缩放比例的计算方式；二是在不同比例（宽高比）的屏幕下，UI控件所处的位置关系，也成为布局。</p>
<p>整体缩放比例<br>UGUI中Canvas Scaler组件是负责整体缩放机制的，缩放模式提供了三种：<br>Constant Pixel Size：固定像素尺寸，即按素材的“固定像素”渲染，缩放屏幕不缩放图片，不适配屏幕<br>Scale Factor：缩放比例，在素材原尺寸上的缩放比例，默认值是1，缩放图片<br>Reference Pixels Per Unit：每个unity单位对应的像素数</p>
<p>Scale With Screen Size：根据屏幕尺寸缩放，图片跟着缩放，适配<br>Reference Resolution：标准分辨率，这是我们提供给美术做图的标准分辨率，所有的UI素材都应该按这个分辨率去做<br>Screen Match Mode：</p>
<p>Shrink 保持缩放比例，裁切</p>
<p>Expand 缩放不裁切</p>
<p>Match Width Or Height 以宽高权重匹配<br>Match：宽高所占权重，默认值是0，相当于以“标准分辨率的宽”和“实际屏幕的宽”的比例作为缩放比例。同理，如果值是1，相当于以“标准分辨率的高”和“实际屏幕的高”的比例作为缩放比例。如果值是0.5，则相当于宽和高的比例权重相等，最终的缩放比=宽缩放比<em>宽权重+高缩放比</em>高权重<br>Reference Pixels Per Unit：每个unity单位对应的像素数</p>
<p>Constant Physical Size：固定物理尺寸<br>Physical Unit：物理单位，包括点，英寸，厘米，毫米等<br>Fallback Screen DPI：对应物理单位的像素密度<br>Default Sprite DPI：默认精灵的像素密度<br>Reference Pixels Per Unit：每个unity单位对应的像素数<br>目前手机设备分辨率宽高比都在1.5:1<del>1.8:1范围，pad的分辨率在1.3:1</del>1.5:1范围，所以一般情况下，我们会根据要覆盖的机型，得到其大概的宽高比范围，从中间选择一个合适的宽高比，例如1.7:1（因为手机设备比较多，所以更接近1.8:1的比例）。有了宽高比，接下来我们要选择目标分辨率了，通常情况下以1024作为宽，以1024/1.7=602作为高比较合适，因为一般的压缩格式会要求宽高是2的次幂或者4的倍数。<br>在确定宽高比和目标分辨率之后，我们还需要设置适配规则，比较推荐的做法是做一张较大的背景图，背景图中上下左右边的内容允许被裁剪。当适配到1.8:1的设备上时，由于背景图内容宽度小于设备宽度，此时需要使用“宽”适配，这时背景图的上下边将被裁剪掉；反之适配到1.5:1的设备上时，需要使用“高”适配，这时背景图的左右边将被裁减掉。<br>布局<br>  在适配分辨率方面，除了等比缩放外，还有一方面是对UI控件位置的适配，例如角色头像一般处在屏幕的左上角，虚拟摇杆处在屏幕的左下角，要想在不同的分辨率下都处在比较合适的位置，就需要理解“锚点”的作用了。<br>   UGUI中控件的锚点都是相对于父控件的，包括 左上，中上，右上，左中，中心，右中，左下，中下，右下，默认值是中心。<br>   当我们在标准分辨率下定位好控件后，设置好合适的锚点，不论在那种分辨率下，控件都会处于一个合适的位置。<br>   以左上角头像为例，我们将其锚点（anchor）设置为“左上”，轴（pivot）设置为“左上角”。<br>   PosX和PosY即UI控件相对于父控件（Canvas）的相对位置，由于锚点设置为“左上”，轴设置为“左上角”，所以位置PosX和PosY都为0</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/11/04/2017-11-04/" data-id="cmcw1g2r5000cz4z88k928pno" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/13/2017-05-13/" class="article-date">
  <time datetime="2017-05-13T00:35:54.000Z" itemprop="datePublished">2017-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/13/2017-05-13/">三消游戏的一些算法总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>•    &quot;如何表示消除游戏的棋盘？&quot;
•    &quot;怎样检测相邻的相同元素？&quot;

•    &quot;如何实现消除后自动补全棋盘效果？
•    &quot;如何实现消除后自动生成新元素效果？&quot;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消除游戏棋盘表示</span><br><span class="line">	int[,] board &#x3D; new int[8, 8]; &#x2F;&#x2F; 0表示空位，1-6表示不同颜色</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 检测相邻相同元素</span><br><span class="line">	bool HasMatch(int[,] grid, int x, int y) &#123;</span><br><span class="line">	    int color &#x3D; grid[x, y];</span><br><span class="line">	    &#x2F;&#x2F; 检查水平方向</span><br><span class="line">	    if (x &gt; 0 &amp;&amp; grid[x-1, y] &#x3D;&#x3D; color &amp;&amp; x &lt; grid.GetLength(0)-1 &amp;&amp; grid[x+1, y] &#x3D;&#x3D; color)</span><br><span class="line">	        return true;</span><br><span class="line">	    &#x2F;&#x2F; 检查垂直方向</span><br><span class="line">	    if (y &gt; 0 &amp;&amp; grid[x, y-1] &#x3D;&#x3D; color &amp;&amp; y &lt; grid.GetLength(1)-1 &amp;&amp; grid[x, y+1] &#x3D;&#x3D; color)</span><br><span class="line">	        return true;</span><br><span class="line">	    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

•    &quot;如何实现三消游戏中的特殊连锁反应效果？&quot;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连锁反应节点</span><br><span class="line">public class ChainNode &#123;</span><br><span class="line">    public Vector2Int Position;</span><br><span class="line">    public ChainNode Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理连锁反应</span><br><span class="line">void ProcessChain(ChainNode head) &#123;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        RemoveTile(head.Position);</span><br><span class="line">        ApplySpecialEffect(head.Position);</span><br><span class="line">        head &#x3D; head.Next;</span><br><span class="line">        yield return new WaitForSeconds(0.3f); &#x2F;&#x2F; 动画间隔</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>“如何检测棋盘上的所有可消除组合？”</p>
<p>“怎样实现特殊消除效果（如L型/T型消除）？”<br>// 检测所有匹配项<br>List<Vector2Int> FindAllMatches(int[,] grid) {<br>    var matches = new List<Vector2Int>();<br>    int width = grid.GetLength(0);<br>    int height = grid.GetLength(1);</p>
<pre><code>// 水平检测
for (int y = 0; y &lt; height; y++) {
    for (int x = 0; x &lt; width - 2; x++) {
        if (grid[x, y] &gt; 0 &amp;&amp; 
            grid[x, y] == grid[x+1, y] &amp;&amp; 
            grid[x, y] == grid[x+2, y]) {
            matches.Add(new Vector2Int(x, y));
            matches.Add(new Vector2Int(x+1, y));
            matches.Add(new Vector2Int(x+2, y));
        }
    }
}

// 垂直检测（类似逻辑）
// ...

return matches.Distinct().ToList();</code></pre><p>}</p>
<p>问题：”如何实现随着玩家水平变化的难度系统？”</p>
<p>public class DifficultyAdjuster {<br>    private float playerSuccessRate;<br>    private int gamesPlayed;</p>
<pre><code>public int GetAdjustedLevel(int baseLevel) {
    float difficultyFactor = Mathf.Clamp(1.5f - playerSuccessRate, 0.5f, 2f);
    return Mathf.RoundToInt(baseLevel * difficultyFactor);
}

public void UpdateSuccess(bool levelPassed) {
    gamesPlayed++;
    playerSuccessRate = (playerSuccessRate * (gamesPlayed - 1) + (levelPassed ? 1 : 0)) / gamesPlayed;
}</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/05/13/2017-05-13/" data-id="cmcvdrdxo000wccz87nok0lgv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/07/2017-05-07/" class="article-date">
  <time datetime="2017-05-07T00:35:47.000Z" itemprop="datePublished">2017-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/07/2017-05-07/">文件的读写存储操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当程序运行时，变量时保存数据的好方法，如果希望程序结束了数据仍能保持，就需要将数据存储到文件中（序列化），你可以认为文件的内容是一个字符串值，那如何使用python 在硬盘上创建，读取和保存呢。</p>
<p>文件关键属性：</p>
<pre><code>- 文件名
- 文件路径
- 文件扩展名
- 文件权限
- 文件显示隐藏属性
- 文件大小</code></pre><p>在不同的平台路径分隔符不一致：在window上是反斜杠，在OSX 和linux上是斜杠，附加卷诸如DVD或USB在不同的操作系统上显示也不同，在window上显示的新的带字符的跟驱动器，在osx表示位/Volumes下的新文件夹，在linux上显示的是/mnt下的新文件夹</p>
<p>import os<br>os.listdir() #列出当前目录的所有文件<br>os.getcwd() #获取当前目录<br>os.chdir(‘path’) #切好当前工作目录<br>os.makedirs(‘path’) #创建文件夹<br>os.path.join(‘path’,’file’) #目录和文件拼接</p>
<p>绝对路径和相对路径<br>绝对路径总是从根文件夹开始‘/’<br>相对路径相对的是程序当前的工作目录<br>‘.’ 当前目录<br>‘..’ 当前目录的父目录<br>os.path.abspath(‘path’) #将目录转为绝对目录<br>os.path.isabs(‘path’) #判断目录是否是绝对路径<br>os.path.relpath(path1,path2) #传人参数是俩个绝对路径，返回path1 相对 path2的相对路径<br>os.path.dirname(‘path’) #返回path 参数重最后一个斜杆之前的所有内容， （文件夹路径）<br>os.path.basename(‘path’) #返回path参数最后一个斜杆之后的内容。（文件或者文件夹名）<br>os.path.split(‘path’) #返回（os.path.dirname(),os.path.basename()）</p>
<p>检查路径有效性<br>os.path.exists(‘path’) #路径是否存在或者正确<br>os.path.isdir(‘path’) #路径是否是一个目录<br>os.path.isfile(‘path’) #路径是否是一个文件</p>
<p>文件的读写<br>open(‘path’,’r/w/a/) #打开文件读，写，追加，返回一个File对象<br>close(‘path’) #关闭文件</p>
<p>用shelve 模块保存变量<br>import shelve<br>shelveFile = shelve.open(‘mydata’)<br>cats =[‘zoophix’,’bbb’,’ccc’]<br>shelveFile[‘cats’]=cats<br>shelveFile.close()</p>
<p>list(shelveFile.keys)<br>list(shelveFile.values)</p>
<p>用pprint.pformat()函数保存变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import pprint</span><br><span class="line">cats &#x3D;[&#123;&#39;name&#39;:&#39;hello&#39;,&#39;desc&#39;:&#39;world&#39;&#125;,&#123;&#39;name:&#39;ouyang&#39;,&#39;desc&#39;:&#39;haha&#39;&#125;]</span><br><span class="line">pprint.pformat(cats)</span><br><span class="line">fileobj &#x3D; open(&#39;myCats.py&#39;,&#39;w&#39;)</span><br><span class="line">fileobj.write(&#39;cats&#x3D;&#39; + pprint.pformat(cats) + &#39;\n&#39;)</span><br><span class="line">fileobj.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import myCats</span><br><span class="line">myCats.cats</span><br><span class="line">myCats.cats[0]</span><br><span class="line">myCats.cats[0][name]</span><br></pre></td></tr></table></figure>
<p>创建一个.py文件而不是利用shelve模块保存变量的好处在于他是一个文本文件，所以任何人都可以用一个简单的文本编辑器读取和修改该文件的内容，但是对于大多数应用，利用shelve模块来保存数据，是将变量保存到文本的最佳方式，因为只有基本数据类型，诸如整形，浮点型，字符串，列表和字典，可以作为简单文本写入一个文件。而对象就不能编码为简单文本，比如File对象。</p>
<p>从剪切板取得文本<br>将文本张贴到剪切板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pyperclip,re</span><br><span class="line">text &#x3D; str(pyperclip.paste())</span><br><span class="line">matchs &#x3D;[]</span><br><span class="line">for groups in phoneRx.findall(text):</span><br><span class="line">	phonenum &#x3D; &#39;-&#39;.join([group[1],group[3],group[5])</span><br><span class="line">	matchs.append(phonenum</span><br><span class="line">	</span><br><span class="line">if len(matchs)&gt;0:</span><br><span class="line">	pyperclip.copy(&#39;\n&#39;.join(matchs))</span><br><span class="line">	print(Copied to clipboard:)</span><br><span class="line">	print(&#39;\n&#39;.join(matchs))</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/05/07/2017-05-07/" data-id="cmcvdrdxl000tccz8hnnv0ex3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/06/2017-05-06/" class="article-date">
  <time datetime="2017-05-06T00:35:40.000Z" itemprop="datePublished">2017-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/06/2017-05-06/">python 正则表达式练习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>知道【正则表达式】可能意味着用3步解决一个问题，而不是用3000步，如果你是一个技术怪侠，别忘了你用几次快捷键就能解决的问题，其他人需要数天的繁琐工作才能解决，而且他们还容易犯错。<br>                                        —- Cory Doctorow </p>
</blockquote>
<p>正则表达式总结：</p>
<ul>
<li>()添加小括号将在正则表达式中创建分组，</li>
<li>？匹配[0,1]次前面的分组</li>
<li>*匹配[0,多]次前面的分组</li>
<li>+匹配[1,多]次前面的分组</li>
<li>{}匹配特定次数或者特定范围次数的前面的分组</li>
<li>{N} 匹配 N 次前面的分组</li>
<li>{N，}匹配[N, 多]次前面的分组</li>
<li>{,N}匹配[0,N]次前面的分组</li>
<li>{N,M}匹配[N,M]次前面的分组进行贪心（最大）匹配</li>
<li>{N,M}?匹配[N,M]次前面的分组进行非贪心（最小）匹配</li>
<li>*？或+？对前面的分组进行最小匹配。</li>
<li>^span匹配的字符串必须以span开头</li>
<li>span$匹配的字符串必须以span结束</li>
<li>. 匹配所有字符（一个字符），换行符除外</li>
<li>\d,\w和\s分别匹配数字（0-9），单词（任意字母，数字或下划线），和空格（空格，制表符，换行符），</li>
<li>\D,\W,\S分别匹配出除数字，单词（任意字母，数字或下划线），空格（空格，制表符，换行符）以外的所有字符</li>
<li>[abca-zA-Z0-9]匹配方括号中的任意字符</li>
<li>[^abc]匹配不在方括号内的任意字符</li>
</ul>
<p>python中使用正则表达式<br>import re #导入模块<br>x = re.compile(r’(\d\d\d)-(\d\d\d-\d\d\d\d) ‘) # 创建一个匹配对象 ，python 的转义字符要加<br>mo = x.search(‘My number is 415-555-4242. ‘) # 搜索匹配正则<br>mo.group() #匹配的结果</p>
<p>使用group（）匹配对象的方法从一个分组中获取匹配的文本，查找的是第一个匹配对象<br>group（）和group（0）返回完整的匹配<br>group(1),group(2) 返回对应第几个括号中的匹配值<br>groups() 返回多个匹配值的元组<br>mo.groups()<br>(‘415’,’555-4242’)<br>areacode,mainNumber = mo.groups()<br>areacode = 415<br>mainNumber = 5555-4242</p>
<p>用管道匹配多个分组（｜）<br>字符‘｜’称为管道，希望匹配多个值时使用r’a|b|c’将匹配a或b或c</p>
<p>使用findall（） 可以找出所有的匹配结果<br>只有正则表达式中没有分组，返回的是一个字符串列表。<br>如果有分组，findall将返回一个匹配的元组的列表。</p>
<p>用问号？实现可选匹配<br>re.compile(r’[aeiouAEIOU]’)匹配单词中的元音字母<br>re.compile(r’[^aeiouAEIOU]’)匹配单词中的非元音字母<br>在[]中的普通的正则表达式符合不会被解释，所以不要在前面(.,*,?,(,),)加转义的反斜杠（\）</p>
<p>点-星（.*）能匹配除换行外的所有字符，通过对re.comile()的第二个参数传人re.DOTALL,可以让句点字符匹配包括换行字符。</p>
<p>用sub（）方法替换字符串</p>
<p>管理复杂的正则表达式<br>比较复杂的需要长的费解的正则表达式，可以传人re.VERBOSE 作为re.compile()的第二个参数，可以忽略正则表达式中的空白符和注释。从而缓解复杂</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">eg： phoneRx &#x3D; re.compile(r&#39;((\d&#123;3&#125;|\(\d3\))?(\s|-|\.)?\d&#123;3&#125;(\s|-|\.)\d&#123;4&#125;(\s*(ext|x|ext.)\s*\d&#123;2,5&#125;)?)&#39;)</span><br><span class="line"></span><br><span class="line">phoneRx &#x3D; re.compile(r&#39;&#39;&#39;(</span><br><span class="line">	(\d&#123;3&#125;|\(d&#123;3&#125;\))? #区号</span><br><span class="line">	(\s|-|\.)? #分隔</span><br><span class="line">	\d&#123;3&#125; #前三</span><br><span class="line">	(\s|-\.) #分隔</span><br><span class="line">	\d&#123;4&#125; #后四</span><br><span class="line">	(\s*(ext|x|ext.)\s*\d&#123;2,5&#125;)? #扩展</span><br><span class="line">)&#39;&#39;&#39;,re.VERBOSE)</span><br></pre></td></tr></table></figure>

<p>使用re.IGNORECASE 忽略大小写<br>someRx = re.compile(‘foo’,re.IGNORECASE|re.DOTALL|re.VERBOSE) #按位或来组合使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/05/06/2017-05-06/" data-id="cmcvdrdxh000qccz888ul71o4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2017-05-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/02/2017-05-02/" class="article-date">
  <time datetime="2017-05-02T00:26:37.000Z" itemprop="datePublished">2017-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/02/2017-05-02/">不要急于学习编程语言，先学会如何解决问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这是一篇关于虚度青春的短篇回忆录。<br>多年来，我一直在学习编程语言，然后用它们来构建更好的投资工具。在建立预测和风险管理模型之余，编程方面的工作堆积如山。<br>但实际上，我并没有花太多时间在真正需要解决的问题上。<br>我把大部分注意力放在了算法和编程语言上。多年来，我每周都要花几个小时学习计算机基础知识，却没有花太多时间应用这些知识来让现实世界变得更美好。<br>而我的一个朋友却基于微软 Office 开发出了一个完整的产品，它使用 Access 保存数据，使用 Excel 分析数据，然后使用 Word 输出报告。<br>当他把产品卖给一家大公司时，我为他感到高兴，同时也有些嫉妒。我比他更了解编程，但却没能推出可以解决实际问题的产品。<br>实际上，为什么要开发产品比如何开发产品更加重要。我花时间学习如何编程，而我的朋友把时间花在解决实际的问题上。<br>他从使用非常简单的工具开始，一步一步往前走，直到找到一个完整的解决方案。在这个过程中，他自学了如何将其他工具整合在一起。这仍然需要做大量的工作，但他做到了，尽管资源非常有限。<br>1<br>神奇之处在于“为什么”<br>后来，我加入了一家初创公司，并最终汲取了这个教训。<br>一个团队能否取得重大突破从来都不取决于如何使用代码完成某些功能，而在于知道要做什么，以及为什么要这样做。<br>在创造性的旅程中，没有什么比在不必要的东西上投入太多更令人心碎的了。<br>如果你想要创造出一些有用的东西，首先要知道“为什么”要这样做。从一开始你就要问自己：谁会用这些东西，它们将如何改善他们的生活？<br>2<br>专注于解决真正的问题可以加快学习速度<br>当你专注于真正需要解决的问题时，大脑中的信息留存率会更高。我们的大脑会优先考虑需要保存的信息，并忽略大部分其他东西。这样可以节约能量，但不利于学习。<br>知道自己为什么要学习，就相当于触发大脑要优先考虑新信息。<br>追求创造性的活动会让你学得更快，而这并不要求你一定要学会一门编程语言。<br>3<br>下面这些事情比学习编程语言更重要<br>找到真正的问题。<br>把问题写下来，它现在是什么样的，它应该是什么样的，并尽可能详细。例如，如果你的问题与使用 Office 文件格式保存数据有关，那么就详细说明这方面的问题，这样有助于找到最好的解决方案。<br>当你对问题本身以及你想如何解决问题有了很好的描述，你就已经成功了一半。<br>然后你要努力去澄清问题，朝着可以找到解决方案的方向迈进。<br>如果你在这个时候纠结于编程语言，那么你可能不是一个好程序员。你要不断培养描述问题和解决方案的能力。<br>当你对问题有了很好的描述，并且确切地知道想要什么，然后再去学习一门编程语言来解决这个问题就变得很容易了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/05/02/2017-05-02/" data-id="cmcvdrdw80000ccz823nhdj8s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">程序员</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assetbundle/" rel="tag">Assetbundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/" rel="tag">IOC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Particle-System/" rel="tag">Particle System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shader/" rel="tag">Shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" rel="tag">Slot, 老虎机，游戏研究</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UGUI/" rel="tag">UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-C/" rel="tag">Unity, C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" rel="tag">Unity, UI框架, UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity%EF%BC%8CAssetBundle/" rel="tag">Unity，AssetBundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gameframework/" rel="tag">gameframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-server/" rel="tag">http.server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" rel="tag">slot, 老虎机, slot game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity-python/" rel="tag">unity python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlua-lua-framework/" rel="tag">xlua, lua, framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%B1%E5%BF%97/" rel="tag">励志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" rel="tag">物理引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">程序员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/Assetbundle/" style="font-size: 10px;">Assetbundle</a> <a href="/tags/C/" style="font-size: 15.71px;">C#</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 14.29px;">Java</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Particle-System/" style="font-size: 10px;">Particle System</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" style="font-size: 10px;">Slot, 老虎机，游戏研究</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/UGUI/" style="font-size: 11.43px;">UGUI</a> <a href="/tags/Unity/" style="font-size: 18.57px;">Unity</a> <a href="/tags/Unity-C/" style="font-size: 10px;">Unity, C#</a> <a href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" style="font-size: 10px;">Unity, UI框架, UGUI</a> <a href="/tags/Unity%EF%BC%8CAssetBundle/" style="font-size: 10px;">Unity，AssetBundle</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/gameframework/" style="font-size: 10px;">gameframework</a> <a href="/tags/http-server/" style="font-size: 10px;">http.server</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/mysql/" style="font-size: 12.86px;">mysql</a> <a href="/tags/python/" style="font-size: 12.86px;">python</a> <a href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" style="font-size: 10px;">slot, 老虎机, slot game</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/unity/" style="font-size: 17.14px;">unity</a> <a href="/tags/unity-python/" style="font-size: 10px;">unity python</a> <a href="/tags/xlua-lua-framework/" style="font-size: 11.43px;">xlua, lua, framework</a> <a href="/tags/%E5%8A%B1%E5%BF%97/" style="font-size: 10px;">励志</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" style="font-size: 10px;">物理引擎</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 10px;">程序员</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.43px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 20px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/13/2025-07-13/">简单的服务器搭建</a>
          </li>
        
          <li>
            <a href="/2025/07/11/2025-07-11/">框架之日志管理系统</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-12/">unity 一键打包</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-10/">Unity UI框架总结</a>
          </li>
        
          <li>
            <a href="/2025/07/09/2025-07-09/">Unity 打android 包报错总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 OuyangWenyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>