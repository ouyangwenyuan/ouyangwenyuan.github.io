<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>持续学习者————Just Do It！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:type" content="website">
<meta property="og:title" content="持续学习者————Just Do It！">
<meta property="og:url" content="http://droidman.net/page/2/index.html">
<meta property="og:site_name" content="持续学习者————Just Do It！">
<meta property="og:description" content="看，听，学，记，练；读，思，写，说，教。读书百遍，其义自现，熟能生巧，巧能升精，精能升华，华能出奇，出奇方能制胜。">
<meta property="og:locale" content="en,ZH">
<meta property="article:author" content="OuyangWenyuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Objective-c">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Unity3d">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="Program">
<meta property="article:tag" content="Mac OS">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="Window">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="xcode">
<meta property="article:tag" content="IDEA">
<meta property="article:tag" content="eclicpse">
<meta property="article:tag" content="blender">
<meta property="article:tag" content="MVC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="持续学习者————Just Do It！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">持续学习者————Just Do It！</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学无止境————不怕你不会，就怕你不学！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://droidman.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2025-07-03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/03/2025-07-03/" class="article-date">
  <time datetime="2025-07-03T00:27:04.000Z" itemprop="datePublished">2025-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/03/2025-07-03/">框架之网络模块</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Socket负责和游服的通信，包括网络的连接、消息的接收、心跳包的发送、断线重连的监听和处理</p>
<p>那一个完整的网络模块包括几方面呢？（仅讨论客户端）</p>
<p>1.建立和服务端的socket连接，实现客户端-服务端两端的接收和发送功能。</p>
<p>2.消息协议的选择，网络消息的解析可以是json、xml、protobuf,本篇使用的是protobuf</p>
<p>3.消息缓存</p>
<p>4.消息的监听、分发、移除</p>
<p>5.客户端身份验证，由客户端、服务端生成密钥进行验证。</p>
<p>6.心跳包的实现，主要是检测客户端的连接情况，避免浪费服务端资源</p>
<p>如上所述，一套完整的unity的socket网络通信模块所包含的内容大概就是这些。</p>
<p>示例工程：链接: <a href="https://pan.baidu.com/s/1vJbo0ThXhShk9eJv3VNCuw" target="_blank" rel="noopener">https://pan.baidu.com/s/1vJbo0ThXhShk9eJv3VNCuw</a> 提取码: fngy  本篇文章资源连接</p>
<p>该工程主要是实现客户端-服务端两端的连接，以及消息的监听、派发、发送、接受等功能，心跳包未实现。</p>
<p>一、创建一个socekt连接</p>
<p>客户端代码如下：创建一个Socket对象，这个对象在客户端是唯一的，连接指定服务器IP和端口号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void Connect(string host, int port)</span><br><span class="line">    &#123;</span><br><span class="line">        if (string.IsNullOrEmpty(host))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;NetMgr.Connect host is null&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;IP验证</span><br><span class="line">        IPEndPoint ipEndPoint &#x3D; null;</span><br><span class="line">        Regex regex &#x3D; new Regex(&quot;((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|[1-9])&quot;);</span><br><span class="line">        Match match &#x3D; regex.Match(host);</span><br><span class="line">        if (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; IP</span><br><span class="line">            ipEndPoint &#x3D; new IPEndPoint(IPAddress.Parse(host), port);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 域名</span><br><span class="line">            IPAddress[] addresses &#x3D; Dns.GetHostAddresses(host);</span><br><span class="line">            ipEndPoint &#x3D; new IPEndPoint(addresses[0], port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;新建连接，连接类型</span><br><span class="line">        mSocket &#x3D; new Socket(ipEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        </span><br><span class="line">        try</span><br><span class="line">        &#123;           </span><br><span class="line">            mSocket.Connect(ipEndPoint);&#x2F;&#x2F;链接IP和端口</span><br><span class="line">        &#125;</span><br><span class="line">        catch (System.Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>服务端代码：创建一个服务器Socket对象，并绑定服务器IP地址和端口号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void InitSocket(string host, int port)</span><br><span class="line">    &#123;</span><br><span class="line">        if (string.IsNullOrEmpty(host))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;NetMgr.Connect host is null&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;IP验证</span><br><span class="line">        IPEndPoint ipEndPoint &#x3D; null;</span><br><span class="line">        Regex regex &#x3D; new Regex(&quot;((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.)&#123;3&#125;(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|[1-9])&quot;);</span><br><span class="line">        Match match &#x3D; regex.Match(host);</span><br><span class="line">        if (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; IP</span><br><span class="line">            ipEndPoint &#x3D; new IPEndPoint(IPAddress.Parse(host), port);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; 域名</span><br><span class="line">            IPAddress[] addresses &#x3D; Dns.GetHostAddresses(host);</span><br><span class="line">            ipEndPoint &#x3D; new IPEndPoint(addresses[0], port);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;新建连接，连接类型</span><br><span class="line">        mSocket &#x3D; new Socket(ipEndPoint.AddressFamily, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        </span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            mSocket.Bind(ipEndPoint);&#x2F;&#x2F;绑定IP和端口          </span><br><span class="line">            mSocket.Listen(5);&#x2F;&#x2F;设置监听数量   </span><br><span class="line">        &#125;</span><br><span class="line">        catch (System.Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>二.protobuf协议生成、解析</p>
<p>我们在存储一串数据的时候，无论这串数据里包含了哪些数据以及哪些数据类型，当我们拿到这串数据在解析的时候能够知道该怎么解析，这是定义协议格式的目标。它是协议解析的规则。</p>
<p>简单的来说就是，当你传给我一串数据的时候，我是用什么样的规则知道这串数据里的内容的。JSON就制定了这么一个规则，这个规则以字符串KEY-VALUE，以及一些辅助的符号‘{’,’}’,’[‘,’]’组合而成，这个规则非常通用，以至于任何人拿到任何JSON数据都能知道里面有什么数据。</p>
<p>protobuf优势：这里只比较json（JSON与同是纯文本类型格式的XML相比较，JSON不需要结束标签，JSON更短，JSON解析和读写的速度更快，所以json是优于xml的）</p>
<p>序列化和反序列化效率比 xml 和 json 都高，序列化的二进制文件更小（传输就更快，节省流量）适合网络传输节省io，Protobuf 数据使用二进制形式，把原来在JSON,XML里用字符串存储的数字换成用byte存储，大量减少了浪费的存储空间。与MessagePack相比，Protobuf减少了Key的存储空间，让原本用字符串来表达Key的方式换成了用整数表达，不但减少了存储空间也加快了反序列化的速度。<br>Json明文，维护麻烦。<br>protobuf提供的多语言支持，所以使用protobuf作为数据载体定制的网络协议具有很强的跨语言特性</p>
<p>缺点：<br>通用性差<br>二进制存储易读性很差，除非你有 .proto 定义，否则你没法直接读出 Protobuf 的任何内容<br>需要依赖于工具生成代码<br>需要生成数据解析类，占用空间<br>协议序号也要占空间，序号越大占空间越大，当序号小于16时无需额外增加字节就可以表示。</p>
<p>1.protobuf语法：官方网站:<a href="https://developers.google.com/protocol-buffers/docs/proto3，英文不好可参考下面的中文语法，这边不做赘述" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/proto3，英文不好可参考下面的中文语法，这边不做赘述</a></p>
<p>中文语法：<a href="https://blog.csdn.net/u011518120/article/details/54604615" target="_blank" rel="noopener">https://blog.csdn.net/u011518120/article/details/54604615</a></p>
<p>大概样子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package protocol;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;握手验证</span><br><span class="line">message Handshake&#123;</span><br><span class="line">    required string token&#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;玩家信息</span><br><span class="line">message PlayerInfo&#123;</span><br><span class="line">    required int32 account&#x3D; 1;</span><br><span class="line">    required string password&#x3D; 2;    </span><br><span class="line">    required string name&#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.协议解析类的生成，如下图所示，双击protoToCs.bat文件就可以把proto文件夹下的.proto协议生成c#文件并存储在generate目录下，proto和生成的cs目录更改在protoToCs文件里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"> @rem 对该目录下每个*.prot文件做转换</span><br><span class="line"> set curdir&#x3D;%cd%</span><br><span class="line"> set protoPath&#x3D;%curdir%\proto\</span><br><span class="line"> set generate&#x3D;%curdir%\generate\</span><br><span class="line"> echo %curdir%</span><br><span class="line"> echo %protoPath%</span><br><span class="line"></span><br><span class="line"> for &#x2F;r %%j in (*.proto) do ( </span><br><span class="line">    echo %%j</span><br><span class="line">    protogen -i:&quot;%%j&quot; -o:%generate%%%~nj.cs </span><br><span class="line"> )</span><br><span class="line"> pause</span><br></pre></td></tr></table></figure>
<p>3.协议的解包、封包（解析类的使用），这边协议的格式是  协议数据长度+协议id+协议数据</p>
<p>当要发送消息给服务端（或客户端）时，调用PackNetMsg封装成二进制流数据，接受到另一端的消息时调用UnpackNetMsg解析成对应的数据类，在分发给客户端使用</p>
<p>协议封包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 序列化  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;&lt;&#x2F;typeparam&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;param&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;  </span><br><span class="line">    static public byte[] Serialize&lt;T&gt;(T msg)</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] result &#x3D; null;</span><br><span class="line">        if (msg !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            using (var stream &#x3D; new MemoryStream())</span><br><span class="line">            &#123;</span><br><span class="line">                Serializer.Serialize&lt;T&gt;(stream, msg);</span><br><span class="line">                result &#x3D; stream.ToArray();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;封包，依次写入协议数据长度、协议id、协议内容</span><br><span class="line">    public static byte[] PackNetMsg(NetMsgData data)</span><br><span class="line">    &#123;</span><br><span class="line">        ushort protoId &#x3D; data.ProtoId;</span><br><span class="line">        MemoryStream ms &#x3D; null;</span><br><span class="line">        using (ms &#x3D; new MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            ms.Position &#x3D; 0;</span><br><span class="line">            BinaryWriter writer &#x3D; new BinaryWriter(ms);</span><br><span class="line">            byte[] pbdata &#x3D; Serialize(data.ProtoData);</span><br><span class="line">            ushort msglen &#x3D; (ushort)pbdata.Length;</span><br><span class="line">            writer.Write(msglen);</span><br><span class="line">            writer.Write(protoId);</span><br><span class="line">            writer.Write(pbdata);</span><br><span class="line">            writer.Flush();</span><br><span class="line">            return ms.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; 反序列化  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;T&quot;&gt;&lt;&#x2F;typeparam&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;message&quot;&gt;&lt;&#x2F;param&gt;  </span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;  </span><br><span class="line">    static public T Deserialize&lt;T&gt;(byte[] message)</span><br><span class="line">    &#123;</span><br><span class="line">        T result &#x3D; default(T);</span><br><span class="line">        if (message !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            using (var stream &#x3D; new MemoryStream(message))</span><br><span class="line">            &#123;</span><br><span class="line">                result &#x3D; Serializer.Deserialize&lt;T&gt;(stream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;解包，依次写出协议数据长度、协议id、协议数据内容</span><br><span class="line">    public static NetMsgData UnpackNetMsg(byte[] msgData)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryStream ms &#x3D; null;</span><br><span class="line"></span><br><span class="line">        using (ms &#x3D; new MemoryStream(msgData))</span><br><span class="line">        &#123;</span><br><span class="line">            BinaryReader reader &#x3D; new BinaryReader(ms);</span><br><span class="line">            ushort msgLen &#x3D; reader.ReadUInt16();</span><br><span class="line">            ushort protoId &#x3D; reader.ReadUInt16();</span><br><span class="line"></span><br><span class="line">            if (msgLen &lt;&#x3D; msgData.Length - 4)</span><br><span class="line">            &#123;</span><br><span class="line">                IExtensible protoData &#x3D; CreateProtoBuf.GetProtoData((ProtoDefine)protoId, reader.ReadBytes(msgLen));</span><br><span class="line">                return NetMsgDataPool.GetMsgData((ProtoDefine)protoId, protoData, msgLen);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(&quot;协议长度错误&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后这边会需要根据协议的id去生成对应的解析类，有两种方式，一种使用switch，一种是用反射的方式去生成，放射应该效率会高一点，本篇使用的是第一种（反射玩不转，我知道怎么根据类名生成指定的类，但是当参数是泛型是就盟了，评论如果有知道欢迎指出来，例如我知道类名xxx,我怎么调用Serializer.Deserialize<T>(stream);这个方法呢，就是我要怎么用xxx替换T呢）</p>
<p>switch实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;动态修改，不要手动修改</span><br><span class="line"></span><br><span class="line">using protocol;</span><br><span class="line">public class CreateProtoBuf</span><br><span class="line">&#123;</span><br><span class="line">  public static ProtoBuf.IExtensible GetProtoData(ProtoDefine protoId, byte[] msgData)</span><br><span class="line">  &#123;</span><br><span class="line">      switch (protoId)</span><br><span class="line">      &#123;</span><br><span class="line">            case ProtoDefine.Handshake:</span><br><span class="line">                return NetUtilcs.Deserialize&lt;Handshake&gt;(msgData);</span><br><span class="line">            case ProtoDefine.ReqLogin:</span><br><span class="line">                return NetUtilcs.Deserialize&lt;ReqLogin&gt;(msgData);</span><br><span class="line">            case ProtoDefine.ReqRegister:</span><br><span class="line">                return NetUtilcs.Deserialize&lt;ReqRegister&gt;(msgData);</span><br><span class="line">            case ProtoDefine.RetLogin:</span><br><span class="line">                return NetUtilcs.Deserialize&lt;RetLogin&gt;(msgData);</span><br><span class="line">            case ProtoDefine.RetRegister:</span><br><span class="line">                return NetUtilcs.Deserialize&lt;RetRegister&gt;(msgData);</span><br><span class="line">          default:</span><br><span class="line">              return null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>createbuf这个类如果手撸的话，几百种协议还是很头疼的，所以我这边是写了个工具去生成这个类，模板也是可以实现这个功能的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static void WriteCreateBufClass()</span><br><span class="line">    &#123;</span><br><span class="line">        using (StreamWriter sw &#x3D; new StreamWriter(Application.dataPath + &quot;&#x2F;Scripts&#x2F;Engine&#x2F;Net&#x2F;CreateProtoBuf.cs&quot;, false))</span><br><span class="line">        &#123;</span><br><span class="line">            sw.WriteLine(&quot;&#x2F;&#x2F;动态修改，不要手动修改\n&quot;);</span><br><span class="line">            sw.WriteLine(&quot;using protocol;&quot;);</span><br><span class="line">            sw.WriteLine(&quot;public class CreateProtoBuf&quot;);</span><br><span class="line">            sw.WriteLine(&quot;&#123;&quot;);</span><br><span class="line">            sw.WriteLine(&quot;  public static ProtoBuf.IExtensible GetProtoData(ProtoDefine protoId, byte[] msgData)&quot;);</span><br><span class="line">            sw.WriteLine(&quot;  &#123;&quot;);</span><br><span class="line">            sw.WriteLine(&quot;      switch (protoId)&quot;);</span><br><span class="line">            sw.WriteLine(&quot;      &#123;&quot;);</span><br><span class="line"></span><br><span class="line">            foreach (int value in Enum.GetValues(typeof(ProtoDefine)))</span><br><span class="line">            &#123;</span><br><span class="line">                string strName &#x3D; Enum.GetName(typeof(ProtoDefine), value);&#x2F;&#x2F;获取名称</span><br><span class="line">                sw.WriteLine(string.Format(&quot;            case ProtoDefine.&#123;0&#125;:&quot;, strName));</span><br><span class="line">                sw.WriteLine(string.Format(&quot;                return NetUtilcs.Deserialize&lt;&#123;0&#125;&gt;(msgData);&quot;, strName));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sw.WriteLine(&quot;          default:&quot;);</span><br><span class="line">            sw.WriteLine(&quot;              return null;&quot;);</span><br><span class="line">            sw.WriteLine(&quot;      &#125;&quot;);</span><br><span class="line">            sw.WriteLine(&quot;  &#125;&quot;);</span><br><span class="line">            sw.WriteLine(&quot;&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这样协议的生成、解析都有了，剩下的就是消息的管理了</p>
<p> 三、消息的缓存、接受、发送</p>
<p>客户端消息队列：总共生成四个缓存队列，两个子线程，一个用于发送消息，一个用于接收消息，主要是防止同时接受、发送多条信息，以及实现转菊花的效果（发送消息开始转菊花，服务器回包后结束菊花，防止重复发送消息）</p>
<p>发送代码如下：创建两个队列，一个用于存储主线程的等待发送的队列（由各模块调用），一个用于子线程向服务器发送消息（使用支线程向socket发送消息，减少主线程压力）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void Send()</span><br><span class="line">    &#123;</span><br><span class="line">        while (this.mIsRunning)</span><br><span class="line">        &#123;</span><br><span class="line">            if (mSendingMsgQueue.Count &#x3D;&#x3D; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                lock (this.mSendLock)</span><br><span class="line">                &#123;</span><br><span class="line">                    while (this.mSendWaitingMsgQueue.Count &#x3D;&#x3D; 0)</span><br><span class="line">                        Monitor.Wait(this.mSendLock);</span><br><span class="line">                    Queue&lt;NetMsgData&gt; temp &#x3D; this.mSendingMsgQueue;</span><br><span class="line">                    this.mSendingMsgQueue &#x3D; this.mSendWaitingMsgQueue;</span><br><span class="line">                    this.mSendWaitingMsgQueue &#x3D; temp;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    NetMsgData msg &#x3D; this.mSendingMsgQueue.Dequeue();</span><br><span class="line">                    byte[] data &#x3D; NetUtilcs.PackNetMsg(msg);</span><br><span class="line">                    mSocket.Send(data, data.Length, SocketFlags.None);</span><br><span class="line">                    Debug.Log(&quot;client send: &quot; + (ProtoDefine)msg.ProtoId);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (System.Exception e) &#123;</span><br><span class="line">                    Debug.LogError(e.Message);</span><br><span class="line">                    Disconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.mSendingMsgQueue.Clear();</span><br><span class="line">        this.mSendWaitingMsgQueue.Clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　&#x2F;&#x2F;业务调用接口</span><br><span class="line">    public void SendMsg(ProtoDefine protoType, IExtensible protoData)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!this.mIsRunning) return;</span><br><span class="line">        lock (this.mSendLock)</span><br><span class="line">        &#123;</span><br><span class="line">            mSendWaitingMsgQueue.Enqueue(NetMsgDataPool.GetMsgData(protoType, protoData));</span><br><span class="line">            Monitor.Pulse(this.mSendLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>数据的接受：创建两个队列，一个用于缓存子线程从服务器接受的消息，一个用于向主线程分发消息</p>
<p>这边的update方法需要由主线程调用，或者使用协程也是可以实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void Receive()</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] data &#x3D; new byte[1024];</span><br><span class="line">        while (this.mIsRunning)</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;将收到的数据取出来</span><br><span class="line">                int len &#x3D; mSocket.Receive(data);</span><br><span class="line">                NetMsgData receive &#x3D; NetUtilcs.UnpackNetMsg(data);</span><br><span class="line">                Debug.Log(&quot;client receive : &quot; + (ProtoDefine)receive.ProtoId);</span><br><span class="line"></span><br><span class="line">                lock (this.mRecvLock)</span><br><span class="line">                &#123;</span><br><span class="line">                    this.mRecvWaitingMsgQueue.Enqueue(receive);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            catch (System.Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.LogError(e.Message);</span><br><span class="line">                Disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!this.mIsRunning) return;</span><br><span class="line"></span><br><span class="line">        if (this.mRecvingMsgQueue.Count &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            lock (this.mRecvLock)</span><br><span class="line">            &#123;</span><br><span class="line">                if (this.mRecvWaitingMsgQueue.Count &gt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    Queue&lt;NetMsgData&gt; temp &#x3D; this.mRecvingMsgQueue;</span><br><span class="line">                    this.mRecvingMsgQueue &#x3D; this.mRecvWaitingMsgQueue;</span><br><span class="line">                    this.mRecvWaitingMsgQueue &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            while (this.mRecvingMsgQueue.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                NetMsgData msg &#x3D; this.mRecvingMsgQueue.Dequeue();</span><br><span class="line">                &#x2F;&#x2F;发送给逻辑处理</span><br><span class="line">                NetMsg.DispatcherMsg(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>四、消息的监听、派发，业务通过这个类和socket交互</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using ProtoBuf;</span><br><span class="line">using protocol;</span><br><span class="line"></span><br><span class="line">public delegate void NetCallBack(IExtensible msgData);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 业务和socket交互的中间层</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class NetMsg</span><br><span class="line">&#123;</span><br><span class="line">    private static Dictionary&lt;ProtoDefine, Delegate&gt; m_EventTable &#x3D; new Dictionary&lt;ProtoDefine, Delegate&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 监听指定的消息协议</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;protoType&quot;&gt;&lt;&#x2F;param&gt; 需要监听的消息</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;callBack&quot;&gt;&lt;&#x2F;param&gt; 当接收到服务端的消息时，需要触发的消息</span><br><span class="line">    public static void ListenerMsg(ProtoDefine protoType, NetCallBack callBack)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!m_EventTable.ContainsKey(protoType))</span><br><span class="line">        &#123;</span><br><span class="line">            m_EventTable.Add(protoType, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_EventTable[protoType] &#x3D; (NetCallBack)m_EventTable[protoType] + callBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 移除监听某条消息</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;protoType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;callBack&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public static void RemoveListenerMsg(ProtoDefine protoType, NetCallBack callBack)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_EventTable.ContainsKey(protoType))</span><br><span class="line">        &#123;</span><br><span class="line">            m_EventTable[protoType] &#x3D; (NetCallBack)m_EventTable[protoType] - callBack;</span><br><span class="line"></span><br><span class="line">            if (m_EventTable[protoType] &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                m_EventTable.Remove(protoType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 接收到服务端消息时，会调用这个接口通知监听这调协议的业务</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;msgData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public static void DispatcherMsg(NetMsgData msgData)</span><br><span class="line">    &#123;</span><br><span class="line">        ProtoDefine protoType &#x3D; (ProtoDefine)msgData.ProtoId;</span><br><span class="line">        Delegate d;</span><br><span class="line">        if (m_EventTable.TryGetValue(protoType, out d))</span><br><span class="line">        &#123;</span><br><span class="line">            NetCallBack callBack &#x3D; d as NetCallBack;</span><br><span class="line">            if (callBack !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                callBack(msgData.ProtoData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 向服务端发送消息</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;protoType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;protoData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public static void SendMsg(ProtoDefine protoType, IExtensible protoData)</span><br><span class="line">    &#123;</span><br><span class="line">        SocketClint.Instance.SendMsg(protoType, protoData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>五、客户端身份验证，做完上面的步骤，你已经可以生成、解析、使用消息协议，也可以和服务端通信了，其实通信功能就已经做完了，但是客户端验证和心跳包又是游戏绕不过去的一个步骤，所以  我们继续～</p>
<p>认证的过程大概是这样子的（以我当前的项目为例）</p>
<p>1.客户端随机生成一个密钥client_key，使用某种加密算法通过刚生成的密钥client_key将自己的client_token加密，然后将加密后的client_token和密钥发送给登录服（client_token只是一个字符串，客户端和服务端都有，这边的加密算法加密时需要一个密钥，服务端和客户端的加密算法是一样的）</p>
<p>2.登录服收到客户端的消息，通过客户端发送的密钥client_key解密出客户端的client_token，通过比对这个client_token能确定是不是正确的客户端，如果是，登录服随机生成一个密钥server_key，并将使用server_key加密后的登录服server_token连同server_key发送给客户端</p>
<p>3.客户端收到登录服返回的消息，通过登录服发送的密钥server_key解密出登录服的server_token，通过比对这个server_token能确定是不是正确的登录服</p>
<p>4.双方身份验证后进行账号验证，客户端重新生成密钥client_key2，将自己的账号、密码、设备id等信息加密成client_info连同client_key2发送给登录服</p>
<p>5.登录服接收到客户端消息后，过客户端发送的密钥client_key2解密出客户端的client_info，通过比对账号、密码信息，返回一个游服的token，并把该token同步给游服</p>
<p>6.客户端通过登录服返回的游服token登录游服，关闭登录服连接</p>
<p>那么为什么要有登录服呢，我个人的理解是1.登录服可以很大的分摊游服的压力，特别是开服的时候2.游戏服一般会有很多（例如slg的王国），而登录服只会有一个？好吧  这个有知道的大神麻烦在评论告诉我下</p>
<p>六、心跳包，具体可以参考<a href="https://gameinstitute.qq.com/community/detail/101837" target="_blank" rel="noopener">https://gameinstitute.qq.com/community/detail/101837</a></p>
<p>心跳包主要用于长连接的保活和断线处理，socket本身的断开通知不是很靠谱，有时候客户端断开网络，Socket并不能实时监测到，服务器还维持这个客户端不必要的引用</p>
<p>心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着加了服务器的负荷</p>
<p>怎么发送心跳？</p>
<p>1：轮询机制：概括来说是服务端定时主动的与客户端通信，询问当前的某种状态，客户端返回状态信息，客户端没有返回，则认为客户端已经宕机，然后服务端把这个客户端的宕机状态保存下来，如果客户端正常，那么保存正常状态。如果客户端宕机或者返回的是定义</p>
<p>的失效状态那么当前的客户端状态是能够及时的监控到的，如果客户端宕机之后重启了那么当服务端定时来轮询的时候，还是可以正常的获取返回信息，把其状态重新更新。</p>
<p>2：心跳机制：最终得到的结果是与轮询一样的但是实现的方式有差别，心跳不是服务端主动去发信息检测客户端状态，而是在服务端保存下来所有客户端的状态信息，然后等待客户端定时来访问服务端，更新自己的当前状态，如果客户端超过指定的时间没有来更新状态，则认为客户端已经宕机。<br>心跳比起轮询有两个优势：1.避免服务端的压力2.灵活好控制</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/07/03/2025-07-03/" data-id="cmcvdrdww000bccz8b1yjhmn1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity/" rel="tag">unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2025-07-02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/02/2025-07-02/" class="article-date">
  <time datetime="2025-07-02T00:27:04.000Z" itemprop="datePublished">2025-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/02/2025-07-02/">游戏前端架构师养成之路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言<br>架构师，一个非常牛逼的称呼。待遇好、工资高，属于公司大牛级别。 希望这篇文章，能成为您成为牛逼架构师的垫脚石。</p>
<p>国内前端项目开发的框架，一般由 前端主程 负责搭建维护，少部分是有专门的架构师岗位。</p>
<p>框架来源，一般是自己搭建 或者使用比较优秀的开源框架。</p>
<p>游戏框架必要性<br>设计框架是为了提高开发效率、降低维护成本、提高代码可复用性和可扩展性，以及促进团队协作。设计好的框架能够提高项目的开发质量和效率，使得项目能够更好地满足用户需求和市场需求。</p>
<p>（下面列举的，可以简单扫一眼）</p>
<p>架构的好处：</p>
<p>提高开发效率：框架提供了一种标准化的开发方式和一系列工具和组件，能够快速搭建项目基础结构，减少重复劳动，提高开发效率。<br>降低维护成本：框架能够规范化项目代码结构和开发流程，使得代码易于阅读和维护，降低项目的维护成本。<br>提高代码可复用性：框架提供了一系列的组件和工具，能够把开发中常用的功能封装成可复用的组件，提高代码的可复用性。<br>提高代码的可扩展性：框架能够规范化代码结构和开发流程，使得代码易于扩展和修改，降低项目的开发风险。<br>促进团队协作：框架可以统一团队开发标准和流程，使得团队成员之间代码交流和沟通更加顺畅，提高团队协作效率。<br>前端游戏架构师<br>前端游戏架构师是负责设计和搭建前端游戏架构的专业人员。他们负责设计和实现游戏前端系统的架构，制定技术方案和技术规范，并领导和指导开发团队完成游戏的前端开发工作。</p>
<p>前端游戏架构师是一位具备丰富的前端开发经验和游戏开发经验，能够负责游戏前端系统的设计和实现，制定技术规范和管理开发团队的专业人员。</p>
<p>（下面列举的，可以简单扫一眼）</p>
<p>前端游戏架构师需要具备以下技能和能力：</p>
<p>熟练掌握游戏开发的相关技术，如Unity引擎、Cocos2d-x、HTML5等。<br>具备丰富的前端开发经验，熟悉前端技术的发展趋势和最佳实践。<br>熟悉游戏开发的工作流程，具备较强的项目管理能力和团队协作能力。<br>能够对游戏前端开发的技术选型、系统架构和性能优化等方面进行深入思考和决策。<br>具备较强的解决问题的能力，能够快速定位和解决游戏前端开发中遇到的各种问题。<br>前端框架设计<br>我们设计框架的时候，需要UI管理模块：这个模块负责管理游戏中所有UI元素的创建、显示、隐藏和销毁等操作。在设计时，需要考虑如何实现UI元素的层级管理、布局管理、动画效果和交互处理等功能。</p>
<p>下面介绍一般框架里面需要包含的模块：</p>
<p>UI管理：这个模块负责所有UI元素的管理和呈现，例如创建、显示、隐藏、销毁UI元素，以及切换不同UI画面之间的逻辑。在设计时需要考虑到UI元素的复杂度和嵌套层次，以及UI画面的切换和缓存机制。<br>数据绑定：这个模块允许UI元素和游戏数据之间的双向绑定，以确保UI元素的显示和游戏数据的同步更新。这个模块需要设计一个可靠的数据绑定机制，以便在游戏运行时及时地更新UI显示。同时需要考虑到数据绑定的性能和可扩展性。<br>事件处理：这个模块负责处理各种用户交互事件，例如点击、拖拽、滑动等等。它需要设计一个事件派发系统，以确保事件能够被正确地传递给目标UI元素。同时需要考虑到事件的优先级、多点触控和手势识别等问题。<br>资源管理：这个模块需要设计一个可靠的资源管理系统，以确保游戏所需的资源能够及时地加载和释放。这个模块需要考虑到游戏资源的优先级、加载顺序和内存占用等问题。同时需要支持资源的异步加载和缓存机制。<br>效果展示：这个模块负责各种视觉和声音效果的展示，例如场景过渡动画、音效和音乐等等。它需要设计一个可扩展的效果展示系统，以便开发人员能够轻松地添加和修改游戏效果。同时需要支持效果的异步加载和缓存机制。<br>网络通信：这个模块负责游戏客户端和服务器之间的通信。它需要设计一个可靠的网络协议和消息处理机制，以便实现游戏的多人联机和服务器通知等功能。同时需要考虑到网络延迟和带宽限制等问题。<br>游戏逻辑：这个模块负责游戏的核心逻辑实现。它需要设计一个可扩展的游戏逻辑框架，以便开发人员能够快速地添加和修改游戏逻辑。同时需要考虑到游戏的性能和稳定性。<br>工具扩展：这个模块提供了一系列实用工具，例如UI编辑器、图形工具、资源打包工具等等。在设计时，需要考虑如何实现工具集的模块化和可扩展性、工具集和游戏引擎的集成、工具集的功能和性能优化等功能。<br>结语<br>我们了解了架构师需要掌握的技能，以及常用的框架的组成。在以后的工作和学习中，多学习借鉴优秀的框架，提炼出一套属于自己的框架。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/07/02/2025-07-02/" data-id="cmcvdrdwy000fccz8harxgrsq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2025-07-01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/07/01/2025-07-01/" class="article-date">
  <time datetime="2025-07-01T00:27:04.000Z" itemprop="datePublished">2025-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/07/01/2025-07-01/">搭建一个简单的休闲游戏框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>乘这段时间有空，整理整理自己之前写的工作内容，想着搭一个游戏框架，从开始创建工程到能打Android 包，一整个流程的工具和模块，整理成文档，方便日后工作上能用上。<br><img src="img/game_framework.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/07/01/2025-07-01/" data-id="cmcvdrdwx000dccz890teaoxq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/game/" rel="tag">game</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/gameframework/" rel="tag">gameframework</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/unity/" rel="tag">unity</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2025-06-30" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/30/2025-06-30/" class="article-date">
  <time datetime="2025-06-30T00:27:04.000Z" itemprop="datePublished">2025-06-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/30/2025-06-30/">游戏性能优化总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>性能优化是游戏开发中非常重要的一环，它直接影响到游戏的流畅度和用户体验。我们的游戏基本都是UI为主</p>
<p>UI的一些建议</p>
<p>显示和隐藏我们可以使用移除到Canvas外，而不是利用SetActive(false)</p>
<p>UI的批处理<br>将更新频率不一样的UI放在不同的canvas上<br>相同canvas中的UI元素的Z值相同，这样才不会打断合批<br>相同的canvasUI元素使用相同的材质和纹理，有动态变化不影响合批<br>相同的canvas中的UI元素要使用相同的裁剪矩阵。<br>Graphic Paycaster<br>Text 、spine， image 禁用 caster target</p>
<p>全屏UI的处理<br>3d场景完全被遮挡，关闭3d场景<br>被遮挡的UI， disable canvas，不是setActive（false)<br>尽可能降低帧率，UI不需要刷新那么频繁。</p>
<p>其他的一些优化</p>
<p>Gameobject 层级结构<br>某些情况下，场景中的物体坑有很深的嵌套结构，<br>对父节点的Gameobject 移动，会产生OnTransformCHanged 会传递给子对象，所有子对象<br>即使没有渲染组件的，会造成一些不必要的转换运算。<br>较深的结构也会导致GC更耗时，</p>
<p>避免在awake 和 start 中添加大量的逻辑，游戏启动黑屏太久。因为游戏是在、Start 方法后执行渲染第一个画面</p>
<p>删除空的unity 事件，Awake() Start() Update<br>即使是空的也会带来微性能消耗</p>
<p>accelerometer Frequency<br>Project setting - player -ios - other settings ，不需要加速仪的游戏中，关闭，或者设置低频。会增加cpu负担。</p>
<p>移动物体，<br>如果对象需要碰撞检测，不用tranform。Translate， 用rigidBody.MovePosition, addForce 并且是在fixedupdate 方法中执行。</p>
<p>添加组件<br>在运行时调用AddComponet其实很没有效率，尤其是一帧中多次启用这类调用<br>当我们添加一个组件的时候，<br>影响性能，增加GC的处理时间</p>
<p>数据结构，array，list 和dictionary<br>array list使用索引成本低，适合要经常通过索引读取的情况，而频繁增加和移除对象，使用dictionary</p>
<p>audio的优化</p>
<p>project settings<br>DSF buffer：FMOD声音引擎有个buff，就是DSF buffer，当buff满了才会去向CPU发送一次播放声音的指令。Default、Best Latency，Good latency， Best performance</p>
<p>audio source<br>Force To Mono：强制单声道<br>Compression：Android： Vorbis 、IOS：ADPCM、MP3<br>LoadType：Decompress OnLoad 必须&lt;200k Complress In memory 中型音频文件，streaming，大型，背景音<br>Bitrate 减低文件的比特率，前提是不会破坏太严重。</p>
<p>静音处理：disable audiosource组件，建议在内存中卸载音频相关的来源</p>
<p>Code size；代码也占内存，模版泛型的滥用。</p>
<p>assetbundle ，typeTree，不同版本数据结构的兼容，TypeTree build 的版本没有升级，关闭它<br>BuildAssetBundle.option.DisableWriteTypeTree</p>
<p>压缩方式 lz4， chunkBasedCompression。<br>大小和数量 ；官方建议是一个1-2m,现在是5g时间可以适当加大，</p>
<p>禁用Resources</p>
<p>Texture<br>Project setting<br>Async Upload Buffsize 16</p>
<p>Read/Write 关闭，不然会出现两份（内存和显存都在内存）<br>mipmap， ui 元素禁用<br>format ASTC<br>alpha  对完全不透明的纹理 关闭alpha通道</p>
<p>max size 设置成该平台最小值<br>合并，尽量多张纹理合并成大图</p>
<p>mesh 网格<br>read/write 关闭<br>compression  关闭（有些版本卡了，解压后内存占用会很大）<br>Rig 没有动画的比如静态的房子，石头 关闭<br>Blend shapes 没有用的的也禁用<br>met额日阿里 没有用的法向量和切线，也可以关闭。</p>
<p>优化managed memory</p>
<p>游戏对象，显示的调用Destroy 不要用null，销毁不完全。</p>
<p>Class 和 Struct 根据具体使用情况选择class 或struct<br>减少装箱拆箱操作<br>减少LINQ表达式，String。Fromat（）</p>
<p>对象池<br>创建和销毁游戏对象很常见，频繁创建和销毁GC会导致负载很重而波动<br>还会导致堆内存碎片化。对象池大小要合适。</p>
<p>闭包和匿名函数（ 在编译成IL代码中会被new成匿名类。<br>所有函数，变量，以及new出来的东西都要占用内存。</p>
<p>协程<br>协程属于闭包和匿名函数的特例，建议new的时候生存一个协程，不用的时候丢掉</p>
<p>配置表<br>分关卡加载配置。</p>
<p>慎用单例，不要什么都往里放，变量会一直占用内存。</p>
<p>scriptable object ，只会消耗一组数据内存。</p>
<p>变量Or 属性<br>属性本质上是函数的调用，会在堆栈上被分配内存，调用属性也是如此，当然一般来说问题不大，<br>可以用宏命令，开发时使用属性，发布时使用变量。</p>
<p>缓存hash值<br>int h = Animator.StringToHash(“idle”)<br>animation:SetTrigger(h)</p>
<p>int s = Shader.PropertyToID(“color”)<br>material.SetColor(s,Color.white)</p>
<p>缓存引用对象<br>不要多次查询相同的对象或组件，查询一次后将其缓存起来，<br>方便后续使用。</p>
<p>图像（Graphics） 的一些优化建议<br>使用批处理来尽量减少draw call。<br>静态批处理满足：要合批的对象必须引用一样的材质，并使用相同的纹理（纹理合并在这里就体现出来了），使用的模型可以不一样。</p>
<p>动态批处理： 减少移动对象的drawcall，只能用于少用900个顶点的信息。包含坐标，法线，uv0,uv1,q切线，每帧评估一次，cpu处理</p>
<p>castShadows<br>meshRender 组件的Cast Shadow 开启阴影渲染，增加真实度和深度感，增加多余的阴影计算，最后看不见。如果对阴影没影响，可以关闭。</p>
<p>light Culling mask 分层，确保只影响特定层（ 专门给角色打光的光源，设置成只影响角色）。尤其是多光源，多对象。</p>
<p>避免使用手机原生分辨率<br>现代手机分辨率很高，在手机上程序影响性能和手机过热<br>使用Screen。SetResolution来降低游戏预设的解析设置，来提高性能。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/06/30/2025-06-30/" data-id="cmcvdrdwu0009ccz81slu1n4u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2025-06-29" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/29/2025-06-29/" class="article-date">
  <time datetime="2025-06-29T00:27:04.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/29/2025-06-29/">xlua-framework框架简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由于slot项目是一个需要快速迭代，经常修改和发布的游戏，因此我们决定用lua来写业务逻辑，选择了使用这个xlua-framework，在此基础上架构开发。</p>
<p>xlua-framework框架，是一个纯lua的框架，基于XLua，整合ToLua的Proto-gen-lua，以及大部分ToLua作者整合的库，除了Assetbundle模块，大部分游戏逻辑全部用lua实现，目前实现的内容包括：</p>
<p>UI管理模块：使用UGUI，基于MVC架构，View层实现一套组件管理系统，提供类似于Unity侧Mono脚本的调度机制。<br>场景管理模块：场景调度、Loading界面、资源预加载<br>网络模块：Protobuff、TCP连接器<br>资源管理模块：打包工具、资源热更、资源加载、资源缓存<br>定时器管理<br>协程管理<br>配置表管理<br>工程目录<br>AssetBundles：AB打包输出目录</p>
<p>ConfigData：配置表目录</p>
<p>ProtoToCS：Proto文件目录</p>
<p>ProtoToLua：proto-gen-lua工作目录</p>
<p>Qudao：渠道目录</p>
<p>Tools：XLua工具目录</p>
<p>Xlua-lib-build：xlua库构建工程（另设Git项目：<a href="https://github.com/smilehao/xlua-lib-build。）" target="_blank" rel="noopener">https://github.com/smilehao/xlua-lib-build。）</a></p>
<p>Assets目录说明<br>AssetsPackage：取代Resources目录，存放项目资源</p>
<p>EasyTouchBundle：EasyTouch插件</p>
<p>Editor：编辑器脚本</p>
<p>LuaScripts：Lua脚本</p>
<p>Plugins：插件</p>
<p>Reporter：真机日志输出插件</p>
<p>Scenes：场景</p>
<p>Scripts：CS脚本</p>
<p>StreamingAssets：AB打包资源</p>
<p>Lua脚本目录说明<br>Common：通用工具脚本，其中Tools目录下的脚本由ToLua迁移过来，其它脚本为自定义的扩展和工具类脚本</p>
<p>Config：配置文件目录，其中Data目录为Lua配置自动生成工具的输出目录</p>
<p>Framework：框架基础脚本，这部分代码具有一定通用性，与游戏逻辑无关。</p>
<p>GameModule：游戏逻辑脚本</p>
<p>GameTheme：游戏机台主题脚本</p>
<p>Global：全局配置脚本</p>
<p>Net：网络逻辑相关脚本</p>
<p>Resource：资源逻辑相关脚本</p>
<p>Scenes：场景逻辑相关脚本</p>
<p>UI：UI逻辑相关脚本</p>
<p>UITest：单元测试</p>
<p>XLua：XLua热修复脚本，其中HotfixMain.lua为lua热修复逻辑入口。</p>
<p>GameMain：游戏逻辑入口</p>
<p>Scripts目录说明<br>XLua：其中Gen为生成脚本、Support为自定义支持脚本</p>
<p>FrameWork：框架基础脚本</p>
<p>其它：Common通用模块、Config配置、GameLaunch游戏入口及资源热更、Platform渠道相关、Test测试和调试相关</p>
<p>游戏启动流程<br>启动场景：LauchScene场景，场景启动后GameLaunch.cs脚本启动</p>
<p>启动资源管理模块AssetBundleManager</p>
<p>启动资源热更新模块AssetBundleUpdater</p>
<p>资源热更新：如果需要更新，则更新完毕后重启资源管理器和Lua虚拟机（热修复模块）</p>
<p>启动游戏：进入Lua脚本执行后续游戏逻辑</p>
<p>Lua端启动流程<br>GameMain.lua：lua的入口类，启动lua端的框架，如ConfigManager，DataManager，SceneManager，UIManager，UpdaterManager，等等<br>加载场景：比如：LoginScene，打开UI页面比如：UILoginUI，接下来就可编写自己的逻辑和页面跳转了。<br>详细可参考框架demo:</p>
<p>xlua-framework：<a href="https://github.com/smilehao/xlua-framework" target="_blank" rel="noopener">https://github.com/smilehao/xlua-framework</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/06/29/2025-06-29/" data-id="cmcvdrdws0005ccz89o0747p9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/xlua-lua-framework/" rel="tag">xlua, lua, framework</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2025-06-28" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/28/2025-06-28/" class="article-date">
  <time datetime="2025-06-28T00:27:04.495Z" itemprop="datePublished">2025-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/28/2025-06-28/">2025-06-28</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 游戏设计模式学习<br>date: 2025-06-28 08:27:04<br>tags: </p>
<hr>
<p>架构,性能和游戏 (已看)<br>再探设计模式<br>命令模式 (已看)<br>享元模式 (已看)<br>观察者模式 (已看)<br>原型模式 (已看)<br>单例模式 (已看)<br>状态模式 (已看)<br>序列型模式<br>双缓冲 (已看)<br>游戏循环 (已看)<br>更新方法 (已看)<br>行为型模式<br>字节码 (已看)<br>子类沙盒 (已看)<br>类型对象 (已看)<br>解耦型模式<br>组件模式 (已看)<br>事件队列 (已看)<br>服务定位器 (已看)<br>优化型模式<br>数据局部性<br>脏标记模式<br>对象池 (已看)<br>空间分区<br>第1章 架构,性能和游戏<br>架构就是关于代码的组织方式<br>架构意味着变化.衡量一个设计好坏的方法就是看它应对变化的灵活性<br>一旦你理解了问题和它涉及的代码,则实际的编码有时是微不足道的<br>你可以用一堆方式来定义”解耦”,但我认为如果两块代码耦合,意味着你必须同时了解这两块代码.如果你让它们解耦,那么你只需了解其一.<br>当然,对解耦的另一个定义就是当改变了一块代码时不必更改另外一块代码.很明显,我们需要更改一些东西,但是耦合得越低,更改所波及得范围就越小<br>良好的架构需要很大的努力及一系列准则.每当你做出一个改变或者实现一个功能时,你必须很优雅地将它们融入到程序的其余部分.<br>你必须非常谨慎地组织代码并保证其在开发周期中经过数以千计的小变化之后仍然具有良好的组织性<br>没有人可以在纸上设计出一个平衡的游戏.这需要迭代和实验.<br>原型(把那些仅仅在功能上满足一个设计问题的代码融合在一起)是一个完全正确的编程实践<br>开发中我们有几个因素需要考虑</p>
<ol>
<li>我们想获得一个良好的架构,这样在项目的生命周期中便会更容易理解代码</li>
<li>我们希望获得快速的运行时性能</li>
<li>我们希望快速完成今天的功能<br>这些目标至少部分是相冲突的.好的架构从长远来看,改进了生产力,但维护一个良好的架构就意味着每一个变化都需要更多的努力来保持代码的干净<br>最快编写的代码实现却很少是运行最快的.相反,优化需要消耗工程时间.一旦完成,也会使代码库僵化:高度优化过的代码缺乏灵活性,很难改变<br>完成今日的工作并担心明天的一切总伴随着压力.但是,如果我们尽可能快的完成功能,我们的代码库就会充满了补丁,bug和不一致的混乱,会一点点地消磨掉我们未来的生产力<br>这里没有简单的答案,只有权衡<br>抽象和解耦能够使得你的程序开发变得更快和更简单.但不要浪费时间来做这件事,除非你确信存在问题的代码需要这种灵活性<br>在你的开发周期中要对性能进行思考和设计,但是要推迟那些降低灵活性的,底层的,详尽的优化,能晚则晚<br>尽快地探索你的游戏的设计空间,但是不要走得太快留下一个烂摊子给自己.毕竟你将不得不面对它<br>如果你将要删除代码,那么不要浪费时间将它整理得很整洁.摇滚明星把酒店房间弄得很乱是因为他们知道第二天就要结账走人.<br>但是,最重要得是,若要做一些有趣得玩意,那就乐在其中地做吧<br>第2章 命令模式<br>将一个请求封装成一个对象,从而允许你使用不同的请求,队列或日志将客户端参数化,同时支持请求操作的撤销和恢复<br>命令就是一个对象化(实例化)的方法调用<br>这个术语意味着,将某个概念转化为一块数据,一个对象,或者你可以认为是传入函数的变量等.<br>命令就是面向对象化的回调<br>一些语言的反射系统可以让你在运行时命令式地处理系统中的类型.你可以获取到一个对象,它代表着某些其他对象的类,你可以通过它试试看这个类型能做些什么.话句话说,反射是一个对象化的类型系统</li>
<li>你可能最终会有很多不同的命令类.为了更容易地实现这些类,可以定义一个具体的基类,里面有着一些实用的高层次的方法,这样便可以通过对派生出来的命令组合来定义其行为,这么做通常是有帮助的.它会将命令的主要方法变成子类沙盒</li>
<li>在我们的例子中,我们明确地选择了那些会执行命令的角色.在某些情况下,尤其是在对象模型分层的情况下,它可能没有这么直观.一个对象可以响应一个命令,而它也可以决定将命令下放给其从属对象.如果你这样做,你需要了解下责任链</li>
<li>一些命令如第一个例子中的JumpCommand是无状态的纯行为的代码块.在类似这样的情况下,拥有不止一个这样命令类的实例会浪费内存,因为所有的实例是等价的.享元模式就是解决这个问题的.<br>第3章 享元模式<br>使用共享以高效地支持大量的细粒度对象<br>享元,一般来说当你有太多对象并考虑对其进行轻量化时它便能派上用场<br>享元模式通过将对象数据切分成两种类型来解决问题.<br>第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据.称为内部状态,但我更喜欢将它认为是”上下文无关”的状态.在本例中,这指的便是数木的几何形状和纹理数据等.<br>其他数据便是外部状态, 对于每一个实例它们都是唯一的<br>你并不会在一开始便创建所有的享元.如果你不能预测哪些是你真正需要的,则最好按需创建它们.为了获得共享优势,当你需要一个对象时,你要先看看你是否已经创建了一个相同的对象.如果是,则只需返回这个实例.这通常意味着在一些用来查找现有对象的接口背后,你必须做些结构上的封装.像这样隐藏构造函数,其中一个例子就是工厂方法模式<br>为了找到以前创建的享元,你必须追踪哪些你已经实例化过的对象的池,对象池模式对于存储它们会很有用<br>在使用状态模式时,你经常会拥有一些”状态”对象,对于状态所处的状态机而言它们没有特定的字段.状态的标识和方法也足够有用.在这种情况下,你可以同时在多个状态机中始使用这种模式,并且重用这个相同的状态实例并不会带来任何问题<br>第4章 观察者模式<br>在对象间定义一种一对多的依赖关系,以便当某对象的状态改变时,与它存在依赖关系的所有对象都能收到通知并自动进行更新<br>在计算机上随便打开一个应用,它就很有可能就是采用MVC架构开发,而其底层就是观察者模式.观察者模式应用十分广泛,Java甚至直接把它集成到了系统库里面(java.util.Observer),C#更是直接将它集成在了语言层面(event关键字)<br>通知方法会被正在被观察的对象调用.被观察对象，它有两个职责.首先,它拥有观察者的一个列表,这些观察者在随时候命接收各种各样的通知,其次就是发送通知<br>允许外部的代码来控制谁可以接收通知.这个被观察者对象负责和观察者对象进行沟通,但是,它并不与它们耦合<br>同时,被观察者对象拥有一个观察者对象的集合,而不是单个观察者,这也是很重要的.它保证了观察者们并不会隐式地耦合在一起<br>这意味着,两个系统会相互干扰对方—-而且是以一种很不恰当的方式,因为第二个观察者使第一个观察者失效了.观察者集合的存在,可以让每一个观察者都互相不干扰.在它们各自的眼里,都认为被观察者对象眼里只有它自己<br>这就是”观察者”系统和”事件”系统的区别.前者,你观察一个事情,它做了一些你感兴趣的事.后者,你观察一个对象,这个对象代表了已经发生的有趣的事情.<br>发送一个通知,只不过需要遍历一个列表,然后调用一些虚函数.老实讲,它比普通的函数调用会慢一些,但是虚函数带来的开销几乎可以忽略不计,除了对性能要求极其高的程序<br>设计模式会遭人诟病,大部分是由于人们用一个好的设计模式去处理错误的问题,所以事情变得更加糟糕了<br>当一个被观察者对象被删除时,观察者本身应该负责把它自己从被观察者对象中移除.通常情况下,观察者都知道它在观察着哪些被观察者,所以需要做的只是在析构器中添加一个removeObserver()方法<br>当一个被观察者对象被删除时,如果不我们不想让观察者来处理问题,则可以修改以下做法.我们只需要在被观察者对象被删除之前,给所有的观察者发送一个”死亡通知”就可以了.这样,所有已注册的观察者都可以收到通知并进行相应的处理<br>观察者模式非常适合于一些不相关的模块之间的通信问题.它不适合于单个紧凑的模块内部的通信.<br>这也是为什么它适合我们的例子: 成就系统和物理系统是完全不相关的领域,而且很有可能是由不同的人实现的.我们想让它们的通信尽可能地减少,这样任何一个模块都不用依赖另一个模块就可以工作<br>第5章 原型模式<br>使用特定原型实例来创建特定种类的对象,并且通过拷贝原型来创建新的对象.<br>第6章 单例模式<br>确保一个类只有一个实例,并为其提供一个全局访问入口<br>后悔使用单例的原因，它是一个全局变量<br>我们学到的一个教训就是,全局变量是有害的<br>我见过的游戏中的许多单例类都是”managers” —-这些保姆类只是为了管理其他对象.有时为了区别,它们叫做”System”或”Engine”,不过只是改了名字而已<br>尽管保姆类有时是有用的,不过这通常反映出它们对OOP不熟悉.比如下面这两个虚构的类<br>就这样.没有管理器也没有问题.设计糟糕的单例通常会”帮助”你往其他类中添加功能.如果可以,你只需要将这些功能移动到它所帮助的类中去就可以了.毕竟,面向对象就是让对象自己管理自己<br>通用的原则是,在保证功能的情况下将变量限制在一个狭窄的范围内.对象的作用越小,我们需要记住它的地方就越少.在我们盲目地采用具有全局作用域的单例对象之前,让我们考虑下代码库访问一个对象的其他途径<br>　　传递进去: 最简的解决方式,通常也是最好的方式,就是将这个对象当作一个参数传递给需要它的函数<br>　　在基类中获取它: 许多游戏架构有浅层次但是有宽度的继承体系,通常只有一层继承 面向切面编程<br>　　通过其他全局对象访问它: 我们可以通过将全局对象类包装到现有类里面来减少它们的数量.<br>　　通过服务定位器来访问: 到现在为止, 我们假设全局类就是像Game那样的具体类.另外一个选择就是定义一个类专门用来给对象做全局访问. 这个模式被称为服务定位器模式<br>还有一个问题,我们应该在什么情况下使用真正的单例呢?<br>为了确保只实例化一次,我通常只是简单地使用一个静态类.如果那不起作用,我就会用一个静态的标识位在运行时检查是否只有一个类实例被创建<br>第7章 状态模式<br>允许一个对象在其内部状态改变时改变自身的行为.对象看起来好像是在修改自身类.<br>有限状态机(FSM)可以看作最简单的图灵机<br>整个状态机可以分为: 状态,输入和转换<br>　　你拥有一组状态,并且可以在这组状态之间进行切换<br>　　状态机同一时刻智能处于一种状态<br>　　状态机会接收一组输入或者事件<br>　　每一个状态有一组转换,每一个转换都关联着一个输入并指向另外一个状态<br>层次状态机:一个状态有一个父状态.当有一个事件进来的时候,如果子状态不处理它,那么沿着继承链传给它的父状态来处理.换句话说,它有点像覆盖继承的方法<br>　　你可以把新的状态放入栈里面.当前的状态永远存在栈顶,所以你总能转换到当前状态.但是当前状态会将前一个状态压在栈中自身的下面而不是抛弃掉它<br>　　你可以弹出栈顶的状态,改状态将被抛弃.与此同时,上一个状态就变成了新的栈顶状态了<br>即使有了这些通用的状态机扩展,它们的使用范围仍然是有限的.在游戏的AI领域,最近的趋势是越来越倾向于行为树和规划系统.<br>但是这并不意味着有限状态机,下推自动机和其他简单的状态机没有用.它们对于解决某些特定的问题是一个很好的建模工具.当你的问题满足以下几点要求的时候,有限状态机将会非常有用<br>　　你有一个游戏实体,它的行为基于它的内部状态而改变<br>　　这些状态被严格划分为相对数目较少的小集合<br>　　游戏实体随着时间的变化会响应用户输入和一些游戏事件<br>第8章 双缓冲<br>诸如计算机显示器的显示设备在每一时刻仅绘制一个像素.显示设备从左至右地扫描屏幕屏幕每行中的像素,并如此从上至下地扫描屏幕上的每一行.当它扫描至屏幕的右下角时,它将重定位至屏幕的左上角并如前述那样地重复扫描屏幕.这一扫描过程是如此地快速(大概每秒60次),以至于我们的眼睛无法察觉这一过程.对于我们而言,扫描的结果就是屏幕一块彩色像素组成的静态区域,即一张图片<br>我们的程序一次只渲染一个像素,同时我们要求显示器一次性显示所有的像素—-可能这一帧看不到任何东西,但下一帧显示的就是完整的笑脸.双缓冲模式解决了这一问题<br>双缓冲中的一个缓存用于展示当前帧,于此同时,渲染代码正在另一个缓冲区中写入数据.当渲染代码完成时,通过交换缓冲区,使得显卡驱动开始从第一个缓冲区转向第二个缓冲区以读取其数据进行渲染.只要它掌握好时机在每次刷新显示器结束时进行切换,我们就不会看到任何衔接的裂隙,且整个场景能一次性的瞬间显示出来<br>定义一个缓冲区类来封装一个缓冲区:一块能被修改的状态区域.这块缓冲区能被逐步地修改,但我们希望任何外部的代码将对该缓冲区的修改都视为原子操作.为实现这一点,此类中维护两个缓冲区实例:后台缓冲区和当前缓冲区<br>当要从缓冲区读取信息时,总是从当前缓冲区读取.当要往缓冲区中写入数据时,则总在后台缓冲区上进行.当改动完成后,则执行”交换”操作来将当前缓冲区与后台缓冲区进行瞬时的交换,以便让新的缓冲区为我们所见,同时刚被换下来的当前缓冲区则成为现在的后台缓冲区以供复用<br>当下面这些条件都成立时,使用双缓冲模式:<br>　　我们需要维护一些被逐步改变着的状态量<br>　　同个状态可能会在其被修改的同时被访问到<br>　　我们希望避免访问状态的代码能看到具体的工作过程<br>　　我们希望能够读取状态但不希望等待写入操作的完成<br>双缓冲模式需要在状态写入完成后进行一次交换操作,操作必须是原子性的:也就是说任何代码都无法在这个交换期间对缓冲区内的任何状态进行访问.通常这个交换过程和分配一个指针的速度差不多,但如果交换用去了比修改初始状态更多的时间,那这样模式就毫无助益了<br>我们必须有两份缓冲区，这个模式的另外一个后果就是增加了内存使用.<br>并非只针对图形<br>双缓冲模式所解决的核心问题就是对状态同时进行修改与访问的冲突.造成此问题的原因通常有两个,我们已经通过上述图形示例描述了第一种情况—-状态直接被另一个线程或中断的代码所直接访问<br>而另一种情况同样很常见:进行状态修改的代码访问到了其正在修改的那个状态.这会在很多地方发生:尤其是实体的AI和物理部分,在它与其他实体进行交互时会发生这样的情况,双缓冲模式往往能在此情形下奏效<br>缓冲区如何交换<br>交换缓冲区指针或者引用<br>在两个缓冲区之间进行数据的拷贝<br>第9章 游戏循环<br>实现用户输入和处理器速度在游戏行进时间上的解耦<br>假如有哪个模式是本书最无法删减的,那么非游戏循环模式莫属.游戏循环模式是游戏编程模式种的精髓.几乎所有的游戏都包含着它,无一雷同,相比而言那些非游戏程序中却难见它的身影<br>不同于其他大多数软件,游戏即便在用户不提供任何输入时也一直在运行.加入你坐下来盯着屏幕,游戏也不会卡住.动画依旧在播放,各种效果也在闪动跳跃<br>这是真实的游戏循环的第一个关键点:它处理用户输入,但并不等待输入.游戏循环始终在运转:<br>假如用现实时间来衡量游戏循环的速度,我们就得到了游戏的帧率.<br>两个因素决定了帧率.<br>　　第一个是循环每一帧要处理的信息量.复杂的物理运算,一堆对象的数据更新,许多图形细节等都将让你的CPU和GPU忙个不停,这都会让一帧消耗更多的时间<br>　　第二个是底层平台的速度.速度越快的芯片相同时间内能够处理更多的代码.多核,多GPU,专用声卡以及操作系统的调度器都会影响着你的一帧中所能处理的代码量<br>游戏循环模式的另一个要点:这一模式让游戏在一个与硬件无关的速度常量下运行.<br>一个游戏循环会在游戏过程中持续地运转.每循环一次,它非阻塞地处理用户输入,更新游戏状态,并渲染游戏.它跟踪流逝的时间并控制游戏的速率<br>它的问题在于你无法控制游戏运转的快慢.在较快的机器上游戏循环可能会快得令玩家看不清楚游戏在做什么,在慢的机器上游戏则会变慢变卡<br>你希望游戏运行在60帧,假如你确定每16ms甚至更短的时间就能处理所有的信息<br>对于超过16ms时间的处理时间,则无能为力<br>使用平台的事件循环<br>使用游戏引擎的游戏循环<br>自己编写游戏循环<br>你如何解决能量耗损<br>限制帧率<br>如何控制游戏速度<br>非同步的固定时间步长<br>同步的固定时长<br>变时时长<br>定时更新迭代,变时渲染<br>第10章 更新方法<br>通过对所有对象实例同时进行帧更新来模拟一系列相互独立的游戏对象<br>你会发现这代码的可维护性不高.我们维护着一堆其值不断增长的变量,并不可避免地将所有代码都塞进游戏循环里,每段代码处理一个游戏中特殊的实体.为达到让所有实体同时运行的目的,我们把它们杂糅在一起了.<br>你可能猜到我们所要运用的设计模式该干些什么了? 它要为游戏中的每个实体封装其自身的行为.这将使得游戏循环保持整洁并便于往循环中增加或移除实体<br>为了做到这一点,我们需要一个抽象层,为此定义一个update()的抽象方法.游戏循环维护对象集合,但它并不关心这些对象的具体类型.它只是更新它们.这将每个对象的行为从游戏循环以及其他对象那里分离了出来<br>每一帧,游戏循环遍历游戏对象集合并调用它们的update().这在每帧都给与每个对象一次更新自己行为的机会.通过逐帧调用update方法,使得这些对象的表现得到同步<br>游戏循环维护一个动态对象集合,这使得向关卡里添加或者移除对象十分便捷—-只要往集合里增加或移除就好<br>游戏世界维护一个对象集合.每个对象实现一个更新方法以在每帧模拟自己的行为.而游戏循环在每帧对集合中所有的对象调用其更新方法,以实现和游戏世界同步更新<br>假如把游戏循环比作有史以来最好的东西,那么更新方法模式就会让它锦上添花.<br>更新方法模式在如下情境最为适用:<br>　　你的游戏中含有一系列对象或系统需要同步地运转<br>　　各个对象之间的行为几乎是相互独立的<br>　　对象的行为与时间相关<br>1 将代码划分至单帧之中使其变得更加复杂<br>2 你需要在每帧结束前存储游戏状态以便下一帧继续<br>3 所有对象都在每帧进行模拟,但并非真正同步<br>在本设计模式中,游戏循环在每帧遍历对象集并逐个更新对象.在update()的调用中,多数对象能够访问到游戏世界的其他部分,包括那些正在更新的其他对象.这意味着,游戏循环遍历更新对象的顺序意义重大<br>在更新期间修改对象列表时必须谨慎<br>不要在本帧处理新添加的对象<br>不要在迭代时移除对象<br>一种方法是小心地移除对象并在更新任何计数器时把被移除的对象也算在内.还有一个办法是将移除操作推迟到本次循环遍历结束之后.将要被移除的对象标记为”死亡”,但并不从列表中移除它.在更新期间,确保跳过那些被标记死亡的对象接着等到遍历更新结束,再次遍历列表来移除这些”尸体”<br>你显然必须决定好该把update()方法放在哪一个类中<br>　　实体类中　　假如你已经创建了实体类,那么这是最简单的选项.因为这不会往游戏中增加额外的类.假如你不需要很多种类的实体,那么这种方法可行,但实际项目中很少这么做<br>　　组件类中　　更新方法模式与组件模式享有相同的功能—-让实体/组件独立更新,它们都使得每个实体/组件在游戏世界中能够独立于其他实体/组件.渲染,物理,AI都仅需专注于自己<br>　　代理类中　　将一个类的行为代理给另一个类,设计了其他几种设计模式.状态模式可以让你通过改变一个对象的代理来改变其行为.对象类型模式可以让你在多个相同类型的实体之间共享行为<br>那些未被利用的对象该如何处理<br>你常需要在游戏中维护这样一些对象:不论处于何种原因,它们暂时无需被更新.一种方法是单独维护一个需要被更新的”存活”对象表.<br>这一模式与游戏循环和组件模式共同构成了多数游戏引擎的核心部分<br>当你开始考虑实体集合或循环中组件在更新时的缓存功能,并希望它们更快地运转时,数据局部性模式将会有所帮助<br>Unity 的引擎框架在许多类模块中使用了本模式,比如Monobehaviour类<br>第11章 字节码<br>通过将行为编码成虚拟机指令,而使其具备数据的灵活性<br>指令集定义了一套可以执行的底层操作.一系列指令被编码为字节序列.虚拟机逐条执行指令栈上这些指令.通过组合指令,既可完成很多高级行为<br>这是本书中最复杂的模式,它可不是轻易就能放进你的游戏里的,仅当你的游戏中需要定义大量行为,而且实现游戏的语言出现下列情况才应该使用:<br>　　编程语言太底层了,编写起来繁琐易错<br>　　因编译时间太长或工具问题,导致迭代缓慢<br>　　它的安全性太依赖编码者.你想确保定义的行为不会让程序崩溃,就得把它们从代码库转移至安全沙箱中<br>当然,这个列表复合大多数游戏的情况.谁不想提高迭代速度,让程序更安全?但那是有代价的,字节码比本地码要慢,所以它并不适合用作对性能要求极高的核心部分<br>字节码虚拟机有两种大风格: 基于栈和基于寄存器.在基于栈的虚拟机中,指令总是操作栈顶<br>基于寄存器的虚拟机也有一个堆栈.唯一的区别是指令可以从栈的更深层次中读取输入.它在字节码中存储两个索引来表示应该从堆栈的哪个位置读取操作数<br>如果你想定义一种基于文本的语言<br>　　你得定义一种语法，外部基本操作，内部基本操作，控制流，抽象化<br>　　你要实现一个分析器<br>　　你必须处理语法错误<br>　　对非技术人员没有亲和力<br>如果你设计了一个图形化编辑器<br>　　你要实现一个用户界面，这样不易出错，但可移植性差<br>这个模式是Gof解释器模式的姊妹版.它们都会为你提供一种用数据组合行为的方法.事实上,你经常会将两个模式一起使用.你用来生成字节码的工具通常会有一个内部对象树来表达代码.这正是解释器模式能做的事情.为了将它编译成字节码,你需要递归遍历整棵树,正如你在解释器模式中解析它那样.唯一的不同是你并不是直接执行一段代码而是将它们输出成字节码指令并在以后执行它们<br>Lua编程语言是游戏中广泛使用的编程语言.它内部实现了一个紧凑的基于寄存器的字节码虚拟机<br>第12章 子类沙盒<br>使用基类提供的操作集合来定义子类中的行为<br>一个基类定义了一个抽象的沙盒模式方法和一些预定义的操作集合.通过将它们设置为受保护的状态以确保它们仅供子类使用.每个派生出的沙盒子类根据父类提供的操作来实现沙盒函数<br>沙盒模式适用于以下情况<br>　　你有一个带有大量子类的函数<br>　　基类能够提供所有子类可能需要执行的操作集合<br>　　在子类之间有重叠的代码,你希望在它们之间更简便地共享代码<br>　　你希望使这些继承类与程序其他代码之间的耦合最小化<br>经验法则<br>　　如果所提供的操作仅仅被一个或者少数的子类所使用,那么不必将它加入基类.这只会给基类增加复杂度,同时将影响每个子类,而仅有少数子类从中受益.将该操作与其他提供的操作保持一致或许值得,但让这些特殊子类直接调用外部系统或许更为简单和清晰<br>　　当你在游戏的其他模块进行某个方法调用时,如果它不修改任何状态,那么它就不具备侵入性.它仍然产生了耦合,但这是个”安全”的耦合,因为在游戏中它不带来任何破坏.而另一方面,如果这些调用确实改变了状态,则将与代码库产生更大的耦合,你需要对这些耦合更上心.因此此时这些方法更适合由更可视化的基类提供<br>　　如果提供的操作,其实现仅仅是对一些外部系统调用的二次封装,那么它并没有带来多少价值.在这种情况下,直接调用外部系统更为简单.然而,极其简单的转向调用也仍有用—-这些函数通常访问基类不像直接暴露给子类的状态<br>是直接提供函数,还是由包含它们的对象提供<br>把提供的操作分流到一个像这样的辅助类中能给你带来些好处<br>　　减少了基类的函数数量.<br>　　在辅助类中的代码通常更容易维护<br>　　降低了基类和其他系统之间的耦合<br>基类如何获取其所需的状态<br>把它传递给基类构造函数<br>当你采用更新方法模式的时候,你的更新函数通常也是一个沙盒函数<br>模板方法模式正好与本模式相反.在这两个模式中,你都使用一系列操作原语来实现一个函数.使用子类沙盒模式时,函数在继承类中,原语操作则在基类中.使用模板方法时,基类定义函数骨架,而原语操作被继承类实现<br>你可以将这个模式看作是在外观模式上的一个变种.外观模式将许多不同的系统隐藏在了一个简化的API之下.在子类沙盒模式中,基类对于子类来说充当着隐藏游戏引擎实现细节的角色<br>第13章 类型对象<br>通过创建一个类来支持新类型的灵活创建,其每个实例都代表一个不同的对象类型<br>类型对象模式，定义一个类型对象类和一个持有类型对象类.每个类型对象的实例表示一个不同的逻辑类型.每个持有类型对象类的实例引用一个描述其类型的类型对象<br>实例数据被存储在持有类型对象的实例中,而所有同概念类型所共享的数据和行为被存储在类型对象中.引用同一个类型的对象之间能表现出”同类”的性状.这让我们可以在相似对象集合中共享数据和行为,这与类派生的作用有几分相似,但却无需硬编码出一批派生类<br>当你需要定义一系列不同”种类”的东西,但又不想把那些种类硬编码进你的类型系统时,本模式都适用.尤其是当下面任何一项成立的时候:<br>　　你不知道将来会有什么类型<br>　　你需要在不重新编译或修改代码的情况下,修改或添加新的类型，类型对象必须手动跟踪，为每个类型定义行为更困难<br>通过类型对象去定义类型相关的数据非常容易,但是定义数据类型相关的行为却很难.<br>有几种方法可以跨越这个限制.<br>一个简单的方法是创建一个固定的预定义行为集合,让类型对象中的数据从中任选其一<br>另一个更强大,更彻底的解决方案是支持在数据中定义行为.如果我们能读取数据文件并提供给上述任意一种模式来实现,行为定义就完全从代码中脱离出来,而被放进数据文件内容中.<br>类型对象应该封装还是暴露<br>如果类型对象被封装<br>　　类型对象模式的复杂性对代码库的其他部分不可见.它成为了持有类型对象才需关心的实现细节<br>　　持有类型对象的类可以有选择性地重写类型对象的行为<br>如果类型对象被公开<br>　　外部代码在没有持有类型对象类实例的情况下就能访问类型对象<br>　　类型对象现在是对象公共API的一部分<br>持有类型对象如何创建<br>通过这种模式,每个”对象”现在都成了一对对象:主对象以及它所使用的类型对象.那么我们如何创建并将它们绑定起来呢?<br>　　构造对象并传入类型对象<br>　　在类型对象上调用”构造”函数<br>类型能否改变<br>类型不变<br>　　无论编码还是理解起来都更简单<br>　　易于调试<br>类型可变<br>　　减少对象创建<br>　　做约束时要更加小心<br>没有派生<br>　　简单<br>　　可能会导致重复劳动<br>单继承<br>　　仍然相对简单<br>　　属性查找会更慢<br>多重派生<br>　　能避免绝大多数的数据重复<br>　　复杂<br>这个模式所围绕的高级问题是如何在不同对象之间共享数据.从另一个不同角度尝试解决这个问题的是原型模式<br>类型对象与享元模式很接近.它们都让你在实例间共享数据.享元模式倾向于节约内存,并且共享的数据可能不会以实际的”类型”呈现.类型对象模式的重点在于组织性和灵活性<br>这个模式与状态模式也有诸多相似性.它们都把对象的部分定义工作交给另一个代理对象实现.在类型对象中,我们通常代理的对象是:宽泛地描述对象的静态数据.在状态模式中,我们代理的是对象当前的状态,即描述对象当前配置的临时数据.当我们讨论到可改变类型对象的时候,你可以认为是类型对象在状态模式的基础上身兼二职<br>第14章 组件模式<br>允许一个单一的实体跨越多个不同域而不会导致耦合<br>继承有它的用处,但是对某些代码重用来说实现起来太麻烦了.相反,软件设计的趋势应该是尽可能地使用组合而不是继承.为实现两个类之间的代码共享,我们应该让它们拥有同一个类的实例而不是继承同一个类<br>单一实体跨越了多个域.为了能保持域之间相互隔离,每个域的代码都独立地放在自己的组件类中.实体本身则可以简化为这些组件的容器<br>组件最常见于游戏中定义实体的核心类,但是它们也能够用在别的地方.当如下条件成立时,组件模式就能够发挥它的作用<br>　　你有一个涉及多个域的类,但是你希望让这些域保持相互解耦<br>　　一个类越来越庞大,越来越难以开发<br>　　你希望定义许多共享不同能力的对象,但采用继承的办法却无法令你精确地重用代码<br>组件模式相较直接在类中编码的方式为类本身引入了更多的复杂性.每个概念上的”对象”成为一系列必须被同时实例化,初始化,并正确关联的对象的集群.不同组件之间的通信变得更具挑战性,而且对它们所占用内存的管理将更复杂<br>使用组件的另外一个后果是你经常需要通过一系列间接引用来处理问题,考虑容器对象,首先你必须得到你需要的组件,然后你才可以做你需要做的事情,在一些性能要求较高的内部循环代码中,这个组件指针可能会导致低劣的性能<br>关于这个设计模式的最重要的问题是:你需要的组件集合是什么?答案取决于你的游戏需求与风格.引擎越大越复杂,你就越想要将组件切分得更细<br>对象如何获得组件<br>如果这个类创建了自己的组件<br>　　它确保了这个类一定有它所需要的组件<br>　　但是这么做将导致重新配置这个类变得困难<br>如果由外部代码提供组件<br>　　对象将变得灵活.我们完全可以通过添加不同的组件来改变类的行为<br>　　对象可以从具体的组件类型中解耦出来<br>完美地将组件互相解耦并且保证功能隔离是个很好的想法,但这通常是不现实的.这些组件同属于一个对象的事实暗示了它们都是整体的一部分因此需要相互协作—-亦即通信<br>所以组件之间又是如何传递信息的呢?有好几个选择<br>　　通过修改容器对象的状态<br>　　　　它使得组件间保持解耦<br>　　　　它要求组件间任何需要共享的数据都由容器对象进行共享<br>　　　　这使得信息传递变得隐秘,同时对组件执行的顺序产生依赖<br>直接互相引用<br>通过传递信息的方式<br>这是选项中最复杂的一个.我们可以在容器类中建立一个小的消息传递系统,让需要传递信息的组件通过广播的方式去建立组件间的联系.GoF称之为中介模式,两个或者两个以上的对象通过将信息传递到一个中介的方法来取得相互之间的联系.而本章节中,容器类则充当了中间的角色<br>意料之外的是,没有哪个选择是最好的.你最终有可能将上述所说的三种方法都使用到<br>Unity框架的核心GameObject类完全围绕组件来设计<br>第15章 事件队列<br>对消息或事件的发送与受理进行时间上的解耦<br>事件驱动式编程<br>问题1: 在音效引擎完全处理完播放请求前,API的调用一直阻塞着调用者<br>问题2: 不能批量地处理请求<br>问题3: 请求在错误的线程被处理<br>事件队列是一个按照先进先出顺序存储一系列通知或请求的队列.发出通知时系统会将该请求置入队列并随即返回,请求处理器随后从事件队列中获取并处理这些请求.请求可由处理器直接处理或转交给对其感兴趣的模块.这一模式对消息的发送者与受理者进行了解耦,使消息的处理变得动态且非实时<br>如果你只想对一条消息的发送者和接收者进行解耦,那么诸如观察者模式和命令模式都能以更低的复杂度满足你.需要在某个问题上对时间进行解耦时,一个队列往往足矣<br>按照推送和拉取的方式思考:代码A希望另一个代码块B做一些事情.A发起这一请求最自然的方式就是将它推送给B<br>同时,B在其自身的循环中适时地拉取该请求并进行处理也是十分自然的.当你具备推送端和拉取端之后,在两者之间需要一个缓冲.这正是缓冲队列比简单的解耦模式多出来的优势<br>队列提供给拉取请求的代码块一些控制权:接收者可以延迟处理,聚合请求或者完全废弃它们.但这是通过”剥夺”发送者对队列的控制来实现的.所有的发送端能做的就是往队列里投递消息.这使得队列在发送端需要实时反馈时显得很不适用<br>事件队列会更复杂一些并且对你的游戏框架产生广泛而深远的影响.这意味着你在决定如何使用,是否适用本模式时须三思<br>中心事件队列是个全局变量<br>该模式的一种普遍用法被称为”中央枢纽站”,游戏中所有模块的消息都可以通过它来传递.它是游戏中强大的基础设施,然而强大并不总意味着好用<br>关于”全局变量是糟糕的”这点,大多数人在走过不少弯路后才恍然大悟.当你有一些系统的任何部分都能访问的状态时,各种细小部分不知不觉地产生了相互依赖.本模式将这些状态封装成为一种不错的小协议,但让然是全局性的,故仍具有任何全局变量所包含的危险性da<br>游戏世界的状态任你掌控<br>当你接收到一个事件,你要十分谨慎,不可认为当前世界的状态反映的是消息发出时世界的状态.这就意味着队列事件视图比同步系统中的事件具有更重量级的数据结构.后者只需通知”某事发生了”然后接收者可以检查系统环境来深入细节,而适用队列时,这些细节必须在事件发生时被记录以便稍后处理消息时适用<br>你会在反馈系统循环中绕圈子，任何一个事件或消息系统都得留意循环<br>当你的消息系统是同步的,你很块就能发现死循环—-它们会导致栈溢出并造成游戏崩溃.对于队列来说,异步的放开栈处理会适这些伪事件在系统中来回徘徊,但游戏可能会保持运行.一个常用的规避法则是避免在处理事件末端代码中发送事件<br>许多游戏将事件队列作为通讯架构的一个关键部分,你可以花大量的时间来设计各种复杂的路由和消息过滤机制.但在你准备建立类似于洛杉矶电话交换机系统那样的东西之前,我建议你开始要简单点.下面是入门时要考虑的一些问题<br>“事件”和”消息”总是被我替换着使用,因为这无伤大雅.无论你往队列里塞什么,它都具备相同的解耦与聚合能力,但二者仍然有一些概念上的不同<br>如果队列中是事件<br>　　一个”事件”或”通知”描述已经发生的事情,比如”怪物死亡”.你将它入队,所以其他对象可以响应事件,有几分像一个异步的观察者模式<br>　　你可能会允许多个监听器.由于队列包含的事件已经发生.因此发送者不关心谁会接收到它.从这个角度来看,这个事件已经过去并且已经被忘记了<br>　　可访问队列的域往往更广.事件队列经常用于给任何和所有感兴趣的部分广播事件.为了允许感兴趣的部分有更大的灵活性,这些队列往往有更多的全局可见性<br>如果队列中是消息<br>　　一个”消息”或”请求”描述一种”我们期望”发生在”将来”的行为,类似于”播放音乐”.你可以认为这是一个异步API服务<br>　　你更可能只有单一的监听器.示例中,队列中的消息专门向音频API请求播放声音.如果游戏的其他任何部分开始从队列中偷窃消息,那并不会起到好的作用<br>谁能从队列中读取<br>单播队列　　当一个队列是一个类的API本身的一部分时,单播再合适不过了<br>广播队列　　这是大多数”事件”系统所做的事情.当一个事件进来时,如果你有十个监听器,则它们都能看见该事件，事件可以被删除，可能需要过滤事件<br>工作队列　　类似于一个广播队列,此时你也有多个监听器.不同的是队列中的每一项只会被投递到一个监听器中.这是一种对于并发线程支持不好的系统中常见的工作分配模式<br>　　你必须做好规划<br>谁可以写入队列<br>一个写入者　　这种风格尤其类似于同步式观察者模式.你拥有一个可以生成事件的特权对象,以供其他模块接收<br>　　你隐式地知道事件的来源<br>　　通常允许多个读取者.你可以创造一对一接收者的队列,但是,这样不太像通信系统,而更像是一个普通的队列数据结构<br>多个写入者　　这是我们的音频引擎例子的工作原理.因为”playSound()”函数是一个公共方法,所以任何代码库部分都可以为队列添加一个请求,”全局”或”中央”事件总线工作原理类似，你必须小心反馈循环，你可能会想要一些发送方在事件本身的引用<br>队列中对象的生命周期是什么<br>转移所有权　　这是手动管理内存时的一种传统方法.当一个消息排队时,队列声明它,发送者不再拥有它.当消息处理时,接收者取走所有权并负责释放它<br>共享所有权　　当前,虽然C++程序员能更舒服地进行垃圾回收了,但分享所有权会容易接受.这样一来,只要任何事情对它有一个引用,消息就依然存在.当被忘记时它就会自动释放<br>队列拥有它　　另一个观点是消息总是存在于队列中.不用自己释放消息,发送者会从队列中请求一个新的消息.队列返回一个已经存在于队列内存中的消息引用,接着发送者会填充队列.消息处理时,接收者参考队列中相同消息的操作.<br>但在很多方面,这个模式可以看成是我们所熟知的观察者模式的异步版本<br>和很多模式一样,事件队列有过一些其他别名.其中一个概念叫做”消息队列”,它通常是指一个更高层面的概念.当事件队列应用于应用程序内部时,消息队列通常用于消息之间的通信<br>另一个术语是”发布/订阅”,有时缩写为”订阅”.类似于”消息队列”,它通常在大型分布式系统中被提及,而不专用于像我们例子这阿姨那个简陋的编码模式中<br>第16章 服务定位器<br>为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合<br>在游戏编程中,某些对象或者系统几乎出现在程序的每个角落.在某些时刻,你很难找到一个不需要内存分配,日志记录或者随机数生成的游戏.我们通常认为类似这样的系统是在整个游戏中需要被随时访问的服务<br>尽管我们实现了想要的目的,但整个过程却带来了很多耦合.游戏中每一处调用音频系统的地方,都直接引用了具体的AudioSystem类和访问AudioSystem类的机制—-使用静态类或者单例<br>这些调用音频系统的地方,的确需要耦合到某些东西上以便播放声音,但直接耦合到音频具体实现类上就好像让一百个陌生人知道你家的地址,而仅仅是因为需要它们投递信件.这不仅是隐私问题,而且当你搬家时必须告诉每个人你的新地址,这实在是太痛苦了<br>这里有个更好的解决办法:电话簿.每一个想要联系我们的人能够通过查找名字来得到我们当前的地址.当我们搬家时,我们告诉电话公司,它们更新电话簿,这样每个人都能得到新的地址了.实际上,我们甚至不必给出我们真正的地址.我们能够列出一个邮政信箱,或者其他能够”代表”我们的东西.通过让访问者查询电话簿来找到我们,我们便有了一个方便的可以控制如何查找我们的地方<br>这就是服务定位器模式的简单介绍—-它将一个服务的”是什么(具体实现类型)”和”在什么地方(我们如何得到它的实例)”与需要使用整个服务的代码解耦了<br>一个服务类为一系列操作定义了一个抽象的接口.一个具体的服务提供器实现了这个接口.一个单独的服务定位器通过查找一个合适的提供器来提供这个服务的访问,它同时屏蔽了提供器的具体类型和定位这个服务的过程.<br>每当你将东西变得全局都能访问的时候,你就是在自找麻烦.这就是单例模式存在的主要问题,而这个模式存在的问题也没有什么不同.对于何时使用服务定位器,我的简单建议就是: 谨慎使用<br>与其给需要使用的地方提供一个全局机制来访问一个对象,不如首先考虑将这个对象传递进去.这极其简单易用,而且将耦合变得直观.这可以满足绝大部分需求<br>但是,有时手动地将一个对象传来传去显得毫无理由或者使得代码难以阅读.有些系统,比如日志系统或内存管理系统,不应该是某个模块公开API的一部分.渲染代码的参数应该必须和渲染相关,而不是像日志系统那样的东西<br>同样地,它也适用于一些类似功能的单一系统.你的游戏可能只有一个音频设备或者显示系统让玩家与之打交道.传递的参数是一项环境属性,所以将它传递10层函数以便让一个底层的函数能够访问,为代码增加了毫无意义的复杂度<br>在这些情况下,这个模式能够起到作用.它用起来像一个更灵活,更可配置的单例模式.当被合理地使用时,它能够让你的代码更有弹性,而且几乎没有运行时的损失.<br>服务定位器的关键困难在于,它要有所依赖(连接两份代码),并且在运行时才连接起来.这给与了你弹性,但付出的代价就是阅读代码时比较难以理解依赖的是什么.<br>服务必须被定位<br>当使用单例或者一个静态类时,我们需要的实例不可能变得不可用.但是,既然这个模式需要定位服务,那么我们可能需要处理定位失败的情况<br>服务不知道被谁定位<br>既然定位器是全局可访问的,那么游戏中的任何代码都有可能请求一个服务然后操作它.这意味着这个服务在任何情况下都必须能正确工作.<br>静态函数getAudio()负责定位工作.我们能在代码的任何地方调用它,它能返回一个Audio服务的实例提供我们使用<br>它”定位”的方法十分简单—-在使用这个服务之前它依赖一些外部代码来注册一个服务提供器.<br>这里使用的技术叫做依赖注入,这个术语表示了一个基本的思想.假设你有一个类,依赖另外一个类.在我们的例子中,我们的Locator类需要Audio服务的一个实例.通常,这个定位器应该负责为自己构建这个实例.依赖注入却说外部代码应该负责为这个对象注入它所需要的这个依赖实例<br>这里关键需要注意的地方是调用playSound()的代码对Audio具体实现毫不知情.它只知道Audio的抽象接口,同样重要的是,甚至是定位器本身和具体服务提供器也没有耦合.代码中唯一知道具体实现类的地方,是提供这个服务的初始化代码<br>这里还有更深一层的解耦—-通过服务定位器,Audio接口在绝大多数地方并不知道自己正在被访问.一旦它知道了,它就是一个普通的抽象基类了.这十分有用,因为这意味着我们可以将这个模式应用到一些已经存在的但并不是围绕这个来设计的类上.这和单例有个对比,后者影响了”服务”类本身的设计<br>“时序解耦”—-两份单独的代码必须按正确的顺序调用来保证程序正确工作.每个状态软件都有不同程度的”时序耦合”,但是就像其他耦合那样,消除时序耦合会使得代码易于管理<br>装饰器模式<br>服务是如何被定位的<br>外部代码注册<br>　　它简单快捷<br>　　我们控制提供器如何被构建<br>　　我们可以在游戏运行的时候更换服务提供器<br>　　定位器依赖外部代码<br>在编译时绑定<br>　　你能保证服务可用<br>　　你不能方便地更改服务提供器<br>在运行时配置<br>　　我们不需重编译就能切换服务提供器<br>　　非程序员能够更换服务提供器<br>　　一份代码库能够同时支持多份配置<br>　　不像前几个解决方案,这方案比较复杂且十分重量级<br>　　定位服务需要时间<br>当服务不能被定位时发生了什么<br>让使用者处理<br>　　它让使用者决定如何处理查找失败<br>　　服务使用者必须处理查找失败<br>终止游戏<br>　　使用者不需要处理一个丢失的服务<br>　　如果服务没有被找到,游戏将会中断<br>返回一个空服务<br>　　使用者不需要处理丢失的服务<br>　　当服务不可用时,游戏还能继续<br>服务的作用域多大<br>如果是全局访问<br>　　它鼓励整个代码库使用同一个服务<br>　　我们对何时何地使用服务完全失去了控制<br>如果访问被限制到类中<br>　　我们控制了耦合.<br>　　它可能导致重复的工作<br>我的一般原则是,如果服务被限制在游戏的一个单独域中,那么就把服务的作用域限制到类中.比如,获取网络访问的服务就可能被限制在联网的类中.而更广泛使用的服务,比如日志服务应该是全局的<br>　<br>第17章 数据局部性<br>通过合理组织数据利用CPU的缓存机制来加快内存访问速度<br>RAM的存取速度远远跟不上CPU的速度<br>对刚访问数据的邻近数据进行访问的术语叫做访问局部性<br>当代计算机有多级缓存,也就是你所听到的那些”L1”, “L2”, “L3”等.它们的大小按照其等级递增,但速度却随等级递减<br>当代CPU带有多级缓存以提高内存访问速度.这一机制加快了对最近访问过的数据的邻近内存的访问速度.通过增加数据局部性并利用这一点可以提高性能—-保持数据位于连续的内存中以提供程序进行处理<br>如果多数优化措施,知道我们使用数据局部性模式的第一条准则就是找到出现性能问题的地方.不要在那些代码库里非频繁执行的部分浪费时间,它们不需要本模式.对那些非必要的代码进行优化将使你的人生变得艰难—-因为结果总是更加复杂且笨拙.由于此模式的特殊性,因此你可能还希望确定你的性能问题是否是由缓存未命中引起的,如果不是,那么这个模式也帮不上忙<br>为了做到缓存友好,你可能需要牺牲一些之前所做的抽象化.你越是在程序的数据局部性上下工夫,你就越要牺牲继承,接口以及这些手段所带来的好处.这里并没有高招,只有利弊权衡的挑战.而乐趣便在这里<br>这种设计模式更适合叫做一种思维模式.它提醒着你,数据的组织方式是游戏性能的一个关键部分.这一块的实际拓展空间很大,你可以让你的数据局部性影响到游戏的整个架构,又或者它只是应用在一些核心模块的数据结构上.对这一模式的应用,你最需要关心的就是该何时何地使用它.而随着这个问题我们也会看到一些新的顾虑<br>如何处理多态<br>避开继承<br>　　安全而容易<br>　　速度更快<br>　　灵活性差<br>为不同的对象类型使用相互独立的数组<br>　　这样的一系列集合让对象紧密地封包<br>　　你可以进行静态地调用分发<br>　　你必须时刻追踪这些集合<br>　　你必须注意每一个类型<br>使用指针集合<br>　　这样做灵活性高<br>　　这样做并不缓存友好<br>假如游戏实体通过类中的指针来索引其组件<br>　　你可以将组件存于相邻的数组中<br>　　对于给定实体,你可以很容易地获取它的组件<br>　　在内存中移动组件很困难<br>假如游戏实体通过一系列ID来索引其组件<br>　　这更加复杂<br>　　这样做更慢<br>　　你需要访问组件管理器<br>假如游戏实体本身就只是个ID<br>　　你的游戏实体类完全消失了,取而代之的是一个优雅的数值包装<br>　　实体类本身是空的<br>　　你无须管理其生命周期<br>　　检索一个实体的所有组件会很慢<br>第18章 脏标记模式<br>许多游戏都有一个称之为场景图的东西.这是一个庞大的数据结构,包含了游戏世界中所有的物体.渲染引擎使用它来决定将物体绘制到屏幕的什么地方<br>就最简单的来说,一个场景图只是包含多个物体的列表.每个物体都含有一个模型(或其他图元)和一个”变换”.变换描述了物体在世界中的位置,旋转角度和缩放大小.想要移动或者旋转物体,我们可以简单地修改它的变换<br>当渲染器绘制一个物体时,它将这个物体的变换作用到这个物体的模型上,然后将它渲染出来.如果我们有的是一个场景”袋”而不是场景”图”的话,事情会变得简单很多<br>然而,许多场景图是分层的.场景中的一个物体会绑定在一个父物体上.在这种情况下,它的变换就依赖于其父物体的位置,而不是游戏世界中的一个绝对位置.<br>举个例子,想象我们的游戏中有一艘海盗船在海上.桅杆的顶部是一个瞭望塔,一个海盗靠在这个瞭望塔上,抓在海盗肩膀上的是只鹦鹉.这艘船的局部变换标记了它在海中的位置,瞭望塔的变换标记了它在船上的位置,等等<br>鹦鹉-&gt;海盗-&gt;瞭望塔-&gt;海盗船<br>这样,当一个父物体移动时,它的子物体也会自动地跟着移动.如果我们修改船的局部变换,瞭望塔,海盗,鹦鹉也会随之变动.如果在船移动时我们必须手动调整船上所有物体的变换来防止相对滑动,那会是一件很头疼的事情<br>计算一个物体的世界变换是相当直观的—-只要从根节点沿着它的父链将变换组合起来就行.也就是说鹦鹉的世界变换就是<br>鹦鹉世界变换 = 船的局部变换 x 瞭望塔的局部变换 x 海盗的局部变换 x 鹦鹉的局部变换<br>我们每帧都需要世界中每个物体的世界变换.所以即使每个模型中只有少数的几个矩阵相乘,却也是代码中影响性能的关键所在.保持它们及时更新是棘手的,因为当一个父物体移动,这会影响它自己和它所有的子物体,以及子物体的子物体等的世界变换<br>最简单的途径是在渲染的过程中计算变换.每一帧中,我们从顶层开始递归地遍历场景图.对每个物体,我们计算它们的世界变换并立刻绘制它<br>但是这对我们宝贵的CPU资源是一种可怕的浪费.许多物体并不是每一帧都移动.想想关卡中那些静止的几何体,它们没有移动,但每一帧都要重计算它们的世界变换是一种多么大的浪费<br>一个明显的解决方法是将它”缓存”起来.在每个物体中,我们保存它的局部变换和它派生物体的世界变换.当我们渲染时,我们只使用预先计算好的世界变换.如果物体从不移动,那么缓存的变换始终是最新的,一切都很美好<br>当一个物体缺失移动了,简单的方法就是立即刷新它的世界变换.但是不要忘了继承连!当一个父物体移动时,我们需要重计算它的世界变换并递归地计算它所有子物体的世界变换<br>想象某些比较繁重的游戏场景.在一个单独帧中,船被扔进海里,瞭望塔在风中晃动,海盗斜靠在边上,鹦鹉跳到他的头上.我们修改了4个局部变换.如果我们在每个局部变换变动时都匆忙地重新计算世界变换,结果会发生什么<br>我们只移动了4个物体,但是我们做了10次世界变换计算.这6次无意义的计算在渲染器使用之前就被扔掉了.我们计算了4次鹦鹉的世界变换,但是只渲染了一次<br>问题的关键是一个世界变换可能依赖于好几个局部变换.由于我们在每个这些变换变化时都立刻重计算,所以最后当一帧内有好几个关联的局部变换改变时,我们就将这个变换重新计算了好多遍<br>我们通过将修改局部变换和更新世界变换解耦来解决这个问题.这让我们在单次渲染中修改多个局部变换,然后在所有变动完成之后,在实际渲染器使用之前仅需要计算一次世界变换<br>要做到这点,我们为图中每个物体添加一个”flag”.”flag”和”bit”在编程中是同义词—-它们都表示单个小单元数据,能够存储两种状态中的一个.我们称之为”true”和”false”,有时也叫”set”和”cleared”.<br>我们在局部变换改动时设置它.当我们需要这个物体的世界变换时,我们检查这个flag.如果它被标记为”set”了,我们计算这个世界变换,然后将这个flag置为”clear”.这个flag代表,”这个世界变换是不是过期了?”由于某些原因,传统上这个”过期的”被称作”脏的”.也就是”脏标记”,”Dirty bit”也是这个模式常见的名字.但是我想我会坚持使用那种看起来每那么”污秽”的名字<br>如果我们运用这个模式,然后将我们上个例子中的所有物体都移动,那么游戏看起来如下:<br>这是你能期望的最好的办法.每个被影响的物体的世界变换只需要计算一次.只需要一个简单的位数据,这个模式位我们做了不少事：<br>　　它将父链上物体的多个局部变换的改动分解为每个物体的一次重计算<br>　　它避免了没有移动的物体的重计算<br>　　一个额外的好处: 如果一个物体在渲染之前移除了,那就根本不用计算它的世界变换<br>一组原始数据随时间变化.一组衍生数据经过一些代价昂贵的操作由这些数据确定.一个脏标记跟踪这个衍生数据是否和原始数据同步.它在原始数据改变时被设置.如果它被设置了,那么当需要衍生数据时,它们就会被重新计算并且标记被清除.否则就使用缓存的数据<br>脏位标记设计两个关键词:”计算”和”同步”.在这两种情况下,处理原始数据到衍生数据的过程在时间或其他方面会有很大的开销<br>这里也有些其他的要求:<br>原始数据的修改次数比衍生数据的使用次数多，<br>递增地更新数据十分困难，<br>延时太长会有代价，<br>这个模式把某些耗时的工作推迟到真正需要时才进行,而到有需要时,往往刻不容缓.<br>必须保证每次状态改动时都设置脏标记<br>既然衍生数据是通过原始数据计算而来,那它本质上就是一份缓存.当你获取缓存数据时,棘手的问题是缓存失效—-当缓存和原始数据不同步时,什么都不正确了.在这个模式中,它意味着当任何原始数据变动时,都要设置脏标记<br>必须在内存中保存上次的衍生数据<br>何时清除脏标记<br>当需要计算结果时<br>　　当计算结果从不使用时,它完全避免了计算<br>　　如果计算十分耗时,会造成明显的卡顿<br>在精心设定的检查点<br>　　这些工作并不影响用户体验.<br>　　当工作执行时,你失去了控制权<br>在后台<br>　　你可以调整工作执行的频率<br>　　你可以做更多冗余的工作<br>　　需要支持异步操作<br>脏标记追踪的粒度多大<br>更精细的粒度<br>　　你只需要处理真正变动了的数据,你将船的真正变动的木块数据发送给服务器<br>更粗糙的粒度<br>　　你最终需要处理未变动的数据<br>　　存储脏标记消耗更少的内存<br>　　固定开销花费的时间要更少<br>物理引擎跟踪着物体的运动和空闲状态.一个空闲的物体直到受到力的作用才会移动,它在受力之前不需要处理.这个”是否在移动”就是一个脏标记,用来标记哪些物体收到了力的作用并需要计算它们的物理状态<br>第19章 对象池<br>使用固定的对象池重用对象,取代单独地分配和释放对象,以此来达到提升性能和优化内存使用的目的<br>定义一个保持着可重用对象集合的对象池类.其中的每个对象支持对其”使用(in use)”状态的访问,以确定这一对象目前是否”存活(alive)”.在对象池初始化时,它预先创建整个对象的集合(通常为一块连续堆区域),并将它们都置为”未使用(not in use)”状态<br>当你想要创建一个新对象时就向对象池请求.它将搜索到一个可用的对象,将其初始化未”使用中(in use)”状态并返回给你.当该对象不再被使用时,它将被置回”未使用(not in use)”状态.使用该方法,对象便可以在无需进行内存或其他资源分配的情况下进行任意的创建和销毁<br>对象池模式被广泛地应用于游戏中的可见物体,如游戏实体对象,各种视觉特效,但同时也被使用于非可见的数据结构中,如当前播放的声音.我们在以下情况使用对象池:<br>当你需要频繁地创建和销毁对象时，对象的大小一致时，在堆上进行对象内存分配较慢或者会产生内存碎片时，每个对象封装着获取代价昂贵且可重用的资源,如数据库,网络的连接<br>注意问题：<br>1 对象池可能在闲置的对象上浪费内存<br>2 任意时刻处于存活状态的对象数目恒定<br>3 每个对象的内存大小是固定的<br>4 重用对象不会被自动清理<br>5 未使用的对象将占用内存<br>对象与对象池耦合<br>　　实现很简单,你可以简单地为那些池中的对象增加一个”使用中”的标志位或者函数,这就能解决问题了<br>　　你可以避免存储一个”使用中”的标志位,许多对象已经维护了可以表示自身是否仍然存活的状态<br>对象独立于对象池<br>　　任意类型的对象可以被置入池中.这是个巨大的优点.通过对象与对象池的解绑,你将能够实现一个通用,可重用的对象池类<br>　　“使用中”状态必须能够在对象外部被追踪.最简单的做法是在对象池中额外创建一块独立的空间:<br>对象池模式与享元模式看起来很相似.它们都管理着一系列可重用对象.其差异在于”重用”的含义.享元模式中的对象通过在多个持有者中并发地共享相同的实例以实现重用.它避免了因在不同上下文中使用相同对象而导致的重复内存使用.对象池的对象也被重用,但此”重用”意味着在原对象持有者使用完对象之后,将其内存回收.对象池里的对象在其生命周期中不存在着因为被共享而引致的异常<br>将那些类型相同的对象在内存上整合,能够帮助你在遍历这些对象时利用好CPU的缓存区.数据局部性设计模式阐释了这一点<br>第20章 空间分区<br>将对象存储在根据位置组织的数据结构中来高效地定位它们<br>对于一组对象而言,每一个对象在空间都有一个位置.将对象存储在一个根据对象的位置来组织的数据结构中,该数据结构可以让你高效地查询位于或靠近某处的对象.当对象的位置变化时,应更新该空间数据结构以便可以继续这样查找对象<br>这是一个用来存储活跃的,移动的对象以及静态图像和游戏世界的几何形状等对象的常见模式.复杂的游戏常常有多个空间分区来应对不同类型的存储内容<br>该模式的基本要求是你有一组对象,每个对象都具备某种位置信息,而你因为要根据位置做大量的查询来查找对象从而遇到了性能问题<br>空间分区将O(n)或者O(n2)复杂度的操作拆解为更易于管理的结构.对象越多,模式的价值就越大.相反,如果你的n值很小,则可能不值得使用该模式.由于该模式要根据对象的位置来组织对象,故对象位置的改变就变得难以处理了.你必须重新组织数据结构来跟踪物体的新位置,这会增加代码的复杂性并产生额外的CPU周期开销.你必须确保这么做是值得的<br>空间分区会使用额外的内存来保存数据结构.就像许多的优化一样,它是以空间换取速度的.如果你的内存比时钟周期更吃紧的话,这可能是个亏本生意<br>分区是层级的还是扁平的<br>在网格例子中,我们将网格划分成了一个单一扁平的单元格集合.与此相反,层级空间分区则是将空间划分成几个区域.然后,如果这些区域中仍然包含着许多的对象,就会继续划分.整个递归过程持续到每个区域的对象数目都少于某个约定的最大对象数量为止<br>如果它是一个扁平的分区<br>　　相对简单<br>　　内存使用量恒定<br>　　当对象改变位置时可以更为快速地更新<br>如果它是一个层级的分区<br>　　它可以更有效地处理空白的空间<br>　　它在处理对象稠密区域时更为有效<br>如果分区依赖于对象<br>　　对象可以被逐步地添加<br>　　对象可以快速地移动<br>　　分区可以不平衡<br>如果分区自适应于对象集合<br>　　你可以确保分区间的平衡<br>　　对整个对象集合进行一次性的分区时更为高效<br>如果分区不依赖于对象,而层级却依赖于对象<br>　　可以逐步地增加对象<br>　　对象可以快速地移动<br>　　分区是平衡的<br>如果它是对象唯一存储的地方，这避免了两个集合的内存开销和复杂性<br>如果存在存储对象的另外一个集合，遍历所有的对象会更为快速<br>在这章中我避开对具体空间分区结构的详细讨论,以保持章节的高层次概括性(并且也不会太长),但是下一步你应该要去了解一些常见的结构.尽管它们的名字吓人,但却出奇的简单明了.常见的有网格、四叉树、二叉空间分割、k-d树、层次包围盒<br>每一个空间数据结构基本都是从一个现有已知的一维数据结构扩展到多维,了解它们的线性结构会帮助你判断它们是否适合于解决你的问题:<br>　　网格是一个连续的桶排序<br>　　二叉空间分割,k-d树,以及层次包围盒都是二叉查找树<br>　　四叉树和八叉树都是Trie树</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/06/28/2025-06-28/" data-id="cmcw2i8g60001isz8c9izb88n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2025-06-27" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/27/2025-06-27/" class="article-date">
  <time datetime="2025-06-27T00:27:04.000Z" itemprop="datePublished">2025-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/27/2025-06-27/">slot 游戏知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="slot-游戏知识"><a href="#slot-游戏知识" class="headerlink" title="slot 游戏知识"></a>slot 游戏知识</h2><p><img src="/img/slot_machine_1.jpeg" alt="网络图，如侵权请联系我删除">)(网上找的图，侵删)</p>
<h3 id="slot-术语"><a href="#slot-术语" class="headerlink" title="slot 术语"></a>slot 术语</h3><p>Reels 滚轴<br>symbol 符号(出现在滚轴上的图案，玩家需要组合出特定符合才能赢钱，体现slot主题玩法的载体和主题辨识度的直接视觉元素）<br>basic symbols<br>数字和字母（典型扑克牌AKQJ10）<br>经典符号水果（🍒，🍋，🍉，🍇）传统的BAR符号<br>High-Value symbol<br>与主题相关的符号，如埃及神话, 法老， 法杖，公主等<br>Special symbol<br>特殊符号：在特定情况下可以带来高额奖励或者特殊玩法。宝石，宝箱，</p>
<p>百搭符合（WILD )<br>可以替代其他符合来形成盈利组合的特殊符号（Scatter，Bonus，Jackpot等特殊symbol除外）Wild pays substitutes for all symbols except（Scatter，Bonus， japkot）<br><strong>* 在设计slot有一个常识，就是当使用百搭符合来匹配组合时，奖金翻倍。<br> 注意百搭符合匹配出来的组合，要根据优先级顺序进行赔付，slot的共通规则是每条赔付线上赔付最好的奖金，而不是所有满足赔付的组合都赔付。*</strong></p>
<p>Scatter symbol 不需要再赔付线上连续出现，只要出现在滚轴上就可以赢得奖励。通常3、4、5个Scatter停在界面就可以激活free spin game。<br>（如果每个reel 同时停留两个堆叠的Scatter，可以改变游戏RTP，)<br>bonus symbol 跟Scatter symbol 类似，以特定组合出现触发额外奖励游戏（bonus game，bingo，开箱子，点泡泡等小游戏）<br>4、其他符号，<br>累计奖池符号<br>扩展符号<br>固定符号<br>叠加符号<br>膨胀符号<br>分散符合<br>合并符合</p>
<p>3游戏区域Play window<br>3X5,5x3,4x5,6x4</p>
<p>4、Base Game<br>5、Feature Game（Free Game、bonus Game）<br>6、赔付线<br>在数量和布局上数值上不太重要，因为RTP跟游戏中赔付线数量无关，与之相关的事命中率和获胜率会随着赔付线的增加而线性增加。所以在设计赌注也会相应增加以保持RTP恒定。<br>每个主题游戏的最大赔付线是每个Reel的各个窗口高度的乘积（3x5 -&gt; 3^5)<br>7 乘数（multiplier）增加盈利的倍数（x2,x3)<br>8 赔付表（paytable）<br>9、 命中率（hit Rate）</p>
<p>玩家在一定的旋转次数内，能够获得任何奖励的概率，命中率会受到赔付表和符号的影响，形成高命中率和低命中率。<br>玩家更频繁的触发赢钱组合，更多低价值符号，让玩家更频繁地获得小额盈利<br>玩家可能需要更多spin 才能触发赢钱，游戏中更多高价值符号和特殊符号，需当特色符号触发时，让玩家获得更大奖励，导致较低命中率。</p>
<p>hitRate = 1/probability = cycle/hit<br>hitFrequency = 100% / hitRate<br>probability  获奖概率<br>cycle 游戏窗口每个滚轴中符号个数的乘积<br>比如1x3 Reel，每个Reel包含10个符号，则cycle = 10x10x10<br>hits 符号在赔付线上命中的次数。<br>probability = hits / cycle</p>
<p>10 波动性Volatility<br>游戏输赢的波动指标，可以用于衡量玩家在游戏中输赢的大小。输赢频率，输赢快慢，用数据来解释，也可以称之为方差。用来衡量数据点相对均值的偏离程度。波动高低和RTP关系不大。</p>
<p>11 、奖池（JackPot）<br>固定奖池<br>累计奖池（单机累计，多人累计）<br>设计者设定规则（5%投注金额将加入到奖池中，奖池金额一直在涨，假的。只不过是设计机器人陪玩。<br>等级奖池，分多个级别的奖池，比如mini,minor,major,mega,grand)</p>
<p> 12、True 随机数生成器<br>random.org提供了真随机数的免费服务接口<br>真随机，基于物理过程（如放射性衰变，光电效应，大气噪声）来生成随机数，通常与硬件设备结合使用。有自然界不可预测性决定。<br>Pseudorandom number generator。基于一个或者多个初始值，（seed)使用确定性算法生成的数字序列，当我们知道该初值和背后算法的工作原理，就可以重现该随机结果。具有周期性。<br>伪随机数算法：线性同余发生器。<br>Xn+1 = (a* Xn+c) mod m<br>通过递推生成伪随机数，Xn位当前随机值，Xn+1 为下一个随机数。<br>a:multiplier<br>c:increment<br>m: modulus.</p>
<p>在设计online slot 上根据游戏的属性不同会使用不同的随机数生成器。<br>如果 设计的游戏仅仅是一款social slots，采用为随机数生成器就可以<br>如果 设计的游戏为了活动游戏许可证（Gaminglicense） 要符合当地监管机构的法律法规，需要采用真随机数生成器，<br>如果设计的游戏采用了经过监管认证的为随机数生成器，并且符合相关的监管要求和技术标准。<br>任然可以使用伪随机当真人娱乐场。</p>
<p>slot监管和测试随机数生成器的机构</p>
<p>GLI(gaming laboratories internationnal）美国内华达州拉斯维加斯，认证和检测</p>
<p>TST（Technical Systems Testing）加拿大<br>BMM Testlabs  测试<br>Gambling Commission 英国博彩委员会（审查和测试）<br>5、iTech Labs 澳大利亚墨尔本 测试和认证</p>
<p>玩家回报率<br>RTP return to Player<br>SRTP  standard Return to Player<br>RTP = Total Win /Total Bet</p>
<p>SRTP = averageWin/ averageBet</p>
<p>averageWin = prize * probability of prize<br>prize 代表符号的赔付值<br>probability 赔付符号的获奖概率。</p>
<p>SRTP = prize * hits/ cycle * averagebet * 100%</p>
<p>SRTP = (win/bet)/TotalBetTimes</p>
<p>设计一款slot 设定好它的数学模型，赔率设定，游戏规则之后，计算出游戏所有的结果加权平均回报值（确定SRTP =（91.68%）<br>在实际游戏过程中，要考虑到一个重要的因素：游戏的波动性，<br>它决定了理论RTP允许的容差，当spin 次数有限时，容差会更宽</p>
<p>假设游戏设计者在设计时波动性=5.6 那么95%置信区间计算出来的平均值偏差</p>
<p>当游戏上线一段时间后，玩家在这个游戏中累计投资￥1.200.000 获得1.085.000</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/06/27/2025-06-27/" data-id="cmcvdrdwm0003ccz8449kgxfk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" rel="tag">slot, 老虎机, slot game</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2025-06-26" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/26/2025-06-26/" class="article-date">
  <time datetime="2025-06-26T00:28:05.000Z" itemprop="datePublished">2025-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/06/26/2025-06-26/">老虎机（Slot Machine）的核心算法整理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="老虎机（Slot-Machine）核心算法详解"><a href="#老虎机（Slot-Machine）核心算法详解" class="headerlink" title="老虎机（Slot Machine）核心算法详解"></a>老虎机（Slot Machine）核心算法详解</h2><p>老虎机是博彩业中最流行的游戏之一，其看似简单的表面下隐藏着复杂而精密的数学模型和算法。作为资深的Slots游戏开发，我将深入解析老虎机的核心算法，包括随机数生成、符号权重分配、RTP控制、波动性设计以及特殊功能触发等关键技术。</p>
<h4 id="随机数生成系统（RNG）"><a href="#随机数生成系统（RNG）" class="headerlink" title="随机数生成系统（RNG）"></a>随机数生成系统（RNG）</h4><p>伪随机数生成器（PRNG）<br>老虎机的核心是一个高质量的伪随机数生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Dict, Tuple, Optional</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotRNG</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""使用系统时间和随机源初始化随机数生成器"""</span></span><br><span class="line">        self.generator = random.Random()</span><br><span class="line">        self.generator.seed(time.time() + random.randint(<span class="number">0</span>, <span class="number">1000000</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, min_val: int, max_val: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""生成[min_val, max_val]范围内的随机整数"""</span></span><br><span class="line">        <span class="keyword">return</span> self.generator.randint(min_val, max_val)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next_float</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">"""生成[0.0, 1.0)范围内的随机浮点数"""</span></span><br><span class="line">        <span class="keyword">return</span> self.generator.random()</span><br></pre></td></tr></table></figure>


<h4 id="随机数映射技术"><a href="#随机数映射技术" class="headerlink" title="随机数映射技术"></a>随机数映射技术</h4><p>随机数需要映射到游戏中的具体元素（如符号、位置等）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Symbol</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    WILD = <span class="number">0</span></span><br><span class="line">    HIGH1 = <span class="number">1</span></span><br><span class="line">    HIGH2 = <span class="number">2</span></span><br><span class="line">    LOW1 = <span class="number">3</span></span><br><span class="line">    LOW2 = <span class="number">4</span></span><br><span class="line">    SCATTER = <span class="number">5</span></span><br><span class="line">    BONUS = <span class="number">6</span></span><br><span class="line">    BLANK = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_random_to_symbol</span><span class="params">(random_value: int, symbols: List[Symbol], weights: List[int])</span> -&gt; Symbol:</span></span><br><span class="line">    <span class="string">"""根据权重表将随机数映射到具体符号"""</span></span><br><span class="line">    total_weight = sum(weights)</span><br><span class="line">    scaled_random = random_value % total_weight</span><br><span class="line">    </span><br><span class="line">    accumulated_weight = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, symbol <span class="keyword">in</span> enumerate(symbols):</span><br><span class="line">        accumulated_weight += weights[i]</span><br><span class="line">        <span class="keyword">if</span> scaled_random &lt; accumulated_weight:</span><br><span class="line">            <span class="keyword">return</span> symbol</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 默认返回第一个符号</span></span><br><span class="line">    <span class="keyword">return</span> symbols[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h4 id="RNG审计与验证"><a href="#RNG审计与验证" class="headerlink" title="RNG审计与验证"></a>RNG审计与验证</h4><p>高质量的老虎机算法必须通过严格的随机性测试：</p>
<p>频率测试：确保每个符号出现频率符合其权重<br>序列测试：验证符号序列没有可预测模式<br>周期性分析：确保不存在可被利用的循环<br>统计分布测试：应用卡方检验等统计方法验证随机性</p>
<h4 id="符号分布与权重系统"><a href="#符号分布与权重系统" class="headerlink" title="符号分布与权重系统"></a>符号分布与权重系统</h4><p>虚拟转轮设计<br>现代老虎机通常使用虚拟转轮技术，每个转轮有不同的符号分布：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualReel</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, symbols: List[Symbol] = None, weights: List[int] = None)</span>:</span></span><br><span class="line">        self.symbols = symbols <span class="keyword">if</span> symbols <span class="keyword">else</span> []</span><br><span class="line">        self.weights = weights <span class="keyword">if</span> weights <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_total_stops</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""获取虚拟转轮的总长度（总权重）"""</span></span><br><span class="line">        <span class="keyword">return</span> sum(self.weights)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_random_symbol</span><span class="params">(self, rng: SlotRNG)</span> -&gt; Symbol:</span></span><br><span class="line">        <span class="string">"""从此转轮获取一个随机符号"""</span></span><br><span class="line">        total_weight = self.get_total_stops()</span><br><span class="line">        random_value = rng.next(<span class="number">0</span>, total_weight - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> map_random_to_symbol(random_value, self.symbols, self.weights)</span><br></pre></td></tr></table></figure>


<h4 id="不均匀分布设计"><a href="#不均匀分布设计" class="headerlink" title="不均匀分布设计"></a>不均匀分布设计</h4><p>关键符号（如散布符号、Wild、高付款符号）通常有特别设计的分布：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_virtual_reels</span><span class="params">()</span> -&gt; List[VirtualReel]:</span></span><br><span class="line">    <span class="string">"""构建一个5x3老虎机的虚拟转轮集，有不同的符号分布"""</span></span><br><span class="line">    reels = [VirtualReel() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>)]  <span class="comment"># 5轴老虎机</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第一个转轮配置</span></span><br><span class="line">    reels[<span class="number">0</span>].symbols = [Symbol.WILD, Symbol.HIGH1, Symbol.HIGH2, Symbol.LOW1, Symbol.LOW2]</span><br><span class="line">    reels[<span class="number">0</span>].weights = [<span class="number">3</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">30</span>, <span class="number">42</span>]  <span class="comment"># 总权重100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第二个转轮配置（减少Wild出现概率）</span></span><br><span class="line">    reels[<span class="number">1</span>].symbols = [Symbol.WILD, Symbol.HIGH1, Symbol.HIGH2, Symbol.LOW1, Symbol.LOW2]</span><br><span class="line">    reels[<span class="number">1</span>].weights = [<span class="number">2</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="number">35</span>, <span class="number">33</span>]  <span class="comment"># 总权重100</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 第三至五个转轮 - 进一步减少高价值符号出现率</span></span><br><span class="line">    reels[<span class="number">2</span>].symbols = [Symbol.WILD, Symbol.HIGH1, Symbol.HIGH2, Symbol.LOW1, Symbol.LOW2]</span><br><span class="line">    reels[<span class="number">2</span>].weights = [<span class="number">1</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">24</span>]</span><br><span class="line">    </span><br><span class="line">    reels[<span class="number">3</span>].symbols = [Symbol.WILD, Symbol.HIGH1, Symbol.HIGH2, Symbol.LOW1, Symbol.LOW2]</span><br><span class="line">    reels[<span class="number">3</span>].weights = [<span class="number">1</span>, <span class="number">18</span>, <span class="number">22</span>, <span class="number">45</span>, <span class="number">14</span>]</span><br><span class="line">    </span><br><span class="line">    reels[<span class="number">4</span>].symbols = [Symbol.WILD, Symbol.HIGH1, Symbol.HIGH2, Symbol.LOW1, Symbol.LOW2]</span><br><span class="line">    reels[<span class="number">4</span>].weights = [<span class="number">1</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">50</span>, <span class="number">4</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> reels</span><br></pre></td></tr></table></figure>


<h4 id="近似错过（Near-Miss）算法"><a href="#近似错过（Near-Miss）算法" class="headerlink" title="近似错过（Near Miss）算法"></a>近似错过（Near Miss）算法</h4><p>增强游戏性的关键技术之一是创造”差一点”的情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpinResult</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.visible_symbols = []  <span class="comment"># 存储每轴显示的符号</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SymbolCombination</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, symbols: List[Symbol], payout: int)</span>:</span></span><br><span class="line">        self.symbols = symbols</span><br><span class="line">        self.payout = payout</span><br><span class="line"></span><br><span class="line">NEAR_MISS_PROBABILITY = <span class="number">5</span>  <span class="comment"># 5%的概率生成近似错过效果</span></span><br><span class="line"><span class="comment"># 生成带有近似错过效果的结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_near_miss_effect</span><span class="params">(rng: SlotRNG, reels: List[VirtualReel])</span> -&gt; SpinResult:</span></span><br><span class="line">    <span class="string">"""生成带有近似错过效果的结果"""</span></span><br><span class="line">    result = SpinResult()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算是否应生成近似错过效果</span></span><br><span class="line">    should_create_near_miss = (rng.next(<span class="number">1</span>, <span class="number">100</span>) &lt;= NEAR_MISS_PROBABILITY)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> should_create_near_miss:</span><br><span class="line">        <span class="comment"># 选择一个高价值组合来"差一点"实现</span></span><br><span class="line">        target_combo = select_high_value_combination(rng)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 设置前几轴符合目标组合</span></span><br><span class="line">        result.visible_symbols = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(reels) - <span class="number">1</span>):</span><br><span class="line">            result.visible_symbols.append(target_combo.symbols[i])</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 最后一轴刻意选择不同的符号</span></span><br><span class="line">        last_symbol = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            last_symbol = reels[<span class="number">-1</span>].get_random_symbol(rng)</span><br><span class="line">            <span class="keyword">if</span> last_symbol != target_combo.symbols[<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        result.visible_symbols.append(last_symbol)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 生成完全随机的结果</span></span><br><span class="line">        result.visible_symbols = [reel.get_random_symbol(rng) <span class="keyword">for</span> reel <span class="keyword">in</span> reels]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_high_value_combination</span><span class="params">(rng: SlotRNG)</span> -&gt; SymbolCombination:</span></span><br><span class="line">    <span class="string">"""选择高价值组合用于近似错过效果"""</span></span><br><span class="line">    <span class="comment"># 这里简化实现，实际游戏可能有更复杂的逻辑</span></span><br><span class="line">    high_value_combos = [</span><br><span class="line">        SymbolCombination([Symbol.WILD, Symbol.WILD, Symbol.WILD, Symbol.WILD, Symbol.WILD], <span class="number">1000</span>),</span><br><span class="line">        SymbolCombination([Symbol.HIGH1, Symbol.HIGH1, Symbol.HIGH1, Symbol.HIGH1, Symbol.HIGH1], <span class="number">500</span>),</span><br><span class="line">        SymbolCombination([Symbol.HIGH2, Symbol.HIGH2, Symbol.HIGH2, Symbol.HIGH2, Symbol.HIGH2], <span class="number">300</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">return</span> rng.choice(high_value_combos)</span><br></pre></td></tr></table></figure>


<h4 id="RTP（Return-to-Player）控制"><a href="#RTP（Return-to-Player）控制" class="headerlink" title="RTP（Return to Player）控制"></a>RTP（Return to Player）控制</h4><p>RTP数学模型设计<br>RTP是老虎机设计中最核心的参数，通常在88%-98%之间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_combination_rtp</span><span class="params">(combo: SymbolCombination, reels: List[VirtualReel])</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""计算特定符号组合的RTP贡献"""</span></span><br><span class="line">    probability = calculate_combination_probability(combo, reels)</span><br><span class="line">    <span class="keyword">return</span> probability * combo.payout</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_combination_probability</span><span class="params">(combo: SymbolCombination, reels: List[VirtualReel])</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""计算组合出现的概率"""</span></span><br><span class="line">    probability = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> i, symbol <span class="keyword">in</span> enumerate(combo.symbols):</span><br><span class="line">        reel = reels[i]</span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> reel.symbols:</span><br><span class="line">            index = reel.symbols.index(symbol)</span><br><span class="line">            weight = reel.weights[index]</span><br><span class="line">            probability *= weight / sum(reel.weights)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>  <span class="comment"># 如果符号不在转轮上，概率为0</span></span><br><span class="line">    <span class="keyword">return</span> probability</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_theoretical_rtp</span><span class="params">(reels: List[VirtualReel], paytable: List[SymbolCombination])</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""计算整个游戏的理论RTP"""</span></span><br><span class="line">    total_rtp = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基础游戏RTP来自所有可能的赢付组合</span></span><br><span class="line">    <span class="keyword">for</span> combo <span class="keyword">in</span> paytable:</span><br><span class="line">        total_rtp += calculate_combination_rtp(combo, reels)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这里可以加上特殊功能的RTP贡献</span></span><br><span class="line">    <span class="comment"># total_rtp += calculate_bonus_game_rtp(reels)</span></span><br><span class="line">    <span class="comment"># total_rtp += calculate_free_spins_rtp(reels)</span></span><br><span class="line">    <span class="comment"># total_rtp += calculate_jackpot_rtp(reels)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total_rtp</span><br></pre></td></tr></table></figure>

<h4 id="RTP组成分解"><a href="#RTP组成分解" class="headerlink" title="RTP组成分解"></a>RTP组成分解</h4><p>现代老虎机的RTP通常由多个部分组成：</p>
<p>典型的RTP分配例子：</p>
<ul>
<li>基础游戏：60-65% RTP</li>
<li>免费游戏特性：20-25% RTP</li>
<li>小游戏/奖金游戏：5-10% RTP</li>
<li>累进奖池贡献：1-3% RTP</li>
<li>其他特殊功能：2-5% RTP</li>
</ul>
<p>动态RTP调整（部分地区允许）<br>某些司法管辖区允许的动态RTP调整系统：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicRTPController</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, base_rtp: float, min_rtp: float, max_rtp: float)</span>:</span></span><br><span class="line">        self.base_rtp = base_rtp</span><br><span class="line">        self.current_rtp = base_rtp</span><br><span class="line">        self.min_rtp = min_rtp</span><br><span class="line">        self.max_rtp = max_rtp</span><br><span class="line">        self.adjustment_factor = <span class="number">0.01</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_reels</span><span class="params">(self, reels: List[VirtualReel], metrics: dict)</span>:</span></span><br><span class="line">        <span class="string">"""基于当前性能调整虚拟转轮配置"""</span></span><br><span class="line">        allowed_deviation = <span class="number">0.01</span>  <span class="comment"># 1%的允许偏差</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> abs(self.current_rtp - self.base_rtp) &gt; allowed_deviation:</span><br><span class="line">            <span class="comment"># 计算需要的调整幅度</span></span><br><span class="line">            adjustment = self.calculate_required_adjustment()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 通过细微调整符号权重来影响RTP</span></span><br><span class="line">            <span class="keyword">for</span> reel <span class="keyword">in</span> reels:</span><br><span class="line">                self.adjust_symbol_weights(reel, adjustment)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 验证调整后的理论RTP</span></span><br><span class="line">            new_theoretical_rtp = self.recalculate_rtp(reels)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 确保调整后的RTP在合法范围内</span></span><br><span class="line">            <span class="keyword">assert</span> self.min_rtp &lt;= new_theoretical_rtp &lt;= self.max_rtp</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_required_adjustment</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">"""计算需要的调整量"""</span></span><br><span class="line">        <span class="keyword">return</span> (self.base_rtp - self.current_rtp) * self.adjustment_factor</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adjust_symbol_weights</span><span class="params">(self, reel: VirtualReel, adjustment: float)</span>:</span></span><br><span class="line">        <span class="string">"""调整符号权重"""</span></span><br><span class="line">        <span class="comment"># 简化实现：按比例调整所有权重</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(reel.weights)):</span><br><span class="line">            reel.weights[i] = max(<span class="number">1</span>, int(reel.weights[i] * (<span class="number">1</span> + adjustment)))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recalculate_rtp</span><span class="params">(self, reels: List[VirtualReel])</span> -&gt; float:</span></span><br><span class="line">        <span class="string">"""重新计算RTP"""</span></span><br><span class="line">        <span class="comment"># 这里简化实现，实际需要完整的paytable</span></span><br><span class="line">        <span class="keyword">return</span> calculate_theoretical_rtp(reels, [])</span><br></pre></td></tr></table></figure>


<h4 id="波动性与风险设计"><a href="#波动性与风险设计" class="headerlink" title="波动性与风险设计"></a>波动性与风险设计</h4><p>波动性数学模型<br>波动性（Volatility）决定了游戏的风险和回报特性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_volatility</span><span class="params">(reels: List[VirtualReel], paytable: List[SymbolCombination])</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""计算游戏波动性"""</span></span><br><span class="line">    expected_payout = calculate_theoretical_rtp(reels, paytable)</span><br><span class="line">    variance = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> combo <span class="keyword">in</span> paytable:</span><br><span class="line">        probability = calculate_combination_probability(combo, reels)</span><br><span class="line">        payout = combo.payout</span><br><span class="line">        variance += probability * (payout - expected_payout) ** <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> variance ** <span class="number">0.5</span>  <span class="comment"># 标准差作为波动性指标</span></span><br></pre></td></tr></table></figure>



<h4 id="赢利分布设计"><a href="#赢利分布设计" class="headerlink" title="赢利分布设计"></a>赢利分布设计</h4><p>赢利分布的设计是老虎机算法的关键部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinCategory</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    NO_WIN = <span class="number">0</span></span><br><span class="line">    SMALL_WIN = <span class="number">1</span></span><br><span class="line">    MEDIUM_WIN = <span class="number">2</span></span><br><span class="line">    BIG_WIN = <span class="number">3</span></span><br><span class="line">    HUGE_WIN = <span class="number">4</span></span><br><span class="line">    JACKPOT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WinDistributionTarget</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.target_percentages = &#123;</span><br><span class="line">            WinCategory.NO_WIN: <span class="number">50.0</span>,    <span class="comment"># 50%无赢利</span></span><br><span class="line">            WinCategory.SMALL_WIN: <span class="number">30.0</span>,  <span class="comment"># 30%小赢利</span></span><br><span class="line">            WinCategory.MEDIUM_WIN: <span class="number">15.0</span>, <span class="comment"># 15%中等赢利</span></span><br><span class="line">            WinCategory.BIG_WIN: <span class="number">4.0</span>,    <span class="comment"># 4%大赢利</span></span><br><span class="line">            WinCategory.HUGE_WIN: <span class="number">0.9</span>,    <span class="comment"># 0.9%巨大赢利</span></span><br><span class="line">            WinCategory.JACKPOT: <span class="number">0.1</span>      <span class="comment"># 0.1%头奖</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_percentage</span><span class="params">(self, category: WinCategory)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.target_percentages.get(category, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">ALLOWED_DEVIATION = <span class="number">0.5</span>  <span class="comment"># 允许0.5%的偏差</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_win_distribution</span><span class="params">(reels: List[<span class="string">'VirtualReel'</span>], </span></span></span><br><span class="line"><span class="function"><span class="params">                            paytable: List[<span class="string">'SymbolCombination'</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                            target: WinDistributionTarget)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    验证赢利分布是否符合设计目标</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        reels: 虚拟转轮列表</span></span><br><span class="line"><span class="string">        paytable: 赔付表</span></span><br><span class="line"><span class="string">        target: 赢利分布目标</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        bool: 是否通过验证</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 模拟大量旋转，记录各级别赢利的频率</span></span><br><span class="line">    win_counts = defaultdict(int)</span><br><span class="line">    simulation_count = <span class="number">1000000</span></span><br><span class="line">    </span><br><span class="line">    rng = SlotRNG()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(simulation_count):</span><br><span class="line">        result = simulate_spin(rng, reels)</span><br><span class="line">        win_amount = calculate_win(result, paytable)</span><br><span class="line">        category = categorize_win(win_amount)</span><br><span class="line">        win_counts[category] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查每个类别的实际分布是否接近目标</span></span><br><span class="line">    <span class="keyword">for</span> category, count <span class="keyword">in</span> win_counts.items():</span><br><span class="line">        actual_percentage = count / simulation_count * <span class="number">100</span></span><br><span class="line">        target_percentage = target.get_percentage(category)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> abs(actual_percentage - target_percentage) &gt; ALLOWED_DEVIATION:</span><br><span class="line">            print(<span class="string">f"验证失败: <span class="subst">&#123;category.name&#125;</span> 实际<span class="subst">&#123;actual_percentage:<span class="number">.2</span>f&#125;</span>% vs 目标<span class="subst">&#123;target_percentage:<span class="number">.2</span>f&#125;</span>%"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"赢利分布验证通过!"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_spin</span><span class="params">(rng: SlotRNG, reels: List[VirtualReel])</span> -&gt; SpinResult:</span></span><br><span class="line">    <span class="string">"""模拟一次旋转"""</span></span><br><span class="line">    result = SpinResult()</span><br><span class="line">    result.visible_symbols = [reel.get_random_symbol(rng) <span class="keyword">for</span> reel <span class="keyword">in</span> reels]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_win</span><span class="params">(result: SpinResult, paytable: List[SymbolCombination])</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""计算赢利金额"""</span></span><br><span class="line">    <span class="comment"># 简化实现 - 实际游戏会有更复杂的赢线计算</span></span><br><span class="line">    <span class="keyword">for</span> combo <span class="keyword">in</span> paytable:</span><br><span class="line">        <span class="keyword">if</span> result.visible_symbols == combo.symbols:</span><br><span class="line">            <span class="keyword">return</span> combo.payout</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">categorize_win</span><span class="params">(win_amount: int)</span> -&gt; WinCategory:</span></span><br><span class="line">    <span class="string">"""将赢利金额分类"""</span></span><br><span class="line">    <span class="keyword">if</span> win_amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> WinCategory.NO_WIN</span><br><span class="line">    <span class="keyword">elif</span> win_amount &lt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> WinCategory.SMALL_WIN</span><br><span class="line">    <span class="keyword">elif</span> win_amount &lt;= <span class="number">50</span>:</span><br><span class="line">        <span class="keyword">return</span> WinCategory.MEDIUM_WIN</span><br><span class="line">    <span class="keyword">elif</span> win_amount &lt;= <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> WinCategory.BIG_WIN</span><br><span class="line">    <span class="keyword">elif</span> win_amount &lt;= <span class="number">1000</span>:</span><br><span class="line">        <span class="keyword">return</span> WinCategory.HUGE_WIN</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> WinCategory.JACKPOT</span><br></pre></td></tr></table></figure>


<h4 id="热力学模型设计"><a href="#热力学模型设计" class="headerlink" title="热力学模型设计"></a>热力学模型设计</h4><p>一些现代老虎机采用热力学模型来控制玩家体验曲线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThermalModel</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cooling_rate: float = <span class="number">0.01</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                 heating_increment: float = <span class="number">0.001</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 max_temperature: float = <span class="number">100.0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 max_probability_boost: float = <span class="number">2.0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化热力学模型</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            cooling_rate: 温度下降速率 (默认0.01表示每帧下降1%)</span></span><br><span class="line"><span class="string">            heating_increment: 每次投注增加的温度量 (默认0.001)</span></span><br><span class="line"><span class="string">            max_temperature: 最高温度上限 (默认100.0)</span></span><br><span class="line"><span class="string">            max_probability_boost: 最大概率提升倍数 (默认2.0)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.temperature = <span class="number">0.0</span></span><br><span class="line">        self.cooling_rate = cooling_rate</span><br><span class="line">        self.heating_increment = heating_increment</span><br><span class="line">        self.max_temperature = max_temperature</span><br><span class="line">        self.max_probability_boost = max_probability_boost</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, bet_amount: float)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        更新系统温度</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        参数:</span></span><br><span class="line"><span class="string">            bet_amount: 当前投注金额</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 投注增加系统温度</span></span><br><span class="line">        self.temperature += self.heating_increment * bet_amount</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 随时间冷却</span></span><br><span class="line">        self.temperature *= (<span class="number">1.0</span> - self.cooling_rate)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 确保温度在有效范围内</span></span><br><span class="line">        self.temperature = max(<span class="number">0.0</span>, min(self.temperature, self.max_temperature))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jackpot_probability_factor</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取基于当前温度的大奖概率修正因子</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            float: 概率修正因子 (1.0表示基础概率，2.0表示双倍概率等)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 温度越高，大奖概率越大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span> + (self.temperature / self.max_temperature) * self.max_probability_boost</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_temperature_percentage</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取当前温度百分比 (0.0到1.0)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.temperature / self.max_temperature</span><br></pre></td></tr></table></figure>


<h4 id="特殊功能触发系统"><a href="#特殊功能触发系统" class="headerlink" title="特殊功能触发系统"></a>特殊功能触发系统</h4><p>免费游戏触发算法<br>免费游戏是老虎机中最常见的特殊功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">should_trigger_free_spins</span><span class="params">(result: SpinResult)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断是否应该触发免费游戏</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        result: 旋转结果</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        bool: 是否触发免费游戏</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    scatter_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> reel_symbols <span class="keyword">in</span> result.visible_symbols:</span><br><span class="line">        <span class="keyword">for</span> symbol <span class="keyword">in</span> reel_symbols:</span><br><span class="line">            <span class="keyword">if</span> symbol == Symbol.SCATTER:</span><br><span class="line">                scatter_count += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 通常3个或更多散布符号触发免费游戏</span></span><br><span class="line">    <span class="keyword">return</span> scatter_count &gt;= <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">determine_free_spin_count</span><span class="params">(scatter_count: int, rng: SlotRNG)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    确定免费游戏数量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        scatter_count: 散布符号数量</span></span><br><span class="line"><span class="string">        rng: 随机数生成器</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        int: 免费旋转次数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 基础免费游戏数量</span></span><br><span class="line">    <span class="keyword">if</span> scatter_count == <span class="number">3</span>:</span><br><span class="line">        base_spins = <span class="number">10</span></span><br><span class="line">    <span class="keyword">elif</span> scatter_count == <span class="number">4</span>:</span><br><span class="line">        base_spins = <span class="number">15</span></span><br><span class="line">    <span class="keyword">elif</span> scatter_count == <span class="number">5</span>:</span><br><span class="line">        base_spins = <span class="number">20</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  <span class="comment"># 不足3个散布符号，不触发免费游戏</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可能有额外奖励</span></span><br><span class="line">    bonus_spins = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> VARIABLE_FREE_SPINS_ENABLED:</span><br><span class="line">        <span class="comment"># 随机额外0-5次免费旋转</span></span><br><span class="line">        bonus_spins = rng.next(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> base_spins + bonus_spins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br></pre></td></tr></table></figure>


<h4 id="特殊符号行为算法"><a href="#特殊符号行为算法" class="headerlink" title="特殊符号行为算法"></a>特殊符号行为算法</h4><p>像Wild和扩展符号这样的特殊元素需要特定的处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_wild_symbols</span><span class="params">(original_grid: List[List[Symbol]])</span> -&gt; List[List[Symbol]]:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理各种Wild符号逻辑</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        original_grid: 原始符号网格</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        处理后的符号网格</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    processed_grid = [row.copy() <span class="keyword">for</span> row <span class="keyword">in</span> original_grid]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 扩展Wild处理</span></span><br><span class="line">    <span class="keyword">for</span> reel <span class="keyword">in</span> range(len(processed_grid)):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(processed_grid[reel])):</span><br><span class="line">            <span class="keyword">if</span> processed_grid[reel][row] == Symbol.EXPANDING_WILD:</span><br><span class="line">                <span class="comment"># 扩展到整个转轮</span></span><br><span class="line">                <span class="keyword">for</span> expand_row <span class="keyword">in</span> range(len(processed_grid[reel])):</span><br><span class="line">                    processed_grid[reel][expand_row] = Symbol.WILD</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment"># 已处理此转轮，跳至下一转轮</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 粘性Wild处理 (示例实现)</span></span><br><span class="line">    <span class="keyword">for</span> reel <span class="keyword">in</span> range(len(processed_grid)):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(processed_grid[reel])):</span><br><span class="line">            <span class="keyword">if</span> processed_grid[reel][row] == Symbol.STICKY_WILD:</span><br><span class="line">                <span class="comment"># 粘性Wild会保留在当前位置多轮旋转</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 行走Wild处理 (示例实现)</span></span><br><span class="line">    walking_wild_positions = []</span><br><span class="line">    <span class="keyword">for</span> reel <span class="keyword">in</span> range(len(processed_grid)):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(processed_grid[reel])):</span><br><span class="line">            <span class="keyword">if</span> processed_grid[reel][row] == Symbol.WALKING_WILD:</span><br><span class="line">                walking_wild_positions.append((reel, row))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> reel, row <span class="keyword">in</span> walking_wild_positions:</span><br><span class="line">        <span class="comment"># 行走Wild每次旋转移动一个位置</span></span><br><span class="line">        new_row = (row + <span class="number">1</span>) % len(processed_grid[reel])</span><br><span class="line">        processed_grid[reel][row] = Symbol.BLANK  <span class="comment"># 假设BLANK表示空白</span></span><br><span class="line">        processed_grid[reel][new_row] = Symbol.WALKING_WILD</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 乘数Wild处理 (示例实现)</span></span><br><span class="line">    <span class="keyword">for</span> reel <span class="keyword">in</span> range(len(processed_grid)):</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(processed_grid[reel])):</span><br><span class="line">            <span class="keyword">if</span> processed_grid[reel][row] == Symbol.MULTIPLIER_WILD:</span><br><span class="line">                <span class="comment"># 乘数Wild会增加赢利倍数</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> processed_grid</span><br></pre></td></tr></table></figure>


<h4 id="小游戏与奖金游戏触发"><a href="#小游戏与奖金游戏触发" class="headerlink" title="小游戏与奖金游戏触发"></a>小游戏与奖金游戏触发</h4><p>复杂的老虎机通常包含多种小游戏：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_and_trigger_bonus_game</span><span class="params">(result: SpinResult, rng: SlotRNG)</span> -&gt; BonusGame:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择并触发小游戏</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        result: 旋转结果</span></span><br><span class="line"><span class="string">        rng: 随机数生成器</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        BonusGame: 触发的小游戏对象</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    available_games = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查各种触发条件</span></span><br><span class="line">    <span class="keyword">if</span> has_bonus_symbol_combination(result):</span><br><span class="line">        available_games.append(BonusGameType.PICK_AND_WIN)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> has_jackpot_symbols(result):</span><br><span class="line">        available_games.append(BonusGameType.JACKPOT_WHEEL)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> has_special_pattern(result):</span><br><span class="line">        available_games.append(BonusGameType.SKILL_GAME)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果有多个可能的小游戏，选择一个</span></span><br><span class="line">    <span class="keyword">if</span> available_games:</span><br><span class="line">        <span class="keyword">if</span> PLAYER_CHOICE_ENABLED:</span><br><span class="line">            selected_type = present_choice_to_player(available_games)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            selected_type = select_bonus_game_by_strategy(available_games, rng)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> initialize_bonus_game(selected_type, result, rng)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 没有触发小游戏</span></span><br><span class="line">    <span class="keyword">return</span> BonusGame(BonusGameType.NONE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_bonus_symbol_combination</span><span class="params">(result: SpinResult)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""检查是否有奖金符号组合"""</span></span><br><span class="line">    bonus_count = sum(row.count(Symbol.BONUS) <span class="keyword">for</span> row <span class="keyword">in</span> result.visible_symbols)</span><br><span class="line">    <span class="keyword">return</span> bonus_count &gt;= <span class="number">3</span>  <span class="comment"># 假设3个或更多BONUS符号触发</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_jackpot_symbols</span><span class="params">(result: SpinResult)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""检查是否有Jackpot符号组合"""</span></span><br><span class="line">    jackpot_count = sum(row.count(Symbol.JACKPOT) <span class="keyword">for</span> row <span class="keyword">in</span> result.visible_symbols)</span><br><span class="line">    <span class="keyword">return</span> jackpot_count &gt;= <span class="number">2</span>  <span class="comment"># 假设2个或更多JACKPOT符号触发</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_special_pattern</span><span class="params">(result: SpinResult)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""检查是否有特殊图案"""</span></span><br><span class="line">    <span class="comment"># 简化的特殊图案检查逻辑</span></span><br><span class="line">    <span class="keyword">for</span> reel <span class="keyword">in</span> result.visible_symbols:</span><br><span class="line">        <span class="keyword">if</span> all(symbol == Symbol.WILD <span class="keyword">for</span> symbol <span class="keyword">in</span> reel):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">present_choice_to_player</span><span class="params">(available_games: List[BonusGameType])</span> -&gt; BonusGameType:</span></span><br><span class="line">    <span class="string">"""让玩家选择小游戏"""</span></span><br><span class="line">    print(<span class="string">"请选择要玩的小游戏:"</span>)</span><br><span class="line">    <span class="keyword">for</span> i, game_type <span class="keyword">in</span> enumerate(available_games, <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;i&#125;</span>. <span class="subst">&#123;game_type.name&#125;</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            choice = int(input(<span class="string">"请输入选择: "</span>)) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= choice &lt; len(available_games):</span><br><span class="line">                <span class="keyword">return</span> available_games[choice]</span><br><span class="line">            print(<span class="string">"无效选择，请重试"</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            print(<span class="string">"请输入数字"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_bonus_game_by_strategy</span><span class="params">(available_games: List[BonusGameType], rng: SlotRNG)</span> -&gt; BonusGameType:</span></span><br><span class="line">    <span class="string">"""根据策略选择小游戏"""</span></span><br><span class="line">    <span class="comment"># 简单实现: 随机选择</span></span><br><span class="line">    <span class="keyword">return</span> rng.choice(available_games)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_bonus_game</span><span class="params">(game_type: BonusGameType, result: SpinResult, rng: SlotRNG)</span> -&gt; BonusGame:</span></span><br><span class="line">    <span class="string">"""初始化选中的小游戏"""</span></span><br><span class="line">    print(<span class="string">f"触发小游戏: <span class="subst">&#123;game_type.name&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> BonusGame(game_type)</span><br></pre></td></tr></table></figure>


<h4 id="高级优化算法"><a href="#高级优化算法" class="headerlink" title="高级优化算法"></a>高级优化算法</h4><p>符号评估优化<br>高效计算赢线是性能关键点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_wins_optimized</span><span class="params">(grid: List[List[Symbol]], </span></span></span><br><span class="line"><span class="function"><span class="params">                          paylines: List[PayLine], </span></span></span><br><span class="line"><span class="function"><span class="params">                          paytable: PayTable)</span> -&gt; WinResult:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    优化的赢线评估算法</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        grid: 符号网格 (reels x rows)</span></span><br><span class="line"><span class="string">        paylines: 所有赢线</span></span><br><span class="line"><span class="string">        paytable: 赔付表</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        WinResult: 包含所有赢利结果</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = WinResult()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 预处理 - 创建符号位置查找表</span></span><br><span class="line">    symbol_positions: DefaultDict[Symbol, List[Position]] = defaultdict(list)</span><br><span class="line">    <span class="keyword">for</span> reel_idx, reel <span class="keyword">in</span> enumerate(grid):</span><br><span class="line">        <span class="keyword">for</span> row_idx, symbol <span class="keyword">in</span> enumerate(reel):</span><br><span class="line">            symbol_positions[symbol].append(Position(reel_idx, row_idx))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对每个可能获奖的符号只处理一次</span></span><br><span class="line">    <span class="keyword">for</span> symbol, positions <span class="keyword">in</span> symbol_positions.items():</span><br><span class="line">        <span class="keyword">if</span> symbol == Symbol.BLANK:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查此符号在每条赢线上的状态</span></span><br><span class="line">        <span class="keyword">for</span> payline <span class="keyword">in</span> paylines:</span><br><span class="line">            consecutive_count = count_consecutive_symbols(grid, payline, symbol)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> consecutive_count &gt;= <span class="number">3</span>:  <span class="comment"># 假设最小赢线为3连</span></span><br><span class="line">                win_amount = paytable.get_payout_amount(symbol, consecutive_count)</span><br><span class="line">                <span class="keyword">if</span> win_amount &gt; <span class="number">0</span>:</span><br><span class="line">                    result.add_win(payline, symbol, consecutive_count, win_amount)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_consecutive_symbols</span><span class="params">(grid: List[List[Symbol]], </span></span></span><br><span class="line"><span class="function"><span class="params">                             payline: PayLine, </span></span></span><br><span class="line"><span class="function"><span class="params">                             symbol: Symbol)</span> -&gt; int:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算赢线上连续相同符号的数量</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        grid: 符号网格</span></span><br><span class="line"><span class="string">        payline: 赢线</span></span><br><span class="line"><span class="string">        symbol: 要检查的符号</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        int: 连续相同符号的数量</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> position <span class="keyword">in</span> payline.positions:</span><br><span class="line">        <span class="keyword">if</span> grid[position.reel][position.row] <span class="keyword">in</span> (symbol, Symbol.WILD):  <span class="comment"># Wild可以替代其他符号</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 连续中断</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h4 id="并行计算与分布式系统"><a href="#并行计算与分布式系统" class="headerlink" title="并行计算与分布式系统"></a>并行计算与分布式系统</h4><p>对于大型模拟和分析，并行计算至关重要：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simulate_spin</span><span class="params">(rng: SlotRNG, reels: List[List[Symbol]])</span> -&gt; SpinResult:</span></span><br><span class="line">    <span class="string">"""模拟一次旋转"""</span></span><br><span class="line">    result = SpinResult()</span><br><span class="line">    <span class="keyword">for</span> reel <span class="keyword">in</span> reels:</span><br><span class="line">        stop_pos = rng.next(<span class="number">0</span>, len(reel)<span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># 获取可见符号(假设显示3行)</span></span><br><span class="line">        visible = [reel[(stop_pos+i) % len(reel)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">        result.visible_symbols.append(visible)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate_win</span><span class="params">(result: SpinResult, pay_table: PayTable)</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""评估赢利金额"""</span></span><br><span class="line">    <span class="comment"># 简化的赢线评估(只检查第一条水平线)</span></span><br><span class="line">    line_symbols = [reel[<span class="number">1</span>] <span class="keyword">for</span> reel <span class="keyword">in</span> result.visible_symbols]  <span class="comment"># 中间行</span></span><br><span class="line">    <span class="keyword">return</span> pay_table.get_payout(line_symbols)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_variance</span><span class="params">(results: List[float], mean: float)</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""计算方差"""</span></span><br><span class="line">    <span class="keyword">return</span> statistics.variance(results) <span class="keyword">if</span> len(results) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_simulation</span><span class="params">(config: SlotGameConfiguration, sims: int, seed: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="string">"""工作线程的模拟任务"""</span></span><br><span class="line">    rng = SlotRNG(seed)</span><br><span class="line">    total_bet = <span class="number">0.0</span></span><br><span class="line">    total_win = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(sims):</span><br><span class="line">        result = simulate_spin(rng, config.reels)</span><br><span class="line">        win = evaluate_win(result, config.pay_table)</span><br><span class="line">        total_bet += config.bet_amount</span><br><span class="line">        total_win += win</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total_win / total_bet <span class="keyword">if</span> total_bet &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallel_rtp_validation</span><span class="params">(config: SlotGameConfiguration, simulation_count: int)</span>:</span></span><br><span class="line">    <span class="string">"""并行RTP验证"""</span></span><br><span class="line">    <span class="comment"># 确定线程数(不超过CPU核心数)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        threads = min(<span class="number">8</span>, os.cpu_count() <span class="keyword">or</span> <span class="number">1</span>)  <span class="comment"># 限制最大8线程</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        threads = <span class="number">4</span></span><br><span class="line">    </span><br><span class="line">    sims_per_thread = simulation_count // threads</span><br><span class="line">    remaining = simulation_count % threads</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">f"使用 <span class="subst">&#123;threads&#125;</span> 个线程并行模拟，每个线程 <span class="subst">&#123;sims_per_thread&#125;</span> 次..."</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=threads) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 分配任务</span></span><br><span class="line">        futures = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(threads):</span><br><span class="line">            <span class="comment"># 最后一个线程处理剩余模拟次数</span></span><br><span class="line">            count = sims_per_thread + (remaining <span class="keyword">if</span> i == threads<span class="number">-1</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            futures.append(</span><br><span class="line">                executor.submit(worker_simulation, config, count, i+<span class="number">1</span>)</span><br><span class="line">            )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 收集结果</span></span><br><span class="line">        results = []</span><br><span class="line">        total_rtp = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">            thread_rtp = future.result()</span><br><span class="line">            results.append(thread_rtp)</span><br><span class="line">            total_rtp += thread_rtp</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算统计信息</span></span><br><span class="line">    average_rtp = total_rtp / threads</span><br><span class="line">    std_dev = np.sqrt(calculate_variance(results, average_rtp)) <span class="keyword">if</span> len(results) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    print(<span class="string">f"\n模拟结果 (总旋转次数: <span class="subst">&#123;simulation_count&#125;</span>):"</span>)</span><br><span class="line">    print(<span class="string">f"平均 RTP: <span class="subst">&#123;average_rtp*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%"</span>)</span><br><span class="line">    print(<span class="string">f"标准差: <span class="subst">&#123;std_dev*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%"</span>)</span><br><span class="line">    print(<span class="string">f"各线程 RTP: <span class="subst">&#123;[round(r*<span class="number">100</span>,<span class="number">2</span>) <span class="keyword">for</span> r <span class="keyword">in</span> results]&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>


<h4 id="巨型奖池管理"><a href="#巨型奖池管理" class="headerlink" title="巨型奖池管理"></a>巨型奖池管理</h4><p>累进式奖池需要特殊的算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProgressiveJackpotSystem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tiers)</span>:</span></span><br><span class="line">        self.tiers = tiers</span><br><span class="line">        self.reserve_pool = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_contribution</span><span class="params">(self, bet_amount)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> tier <span class="keyword">in</span> self.tiers:</span><br><span class="line">            contribution = bet_amount * tier.contribution_rate</span><br><span class="line">            tier.current_amount += contribution * <span class="number">0.7</span></span><br><span class="line">            self.reserve_pool += contribution * <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_jackpot_trigger</span><span class="params">(self, rng, bet_amount)</span>:</span></span><br><span class="line">        result = JackpotResult()</span><br><span class="line">        result.triggered = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, tier <span class="keyword">in</span> enumerate(self.tiers):</span><br><span class="line">            adjusted_probability = calculate_adjusted_probability(tier, bet_amount)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> rng.next(<span class="number">0</span>, <span class="number">1</span>) &lt; adjusted_probability:</span><br><span class="line">                result.triggered = <span class="literal">True</span></span><br><span class="line">                result.tier_index = i</span><br><span class="line">                result.amount = tier.current_amount</span><br><span class="line"></span><br><span class="line">                tier.last_hit_timestamp = time.time()</span><br><span class="line"></span><br><span class="line">                reset_amount = max(tier.seed_amount, min(self.reserve_pool, tier.seed_amount * <span class="number">2</span>))</span><br><span class="line">                tier.current_amount = reset_amount</span><br><span class="line">                self.reserve_pool -= (reset_amount - tier.seed_amount)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="合规与安全考量"><a href="#合规与安全考量" class="headerlink" title="合规与安全考量"></a>合规与安全考量</h4><p>合规验证算法<br>确保游戏符合各司法管辖区的法规：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_regulatory_compliance</span><span class="params">(config, requirements)</span>:</span></span><br><span class="line">    theoretical_rtp = calculate_theoretical_rtp(config)</span><br><span class="line">    <span class="keyword">if</span> theoretical_rtp &lt; requirements.min_rtp <span class="keyword">or</span> theoretical_rtp &gt; requirements.max_rtp:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    max_possible_win = find_max_possible_win(config)</span><br><span class="line">    <span class="keyword">if</span> max_possible_win &gt; requirements.max_win_multiplier * config.max_bet:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    cycle_period = calculate_minimum_cycle_period(config)</span><br><span class="line">    <span class="keyword">if</span> cycle_period &lt; requirements.min_cycle_period:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> requirements.near_miss_restrictions <span class="keyword">and</span> has_prohibited_near_miss(config):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他特定司法管辖区的规定...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h4 id="反作弊与安全措施"><a href="#反作弊与安全措施" class="headerlink" title="反作弊与安全措施"></a>反作弊与安全措施</h4><p>防止黑客和作弊行为的算法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecuritySystem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.game_history = []</span><br><span class="line">        self.crypto = CryptoProvider()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_game_integrity</span><span class="params">(self, session_id, spin_id)</span>:</span></span><br><span class="line">        record = next((record <span class="keyword">for</span> record <span class="keyword">in</span> self.game_history <span class="keyword">if</span> record.session_id == session_id <span class="keyword">and</span> record.spin_id == spin_id), <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> record:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        computed_hash = self.calculate_result_hash(record)</span><br><span class="line">        <span class="keyword">return</span> computed_hash == record.integrity_hash</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect_anomalies</span><span class="params">(self, session_id)</span>:</span></span><br><span class="line">        report = SuspiciousActivityReport()</span><br><span class="line"></span><br><span class="line">        session_records = [record <span class="keyword">for</span> record <span class="keyword">in</span> self.game_history <span class="keyword">if</span> record.session_id == session_id]</span><br><span class="line"></span><br><span class="line">        report.unusual_win_patterns = detect_unusual_win_patterns(session_records)</span><br><span class="line">        report.rng_anomalies = detect_rng_anomalies(session_records)</span><br><span class="line">        report.timing_anomalies = detect_timing_anomalies(session_records)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 其他安全检查...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> report</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_result_hash</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        data_to_hash = <span class="string">f"<span class="subst">&#123;record.session_id&#125;</span>|<span class="subst">&#123;record.spin_id&#125;</span>|<span class="subst">&#123;record.rng_seed&#125;</span>|<span class="subst">&#123;serialize_result(record.result)&#125;</span>|<span class="subst">&#123;record.win:<span class="number">.6</span>f&#125;</span>|<span class="subst">&#123;record.timestamp&#125;</span>"</span></span><br><span class="line">        <span class="keyword">return</span> self.crypto.compute_hash(data_to_hash)</span><br></pre></td></tr></table></figure>


<h4 id="模拟测试与验证系统"><a href="#模拟测试与验证系统" class="headerlink" title="模拟测试与验证系统"></a>模拟测试与验证系统</h4><p>蒙特卡洛模拟<br>大规模模拟是验证老虎机设计的关键：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotSimulationSystem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, config, simulation_count=<span class="number">10000000000</span>, threads=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.config = config</span><br><span class="line">        self.simulation_count = simulation_count</span><br><span class="line">        self.thread_count = threads <span class="keyword">or</span> os.cpu_count()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_full_simulation</span><span class="params">(self)</span>:</span></span><br><span class="line">        results = SimulationResults()</span><br><span class="line">        results.start_time = time.time()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> ThreadPoolExecutor(max_workers=self.thread_count) <span class="keyword">as</span> executor:</span><br><span class="line">            futures = [executor.submit(self.simulate_on_thread, sims_per_thread, t) <span class="keyword">for</span> t <span class="keyword">in</span> range(self.thread_count)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">            thread_results = future.result()</span><br><span class="line">            results.total_bet += thread_results.total_bet</span><br><span class="line">            results.total_win += thread_results.total_win</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> thread_results.feature_trigger_counts.items():</span><br><span class="line">                results.feature_trigger_counts[key] += value</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> thread_results.win_distribution.items():</span><br><span class="line">                results.win_distribution[key] += value</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> thread_results.max_win &gt; results.max_win:</span><br><span class="line">                results.max_win = thread_results.max_win</span><br><span class="line">                results.max_win_details = thread_results.max_win_details</span><br><span class="line"></span><br><span class="line">        results.end_time = time.time()</span><br><span class="line">        results.actual_rtp = results.total_win / results.total_bet</span><br><span class="line">        results.simulation_time = results.end_time - results.start_time</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simulate_on_thread</span><span class="params">(self, sim_count, thread_id)</span>:</span></span><br><span class="line">        results = ThreadSimResults()</span><br><span class="line">        rng = SlotRNG()</span><br><span class="line">        rng.seed += thread_id</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(sim_count):</span><br><span class="line">            spin_result = simulate_spin(rng, self.config)</span><br><span class="line">            win = evaluate_win(spin_result, self.config)</span><br><span class="line"></span><br><span class="line">            results.total_bet += self.config.bet_amount</span><br><span class="line">            results.total_win += win</span><br><span class="line"></span><br><span class="line">            category = categorize_win(win, self.config.bet_amount)</span><br><span class="line">            results.win_distribution[category] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            track_feature_triggers(spin_result, results.feature_trigger_counts)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> win &gt; results.max_win:</span><br><span class="line">                results.max_win = win</span><br><span class="line">                results.max_win_details = spin_result</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> _ % <span class="number">1000000000</span> == <span class="number">0</span> <span class="keyword">and</span> _ &gt; <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">f"Thread <span class="subst">&#123;thread_id&#125;</span>: <span class="subst">&#123;_ // <span class="number">1000000000</span>&#125;</span> billion spins completed"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h4 id="极端情况与边缘案例测试"><a href="#极端情况与边缘案例测试" class="headerlink" title="极端情况与边缘案例测试"></a>极端情况与边缘案例测试</h4><p>测试罕见场景和边缘情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_edge_cases</span><span class="params">(config)</span>:</span></span><br><span class="line">    <span class="comment"># 测试最高赢利组合</span></span><br><span class="line">    max_win_setup = create_max_win_scenario(config)</span><br><span class="line">    win = evaluate_win(max_win_setup, config)</span><br><span class="line">    print(<span class="string">f"Maximum theoretical win: <span class="subst">&#123;win&#125;</span> (multiplier: <span class="subst">&#123;win / config.bet_amount:<span class="number">.2</span>f&#125;</span>x)"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试特殊功能级联</span></span><br><span class="line">    cascading_features = create_cascading_features_scenario(config)</span><br><span class="line">    cascade = simulate_feature_cascade(cascading_features, config)</span><br><span class="line">    print(<span class="string">f"Maximum feature cascade depth: <span class="subst">&#123;cascade.depth&#125;</span> with total win: <span class="subst">&#123;cascade.total_win&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试边缘RTP情况</span></span><br><span class="line">    sensitivity = analyze_rtp_sensitivity(config)</span><br><span class="line">    print(<span class="string">f"Most sensitive parameter: <span class="subst">&#123;sensitivity.most_sensitive_param&#125;</span> with impact of <span class="subst">&#123;sensitivity.max_impact:<span class="number">.2</span>f&#125;</span>%"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 测试极端长度的游戏会话</span></span><br><span class="line">    long_session = simulate_long_player_session(config)</span><br><span class="line">    print(<span class="string">f"Long session results: RTP convergence after <span class="subst">&#123;long_session.convergence_spins&#125;</span> spins to <span class="subst">&#123;long_session.converged_rtp:<span class="number">.2</span>f&#125;</span>%"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>老虎机的核心算法是一个精密的数学和软件工程系统，结合了随机数生成、概率分布、经济模型和游戏设计原则。现代老虎机的复杂性远超表面所见，需要大量的数学验证和技术优化才能创造既公平又有吸引力的游戏体验。</p>
<p>作为一名资深的Slots游戏开发，深入理解这些算法原理并确保它们的正确实现，对于创造成功的游戏产品至关重要。通过精心设计的核心算法，我们可以在保证游戏公平性和合规性的同时，为玩家提供引人入胜的娱乐体验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/06/26/2025-06-26/" data-id="cmcw2i8ga0003isz89lxfdn5z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" rel="tag">Slot, 老虎机，游戏研究</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-31" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/31/2020-01-31/" class="article-date">
  <time datetime="2020-01-31T12:53:32.000Z" itemprop="datePublished">2020-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/31/2020-01-31/">三消游戏的一些算法总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code>•    &quot;如何表示消除游戏的棋盘？&quot;
•    &quot;怎样检测相邻的相同元素？&quot;

•    &quot;如何实现消除后自动补全棋盘效果？
•    &quot;如何实现消除后自动生成新元素效果？&quot;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 消除游戏棋盘表示</span><br><span class="line">	int[,] board &#x3D; new int[8, 8]; &#x2F;&#x2F; 0表示空位，1-6表示不同颜色</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 检测相邻相同元素</span><br><span class="line">	bool HasMatch(int[,] grid, int x, int y) &#123;</span><br><span class="line">	    int color &#x3D; grid[x, y];</span><br><span class="line">	    &#x2F;&#x2F; 检查水平方向</span><br><span class="line">	    if (x &gt; 0 &amp;&amp; grid[x-1, y] &#x3D;&#x3D; color &amp;&amp; x &lt; grid.GetLength(0)-1 &amp;&amp; grid[x+1, y] &#x3D;&#x3D; color)</span><br><span class="line">	        return true;</span><br><span class="line">	    &#x2F;&#x2F; 检查垂直方向</span><br><span class="line">	    if (y &gt; 0 &amp;&amp; grid[x, y-1] &#x3D;&#x3D; color &amp;&amp; y &lt; grid.GetLength(1)-1 &amp;&amp; grid[x, y+1] &#x3D;&#x3D; color)</span><br><span class="line">	        return true;</span><br><span class="line">	    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

•    &quot;如何实现三消游戏中的特殊连锁反应效果？&quot;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 连锁反应节点</span><br><span class="line">public class ChainNode &#123;</span><br><span class="line">    public Vector2Int Position;</span><br><span class="line">    public ChainNode Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理连锁反应</span><br><span class="line">void ProcessChain(ChainNode head) &#123;</span><br><span class="line">    while (head !&#x3D; null) &#123;</span><br><span class="line">        RemoveTile(head.Position);</span><br><span class="line">        ApplySpecialEffect(head.Position);</span><br><span class="line">        head &#x3D; head.Next;</span><br><span class="line">        yield return new WaitForSeconds(0.3f); &#x2F;&#x2F; 动画间隔</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>“如何检测棋盘上的所有可消除组合？”</p>
<p>“怎样实现特殊消除效果（如L型/T型消除）？”<br>// 检测所有匹配项<br>List<Vector2Int> FindAllMatches(int[,] grid) {<br>    var matches = new List<Vector2Int>();<br>    int width = grid.GetLength(0);<br>    int height = grid.GetLength(1);</p>
<pre><code>// 水平检测
for (int y = 0; y &lt; height; y++) {
    for (int x = 0; x &lt; width - 2; x++) {
        if (grid[x, y] &gt; 0 &amp;&amp; 
            grid[x, y] == grid[x+1, y] &amp;&amp; 
            grid[x, y] == grid[x+2, y]) {
            matches.Add(new Vector2Int(x, y));
            matches.Add(new Vector2Int(x+1, y));
            matches.Add(new Vector2Int(x+2, y));
        }
    }
}

// 垂直检测（类似逻辑）
// ...

return matches.Distinct().ToList();</code></pre><p>}</p>
<p>问题：”如何实现随着玩家水平变化的难度系统？”</p>
<p>public class DifficultyAdjuster {<br>    private float playerSuccessRate;<br>    private int gamesPlayed;</p>
<pre><code>public int GetAdjustedLevel(int baseLevel) {
    float difficultyFactor = Mathf.Clamp(1.5f - playerSuccessRate, 0.5f, 2f);
    return Mathf.RoundToInt(baseLevel * difficultyFactor);
}

public void UpdateSuccess(bool levelPassed) {
    gamesPlayed++;
    playerSuccessRate = (playerSuccessRate * (gamesPlayed - 1) + (levelPassed ? 1 : 0)) / gamesPlayed;
}</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/31/2020-01-31/" data-id="cmcvp1llh000g0mz86wwianfo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-01-30" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/30/2020-01-30/" class="article-date">
  <time datetime="2020-01-30T12:53:28.000Z" itemprop="datePublished">2020-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/01/30/2020-01-30/">洗牌算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原理：遍历所有牌（52+大小王），每张牌随机一个小于54的数，交换当前遍历的index和随机数对应数组下标的值。random 方法为伪随机，并非等概率随机。<br>c#实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">　　private static void Shuffle ()  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F; 扑克牌初始化   </span><br><span class="line">    List&lt;string&gt; allCard &#x3D; new List&lt;string&gt;();  </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 54; i++) &#123;  </span><br><span class="line">         allCard.Add(i); </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 定义随机数  </span><br><span class="line">    Random random &#x3D; new Random ();  </span><br><span class="line">    &#x2F;&#x2F; 从数组的最后一个数开始递减  </span><br><span class="line">    for (int i &#x3D; allCard.Count - 1; i &gt; 0; i--) &#123;  </span><br><span class="line">        &#x2F;&#x2F; 随机下标  </span><br><span class="line">        int index &#x3D; random.Next (0, i);  </span><br><span class="line">        &#x2F;&#x2F; 随机出来的数与最后位置的数交换  </span><br><span class="line">        string temp &#x3D; allCard [i];  </span><br><span class="line">        allCard [i] &#x3D; allCard [index];  </span><br><span class="line">        allCard [index] &#x3D; temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    foreach (string item in allCard) &#123;  </span><br><span class="line">        Console.WriteLine (item);  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>获取牌类型：数组值除以13是否大于4，是则是大小王，否则为普通牌<br>c#实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">　　for (int i &#x3D; 0; i &lt; allCard.Count; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (allCard [i] &#x2F; 13 &gt; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        if (allCard [i] % 4 &#x3D;&#x3D; 1)</span><br><span class="line">           &#123;</span><br><span class="line">                &#x2F;&#x2F;小王</span><br><span class="line">           &#125;</span><br><span class="line">           else</span><br><span class="line">           &#123;</span><br><span class="line">                &#x2F;大王</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;cardType为0时为黑桃，以次类推，cardNum代表A到K，可以以cardType_cardNum作为牌图片索引。</span><br><span class="line">        int cardType &#x3D; allCard [i] &#x2F; 13;</span><br><span class="line">        int cardNum &#x3D; allCard [i] % 13;</span><br><span class="line">    &#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2020/01/30/2020-01-30/" data-id="cmcw1g2uo002wz4z83n43fb4f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assetbundle/" rel="tag">Assetbundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/" rel="tag">IOC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shader/" rel="tag">Shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" rel="tag">Slot, 老虎机，游戏研究</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UGUI/" rel="tag">UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-C/" rel="tag">Unity, C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" rel="tag">Unity, UI框架, UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity%EF%BC%8CAssetBundle/" rel="tag">Unity，AssetBundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gameframework/" rel="tag">gameframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-server/" rel="tag">http.server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" rel="tag">slot, 老虎机, slot game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity-python/" rel="tag">unity python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlua-lua-framework/" rel="tag">xlua, lua, framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%B1%E5%BF%97/" rel="tag">励志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" rel="tag">物理引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">程序员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/Assetbundle/" style="font-size: 10px;">Assetbundle</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" style="font-size: 10px;">Slot, 老虎机，游戏研究</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/UGUI/" style="font-size: 11.67px;">UGUI</a> <a href="/tags/Unity/" style="font-size: 18.33px;">Unity</a> <a href="/tags/Unity-C/" style="font-size: 10px;">Unity, C#</a> <a href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" style="font-size: 10px;">Unity, UI框架, UGUI</a> <a href="/tags/Unity%EF%BC%8CAssetBundle/" style="font-size: 10px;">Unity，AssetBundle</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/gameframework/" style="font-size: 10px;">gameframework</a> <a href="/tags/http-server/" style="font-size: 10px;">http.server</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/mysql/" style="font-size: 13.33px;">mysql</a> <a href="/tags/python/" style="font-size: 13.33px;">python</a> <a href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" style="font-size: 10px;">slot, 老虎机, slot game</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/unity/" style="font-size: 16.67px;">unity</a> <a href="/tags/unity-python/" style="font-size: 10px;">unity python</a> <a href="/tags/xlua-lua-framework/" style="font-size: 11.67px;">xlua, lua, framework</a> <a href="/tags/%E5%8A%B1%E5%BF%97/" style="font-size: 10px;">励志</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" style="font-size: 10px;">物理引擎</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 10px;">程序员</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.67px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 20px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.67px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/13/2025-07-13/">简单的服务器搭建</a>
          </li>
        
          <li>
            <a href="/2025/07/11/2025-07-11/">框架之日志管理系统</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-12/">unity 一键打包</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-10/">Unity UI框架总结</a>
          </li>
        
          <li>
            <a href="/2025/07/09/2025-07-09/">Unity 打android 包报错总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 OuyangWenyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>