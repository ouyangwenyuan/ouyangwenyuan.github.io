<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>编程中的基本数据结构与算法思想 | 持续学习者————Just Do It！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。描述问题的数据除了各数据元素本身，还要考虑各元素的逻辑关系，主要是一对一的线性关系，一对多的树型关系和多对多的图形关系。另外，内存中对各数据元素的存储只有顺序存储和链式存储两种方式，所以数据结构还要考虑数据的存储结构，并考虑逻辑结构与数据结构如何有效地结合到一起。 用算法描述问题，当问题比较复杂时，通常的思路">
<meta property="og:type" content="article">
<meta property="og:title" content="编程中的基本数据结构与算法思想">
<meta property="og:url" content="http://droidman.net/2017/04/16/2017-04-16/index.html">
<meta property="og:site_name" content="持续学习者————Just Do It！">
<meta property="og:description" content="编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。描述问题的数据除了各数据元素本身，还要考虑各元素的逻辑关系，主要是一对一的线性关系，一对多的树型关系和多对多的图形关系。另外，内存中对各数据元素的存储只有顺序存储和链式存储两种方式，所以数据结构还要考虑数据的存储结构，并考虑逻辑结构与数据结构如何有效地结合到一起。 用算法描述问题，当问题比较复杂时，通常的思路">
<meta property="og:locale" content="en,ZH">
<meta property="article:published_time" content="2017-04-16T00:34:20.000Z">
<meta property="article:modified_time" content="2017-04-22T01:24:42.389Z">
<meta property="article:author" content="OuyangWenyuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Objective-c">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Unity3d">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="Program">
<meta property="article:tag" content="Mac OS">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="Window">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="xcode">
<meta property="article:tag" content="IDEA">
<meta property="article:tag" content="eclicpse">
<meta property="article:tag" content="blender">
<meta property="article:tag" content="MVC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="持续学习者————Just Do It！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">持续学习者————Just Do It！</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学无止境————不怕你不会，就怕你不学！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://droidman.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2017-04-16" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/16/2017-04-16/" class="article-date">
  <time datetime="2017-04-16T00:34:20.000Z" itemprop="datePublished">2017-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      编程中的基本数据结构与算法思想
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。"><a href="#编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。" class="headerlink" title="编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。"></a>编程的关键在于选择数据结构和算法，数据结构用于描述问题，算法用于描述解决问题的方法和步骤。</h6><p>描述问题的数据除了各数据元素本身，还要考虑各元素的逻辑关系，主要是一对一的线性关系，一对多的树型关系和多对多的图形关系。另外，内存中对各数据元素的存储只有顺序存储和链式存储两种方式，所以数据结构还要考虑数据的存储结构，并考虑逻辑结构与数据结构如何有效地结合到一起。</p>
<h6 id="用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。"><a href="#用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。" class="headerlink" title="用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。"></a>用算法描述问题，当问题比较复杂时，通常的思路是分而治之，并辅以适当的数据结构。</h6><h5 id="1-分治法Divide-and-Conquer"><a href="#1-分治法Divide-and-Conquer" class="headerlink" title="1 分治法Divide and Conquer"></a>1 分治法Divide and Conquer</h5><p>分治法通常描述为以下三步：</p>
<ol>
<li><p>Divide the problem into more subproblems（分解问题为众多的子问题）;</p>
</li>
<li><p>Conuqe(solve) the subproblems（解决各子问题）;</p>
</li>
<li><p>Combine(merge) the solution of subproblems(if need)（合并各子问题的解（如果需要））.</p>
</li>
</ol>
<p>如用分治法来计算2^10?</p>
<p>2^10＝2^5<em>x^5=2^2</em>x^3<em>x^5=32</em>32=1024</p>
<a id="more"></a>

<p>相对于顺序查找，二分查找有更高的效率，前提是二分查找需要事先排好序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchLoop</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len, <span class="keyword">int</span> findData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || len &lt;=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">end</span> = len<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span>(start&lt;=<span class="built_in">end</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = start+(<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == findData)</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(findData &lt; arr[mid])</span><br><span class="line">      <span class="built_in">end</span> = mid<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      start = mid+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-枚举法也是一种暴力缩小问题规模的算法"><a href="#2-枚举法也是一种暴力缩小问题规模的算法" class="headerlink" title="2 枚举法也是一种暴力缩小问题规模的算法"></a>2 枚举法也是一种暴力缩小问题规模的算法</h5><p> <br>简单的枚举算法也是可以优化的，即尽可能缩小搜索的空间，如判断质数：</p>
<blockquote>
<p>质数（prime number）又称素数，有无限个。质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。</p>
</blockquote>
<p>判断质数的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;= <span class="number">1</span>)<span class="comment">// 小于等于1的整数不可能是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(n == <span class="number">2</span>); <span class="comment">// 2 是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 能被2整除的其他整数都不是素数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> limit = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)n)+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= limit; i=i+<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="number">1.</span> 只要发现任何一个大于<span class="number">1</span>小于n的因子，就能停下来报告n不是素数。</span><br><span class="line"> <span class="number">2.</span> 如果n能被<span class="number">2</span>整除，直接报告n不是素数。如果n不能被<span class="number">2</span>整除，那么它也不可能被<span class="number">4</span>或<span class="number">6</span>或其他偶数整除。因此，isPrime只需要检查<span class="number">2</span>和奇数（由<span class="number">3</span>开始，步长为<span class="number">2</span>）。但注意有个特例，<span class="number">2</span>能被<span class="number">2</span>整除，但<span class="number">2</span>是素数。</span><br><span class="line"> <span class="number">3.</span> 如果n不是素数，则必有一个因子小于√n 。因此不需要检查到n为止。只需检查到√n（n=√n*√n） 。</span><br></pre></td></tr></table></figure>
<p>因为如果n能被2~n-1之间任一整数整除，其二个因子必定有一个小于或等于√n，另一个大于或等于√n。例如24可以表示为：2<em>12、3</em>8、4*6，前面的因子小于√24，后面的因子大于√24，检验出了小因子，即可判断n是否为素数，就像逻辑运算的短路求值。
 </p>
<h5 id="3-程序的模块化"><a href="#3-程序的模块化" class="headerlink" title="3 程序的模块化"></a>3 程序的模块化</h5><p> <br>分治法在程序思想中的应用就是实现程序的模块化，包括面向过程的函数化和面向对象的对象化。 <br> <br>许多原因都促使我们将应用程序分解成函数，下面仅列举其中三个：<br> <br>函数一般小而具体。用一系列函数来写程序，胜于一气呵成写完整个程序。这称为“分而治之”，使你的精力一次集中在一个函数上。<br> <br>包含许多小函数的应用程序比单一的长程序更容易阅读和调试。<br> <br>函数可以重用。函数写好后可在程序的其他任何地方调用。这减少了编码量，提高了开发效率。 
 </p>
<h5 id="4-函数调用与栈"><a href="#4-函数调用与栈" class="headerlink" title="4 函数调用与栈"></a>4 函数调用与栈</h5><p> <br>首先讨论一个从a点出发去f点，然后回到a点的问题（中间的b、c、d、e都有多个分岔口）：<br> <br>a→b2→c1→d3→e2→f，每个分岔口都有一个信封，告诉你应该走哪一个分支，为了能够正确地回到起点a，正确的做法是拿到一个信封后，即将这个信封叠在上一次拿到的信封的上面，回去时，依次从上面拿取信封，按提示即可正确返回。 <br> <br>其做法就是依次放入，依次取出，信封之间是顺序关系，只在一端操作，也就是不管是放入还是取出都不在中间操作。这样一种思路在计算机上用数据来描述就是后进先出的栈，函数的调用、返回，递归、回溯算法都需要使用栈这种数据结构（由程序员或递归时由编译器来实现）。<br> <br>在C++中，函数不能嵌套定义，但可以嵌套调用，在函数调用时，编译器需要确保在逐级调用后能够回归到最初的调用点，编译器会隐式实现一个堆栈，用来保存每一级函数调用时的函数返回地址和局部变量，依次入栈和出栈。<br> <br>C++也支持递归函数的递归调用，同样是由编译器隐式地实现了一个堆栈。
 </p>
<h5 id="5-深度搜索与广度搜索"><a href="#5-深度搜索与广度搜索" class="headerlink" title="5 深度搜索与广度搜索"></a>5 深度搜索与广度搜索</h5><p> <br>如果将上述的问题稍微扩展一点，要从源点到目标点，中间的节点可能有多个分叉，这样的问题可以用一个树或图来描述。<br>而探路的方法可以分为两种，一种是深度优先搜索（下一点、下一点……回溯……），一种是广度优先搜索（下一点的全部分叉、下一点的全部分叉……）：
 </p>
<ol>
<li><p>深度优先搜索用栈（stack）来实现，整个过程可以想象成一个倒立的树形：</p>
<p> 1）把根节点压入栈中。<br> 2）每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。<br> 3）找到所要找的元素时结束程序。<br> 4）如果遍历整个树还没有找到，结束程序。</p>
</li>
<li><p>广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：</p>
<p> 1）把根节点放到队列的末尾。<br> 2）每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。（取出的元素也可以保存到一个队列）<br> 3）找到所要找的元素时结束程序。<br> 4）如果遍历整个树还没有找到，结束程序。</p>
</li>
</ol>
<h5 id="6-递归算法"><a href="#6-递归算法" class="headerlink" title="6 递归算法"></a>6 递归算法</h5><p> <br>递归就是某个函数直接或间接的调用自身。<br>语法形式上: 在一个函数的运行过程中, 调用这个函数自己：</p>
<blockquote>
<p>直接调用: 在fun()中直接执行fun()；<br>间接调用: 在fun1()中执行fun2(); 在fun2()中又执行fun1() ；</p>
</blockquote>
<p>问题的求解过程是划分成许多相同性质的子问题的求解，而小问题的求解过程可以很容易的求出。这些子问题的解就构成里原问题的解。<br> <br>待求解问题的解可以描述为输入变量x的函数f(x)。 <br> <br>通过寻找函数g( )，使得f(x) = g(f(x-1))。<br> <br>且已知f(0)的值, 就可以通过f(0)和g( )求出f(x)的值。<br> <br>扩展到多个输入变量x, y, z等, x-1也可以推广到 x - x1 , 只要递归朝着 “出口” 的方向即可。<br> <br>递归算法分解出的子问题与原问题之间是纵向的, 同类的关系（枚举分解出的子问题之间是横向的, 同类的关系）。<br> <br>递归的三个要点:</p>
<ul>
<li>递归式：如何将原问题划分成子问题；</li>
<li>递归出口：递归终止的条件, 即最小子问题的求解,可以允许多个出口；</li>
<li>界函数：问题规模变化的函数, 它保证递归的规模向出口条件靠拢。</li>
</ul>
<p>如一个求阶乘的递归程序，给定n, 求阶乘n!</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> n,m=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n; i++)</span><br><span class="line">	m *=i;</span><br><span class="line">	</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分搜索的递归实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearchRecursion</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> findData, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr==<span class="literal">NULL</span> || start&gt;<span class="built_in">end</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start+(<span class="built_in">end</span>-start)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == findData)</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(findData &lt; arr[mid])</span><br><span class="line">      binarySearchRecursion(arr, findData, start, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      binarySearchRecursion(arr, findData, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br></pre></td></tr></table></figure>


<h5 id="7-归并排序"><a href="#7-归并排序" class="headerlink" title="7 归并排序"></a>7 归并排序</h5><p> <br>归并排序（merge sort）是建立在归并操作上的一种有效的排序算法。该算法是分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并（2-way or binary merges sort）。 <br> <br>归并排序在1945年由冯·诺伊曼首次提出。<br> <br>2-路归并的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序？<br> <br>可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。 <br> <br>归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N<em>logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N</em>logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。<br> <br>归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。<br> <br>7.1 归并排序分解</p>
<p>可以看到这种结构很像一棵完全二叉树，分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p>
<p>7.2 归并排序合并相邻有序子序列<br> <br>再来看看并阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。<br> <br>    •    申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； <br>    •    设定两个指针，最初位置分别为两个已经排序序列的起始位置； <br>    •    比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; <br>    •    重复步骤3直到某一指针到达序列尾； <br>    •    将另一序列剩下的所有元素直接复制到合并序列尾;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="comment">// 分类 -------------- 内部比较排序</span></span><br><span class="line"><span class="comment">// 数据结构 ---------- 数组</span></span><br><span class="line"><span class="comment">// 最差时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 最优时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 平均时间复杂度 ---- O(nlogn)</span></span><br><span class="line"><span class="comment">// 所需辅助空间 ------ O(n)</span></span><br><span class="line"><span class="comment">// 稳定性 ------------ 稳定</span></span><br><span class="line"><span class="comment">// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = right - left + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len]; <span class="comment">// 辅助空间O(n)</span></span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = left; <span class="comment">// 前一数组的起始元素</span></span><br><span class="line">  <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">// 后一数组的起始元素</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; <span class="comment">// 带等号保证归并排序的稳定性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[index++] = A[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">  &#123;</span><br><span class="line">    temp[index++] = A[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++)</span><br><span class="line">  &#123;</span><br><span class="line">    A[left++] = temp[k];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现的归并排序(自顶向下)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursion</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left == right) <span class="comment">// 当待排序的序列长度为1时，递归开始回溯，进行merge操作</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">  MergeSortRecursion(A, left, mid); <span class="comment">//左半部分排好序</span></span><br><span class="line">  MergeSortRecursion(A, mid + <span class="number">1</span>, right); <span class="comment">//右半部分排好序</span></span><br><span class="line">  Merge(A, left, mid, right); <span class="comment">//合并左右部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归(迭代)实现的归并排序(自底向上)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> left, mid, right;<span class="comment">// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i *= <span class="number">2</span>) <span class="comment">// 子数组的大小i初始为1，每轮翻倍</span></span><br><span class="line">  &#123;</span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + i &lt; len) <span class="comment">// 后一个子数组存在(需要归并)</span></span><br><span class="line">    &#123;</span><br><span class="line">      mid = left + i - <span class="number">1</span>;</span><br><span class="line">      right = mid + i &lt; len ? mid + i : len - <span class="number">1</span>;<span class="comment">// 后一个子数组大小可能不够</span></span><br><span class="line">      Merge(A, left, mid, right);</span><br><span class="line">      left = right + <span class="number">1</span>; <span class="comment">// 前一个子数组索引向后移动</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> A1[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;; <span class="comment">// 从小到大归并排序</span></span><br><span class="line">  <span class="keyword">int</span> A2[] = &#123; <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> n1 = <span class="keyword">sizeof</span>(A1) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> n2 = <span class="keyword">sizeof</span>(A2) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">  MergeSortRecursion(A1, <span class="number">0</span>, n1 - <span class="number">1</span>); <span class="comment">// 递归实现</span></span><br><span class="line">  MergeSortIteration(A2, n2); <span class="comment">// 非递归实现</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"递归实现的归并排序结果："</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, A1[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"</span></span><br><span class="line"><span class="string">    "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"非递归实现的归并排序结果："</span>);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, A2[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"</span></span><br><span class="line"><span class="string">    "</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> </p>
<h5 id="8-回溯法和分书问题"><a href="#8-回溯法和分书问题" class="headerlink" title="8 回溯法和分书问题"></a>8 回溯法和分书问题</h5><p> <br>回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯“返回，尝试别的路径。可以参考一下走迷宫的过程，一开始会随机选择一条道路前进，一直到走不通之后就会回头直到找到另外一条没有试过的道路前进。实际上，走迷宫的算法就是回溯法的经典问题。<br> <br>回溯法实际上也是一种试错的思路，通过不断尝试解的组合来达到求解可行解和最优解的目的。虽然都有穷搜的概念蕴含其中，但是回溯法和穷举查找法是不同的。对于一个问题的所有实例，穷举法注定都是非常缓慢的，但应用回溯法至少可以期望对于一些规模不是很小的实例，计算机在可接受的时间内对问题求解。<br> <br>许多复杂的规模的问题都可以使用回溯法，有”通用解题方法”的美称。分书问题和八皇后都是典型的回溯法问题。<br> <br>分书问题能够较有代表性地表现数据描述、递归、回溯的算法思路。 <br> <br>有编号为0，1，2，3，4的5本书，准备分给5个人A，B，C，D，E，写一个程序，输出所有皆大欢喜的分书方案。<br> <br>每个人的阅读兴趣用一个二维数组like描述： <br> <br>Like[i][j] = true i喜欢书j<br>Like[i][j] = false i不喜欢书j</p>
<p>设计一个函数trynext(int i)给第i个人分书。<br> <br>用一个一维数组take表示某本书分给了某人。take[j]=i+1;//把第j本书分配给第i个人<br> <br>依次尝试把书j分给人i。 <br> <br>如果第i个人不喜欢第j本书，则尝试下一本书，如果喜欢，并且第j本书尚未分配，则把书j分配给i。<br> <br>如果i是最后一个人，则方案数加1，输出该方案。否则调用trynext(i+1)为第i+1个人分书。<br> <br>如果对第i个人枚举了他喜欢的所有的书，都没有找到可行的方案，那就回到前一个状态i-1，让i-1把分到的书退回去，重新找喜欢的书，再递归调用函数，寻找可行的方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> like[<span class="number">5</span>][<span class="number">5</span>]=&#123;</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> take[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//记录每一本书的分配情况</span></span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n表示分书方案数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trynext</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n=<span class="number">0</span>;</span><br><span class="line">	trynext(<span class="number">0</span>);</span><br><span class="line">	getch();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对第 i 个人进行分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trynext</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j,k;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(like[i][j]&amp;&amp;take[j]==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			take[j]=i+<span class="number">1</span>;<span class="comment">//把第j本书分配给第i个人</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">4</span>)<span class="comment">//第5个人分配结束，也即所有的书已经分配完毕，可以将方案进行输出</span></span><br><span class="line">			&#123;</span><br><span class="line">				n++;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;n&lt;&lt;<span class="string">"种分配方案"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;<span class="number">5</span>;k++)</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"第"</span>&lt;&lt;k&lt;&lt;<span class="string">"本书分配给"</span>&lt;&lt;(<span class="keyword">char</span>)(take[k]+<span class="string">'A'</span><span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			trynext(i+<span class="number">1</span>);<span class="comment">//递归，对下一个人进行分配</span></span><br><span class="line">			take[j]=<span class="number">0</span>;<span class="comment">//回溯，寻找下一种方案</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- more -->



      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2017/04/16/2017-04-16/" data-id="cj1k4sbjs0000ep73bmhn9pry" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/22/2017-04-22/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring框架介绍及使用
        
      </div>
    </a>
  
  
    <a href="/2017/04/15/2017-04-15/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MySQL面试题总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/" rel="tag">IOC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/mysql/" style="font-size: 20px;">mysql</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/22/2017-04-22/">Spring框架介绍及使用</a>
          </li>
        
          <li>
            <a href="/2017/04/16/2017-04-16/">编程中的基本数据结构与算法思想</a>
          </li>
        
          <li>
            <a href="/2017/04/15/2017-04-15/">MySQL面试题总结</a>
          </li>
        
          <li>
            <a href="/2017/04/09/2017-04-09/">MySQL常用优化指南，及大表优化思路</a>
          </li>
        
          <li>
            <a href="/2017/04/08/2017-04-08/">MySQL 学习笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 OuyangWenyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>