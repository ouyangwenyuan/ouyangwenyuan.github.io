<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>2025-06-28 | 持续学习者————Just Do It！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="title: 游戏设计模式学习date: 2025-06-28 08:27:04tags:   架构,性能和游戏 (已看)再探设计模式命令模式 (已看)享元模式 (已看)观察者模式 (已看)原型模式 (已看)单例模式 (已看)状态模式 (已看)序列型模式双缓冲 (已看)游戏循环 (已看)更新方法 (已看)行为型模式字节码 (已看)子类沙盒 (已看)类型对象 (已看)解耦型模式组件模式 (已看)事">
<meta property="og:type" content="article">
<meta property="og:title" content="2025-06-28">
<meta property="og:url" content="http://droidman.net/2025/06/28/2025-06-28/index.html">
<meta property="og:site_name" content="持续学习者————Just Do It！">
<meta property="og:description" content="title: 游戏设计模式学习date: 2025-06-28 08:27:04tags:   架构,性能和游戏 (已看)再探设计模式命令模式 (已看)享元模式 (已看)观察者模式 (已看)原型模式 (已看)单例模式 (已看)状态模式 (已看)序列型模式双缓冲 (已看)游戏循环 (已看)更新方法 (已看)行为型模式字节码 (已看)子类沙盒 (已看)类型对象 (已看)解耦型模式组件模式 (已看)事">
<meta property="og:locale" content="en,ZH">
<meta property="article:published_time" content="2025-06-28T00:27:04.495Z">
<meta property="article:modified_time" content="2025-07-13T05:57:25.300Z">
<meta property="article:author" content="OuyangWenyuan">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="C">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="Objective-c">
<meta property="article:tag" content="Swift">
<meta property="article:tag" content="Unity">
<meta property="article:tag" content="Unity3d">
<meta property="article:tag" content="Shader">
<meta property="article:tag" content="Http">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="Blog">
<meta property="article:tag" content="Program">
<meta property="article:tag" content="Mac OS">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Unix">
<meta property="article:tag" content="Window">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="Lua">
<meta property="article:tag" content="Javascript">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="xcode">
<meta property="article:tag" content="IDEA">
<meta property="article:tag" content="eclicpse">
<meta property="article:tag" content="blender">
<meta property="article:tag" content="MVC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="持续学习者————Just Do It！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">持续学习者————Just Do It！</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">学无止境————不怕你不会，就怕你不学！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://droidman.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2025-06-28" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/06/28/2025-06-28/" class="article-date">
  <time datetime="2025-06-28T00:27:04.495Z" itemprop="datePublished">2025-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      2025-06-28
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: 游戏设计模式学习<br>date: 2025-06-28 08:27:04<br>tags: </p>
<hr>
<p>架构,性能和游戏 (已看)<br>再探设计模式<br>命令模式 (已看)<br>享元模式 (已看)<br>观察者模式 (已看)<br>原型模式 (已看)<br>单例模式 (已看)<br>状态模式 (已看)<br>序列型模式<br>双缓冲 (已看)<br>游戏循环 (已看)<br>更新方法 (已看)<br>行为型模式<br>字节码 (已看)<br>子类沙盒 (已看)<br>类型对象 (已看)<br>解耦型模式<br>组件模式 (已看)<br>事件队列 (已看)<br>服务定位器 (已看)<br>优化型模式<br>数据局部性<br>脏标记模式<br>对象池 (已看)<br>空间分区<br>第1章 架构,性能和游戏<br>架构就是关于代码的组织方式<br>架构意味着变化.衡量一个设计好坏的方法就是看它应对变化的灵活性<br>一旦你理解了问题和它涉及的代码,则实际的编码有时是微不足道的<br>你可以用一堆方式来定义”解耦”,但我认为如果两块代码耦合,意味着你必须同时了解这两块代码.如果你让它们解耦,那么你只需了解其一.<br>当然,对解耦的另一个定义就是当改变了一块代码时不必更改另外一块代码.很明显,我们需要更改一些东西,但是耦合得越低,更改所波及得范围就越小<br>良好的架构需要很大的努力及一系列准则.每当你做出一个改变或者实现一个功能时,你必须很优雅地将它们融入到程序的其余部分.<br>你必须非常谨慎地组织代码并保证其在开发周期中经过数以千计的小变化之后仍然具有良好的组织性<br>没有人可以在纸上设计出一个平衡的游戏.这需要迭代和实验.<br>原型(把那些仅仅在功能上满足一个设计问题的代码融合在一起)是一个完全正确的编程实践<br>开发中我们有几个因素需要考虑</p>
<ol>
<li>我们想获得一个良好的架构,这样在项目的生命周期中便会更容易理解代码</li>
<li>我们希望获得快速的运行时性能</li>
<li>我们希望快速完成今天的功能<br>这些目标至少部分是相冲突的.好的架构从长远来看,改进了生产力,但维护一个良好的架构就意味着每一个变化都需要更多的努力来保持代码的干净<br>最快编写的代码实现却很少是运行最快的.相反,优化需要消耗工程时间.一旦完成,也会使代码库僵化:高度优化过的代码缺乏灵活性,很难改变<br>完成今日的工作并担心明天的一切总伴随着压力.但是,如果我们尽可能快的完成功能,我们的代码库就会充满了补丁,bug和不一致的混乱,会一点点地消磨掉我们未来的生产力<br>这里没有简单的答案,只有权衡<br>抽象和解耦能够使得你的程序开发变得更快和更简单.但不要浪费时间来做这件事,除非你确信存在问题的代码需要这种灵活性<br>在你的开发周期中要对性能进行思考和设计,但是要推迟那些降低灵活性的,底层的,详尽的优化,能晚则晚<br>尽快地探索你的游戏的设计空间,但是不要走得太快留下一个烂摊子给自己.毕竟你将不得不面对它<br>如果你将要删除代码,那么不要浪费时间将它整理得很整洁.摇滚明星把酒店房间弄得很乱是因为他们知道第二天就要结账走人.<br>但是,最重要得是,若要做一些有趣得玩意,那就乐在其中地做吧<br>第2章 命令模式<br>将一个请求封装成一个对象,从而允许你使用不同的请求,队列或日志将客户端参数化,同时支持请求操作的撤销和恢复<br>命令就是一个对象化(实例化)的方法调用<br>这个术语意味着,将某个概念转化为一块数据,一个对象,或者你可以认为是传入函数的变量等.<br>命令就是面向对象化的回调<br>一些语言的反射系统可以让你在运行时命令式地处理系统中的类型.你可以获取到一个对象,它代表着某些其他对象的类,你可以通过它试试看这个类型能做些什么.话句话说,反射是一个对象化的类型系统</li>
<li>你可能最终会有很多不同的命令类.为了更容易地实现这些类,可以定义一个具体的基类,里面有着一些实用的高层次的方法,这样便可以通过对派生出来的命令组合来定义其行为,这么做通常是有帮助的.它会将命令的主要方法变成子类沙盒</li>
<li>在我们的例子中,我们明确地选择了那些会执行命令的角色.在某些情况下,尤其是在对象模型分层的情况下,它可能没有这么直观.一个对象可以响应一个命令,而它也可以决定将命令下放给其从属对象.如果你这样做,你需要了解下责任链</li>
<li>一些命令如第一个例子中的JumpCommand是无状态的纯行为的代码块.在类似这样的情况下,拥有不止一个这样命令类的实例会浪费内存,因为所有的实例是等价的.享元模式就是解决这个问题的.<br>第3章 享元模式<br>使用共享以高效地支持大量的细粒度对象<br>享元,一般来说当你有太多对象并考虑对其进行轻量化时它便能派上用场<br>享元模式通过将对象数据切分成两种类型来解决问题.<br>第一种类型数据是那些不属于单一实例对象并且能够被所有对象共享的数据.称为内部状态,但我更喜欢将它认为是”上下文无关”的状态.在本例中,这指的便是数木的几何形状和纹理数据等.<br>其他数据便是外部状态, 对于每一个实例它们都是唯一的<br>你并不会在一开始便创建所有的享元.如果你不能预测哪些是你真正需要的,则最好按需创建它们.为了获得共享优势,当你需要一个对象时,你要先看看你是否已经创建了一个相同的对象.如果是,则只需返回这个实例.这通常意味着在一些用来查找现有对象的接口背后,你必须做些结构上的封装.像这样隐藏构造函数,其中一个例子就是工厂方法模式<br>为了找到以前创建的享元,你必须追踪哪些你已经实例化过的对象的池,对象池模式对于存储它们会很有用<br>在使用状态模式时,你经常会拥有一些”状态”对象,对于状态所处的状态机而言它们没有特定的字段.状态的标识和方法也足够有用.在这种情况下,你可以同时在多个状态机中始使用这种模式,并且重用这个相同的状态实例并不会带来任何问题<br>第4章 观察者模式<br>在对象间定义一种一对多的依赖关系,以便当某对象的状态改变时,与它存在依赖关系的所有对象都能收到通知并自动进行更新<br>在计算机上随便打开一个应用,它就很有可能就是采用MVC架构开发,而其底层就是观察者模式.观察者模式应用十分广泛,Java甚至直接把它集成到了系统库里面(java.util.Observer),C#更是直接将它集成在了语言层面(event关键字)<br>通知方法会被正在被观察的对象调用.被观察对象，它有两个职责.首先,它拥有观察者的一个列表,这些观察者在随时候命接收各种各样的通知,其次就是发送通知<br>允许外部的代码来控制谁可以接收通知.这个被观察者对象负责和观察者对象进行沟通,但是,它并不与它们耦合<br>同时,被观察者对象拥有一个观察者对象的集合,而不是单个观察者,这也是很重要的.它保证了观察者们并不会隐式地耦合在一起<br>这意味着,两个系统会相互干扰对方—-而且是以一种很不恰当的方式,因为第二个观察者使第一个观察者失效了.观察者集合的存在,可以让每一个观察者都互相不干扰.在它们各自的眼里,都认为被观察者对象眼里只有它自己<br>这就是”观察者”系统和”事件”系统的区别.前者,你观察一个事情,它做了一些你感兴趣的事.后者,你观察一个对象,这个对象代表了已经发生的有趣的事情.<br>发送一个通知,只不过需要遍历一个列表,然后调用一些虚函数.老实讲,它比普通的函数调用会慢一些,但是虚函数带来的开销几乎可以忽略不计,除了对性能要求极其高的程序<br>设计模式会遭人诟病,大部分是由于人们用一个好的设计模式去处理错误的问题,所以事情变得更加糟糕了<br>当一个被观察者对象被删除时,观察者本身应该负责把它自己从被观察者对象中移除.通常情况下,观察者都知道它在观察着哪些被观察者,所以需要做的只是在析构器中添加一个removeObserver()方法<br>当一个被观察者对象被删除时,如果不我们不想让观察者来处理问题,则可以修改以下做法.我们只需要在被观察者对象被删除之前,给所有的观察者发送一个”死亡通知”就可以了.这样,所有已注册的观察者都可以收到通知并进行相应的处理<br>观察者模式非常适合于一些不相关的模块之间的通信问题.它不适合于单个紧凑的模块内部的通信.<br>这也是为什么它适合我们的例子: 成就系统和物理系统是完全不相关的领域,而且很有可能是由不同的人实现的.我们想让它们的通信尽可能地减少,这样任何一个模块都不用依赖另一个模块就可以工作<br>第5章 原型模式<br>使用特定原型实例来创建特定种类的对象,并且通过拷贝原型来创建新的对象.<br>第6章 单例模式<br>确保一个类只有一个实例,并为其提供一个全局访问入口<br>后悔使用单例的原因，它是一个全局变量<br>我们学到的一个教训就是,全局变量是有害的<br>我见过的游戏中的许多单例类都是”managers” —-这些保姆类只是为了管理其他对象.有时为了区别,它们叫做”System”或”Engine”,不过只是改了名字而已<br>尽管保姆类有时是有用的,不过这通常反映出它们对OOP不熟悉.比如下面这两个虚构的类<br>就这样.没有管理器也没有问题.设计糟糕的单例通常会”帮助”你往其他类中添加功能.如果可以,你只需要将这些功能移动到它所帮助的类中去就可以了.毕竟,面向对象就是让对象自己管理自己<br>通用的原则是,在保证功能的情况下将变量限制在一个狭窄的范围内.对象的作用越小,我们需要记住它的地方就越少.在我们盲目地采用具有全局作用域的单例对象之前,让我们考虑下代码库访问一个对象的其他途径<br>　　传递进去: 最简的解决方式,通常也是最好的方式,就是将这个对象当作一个参数传递给需要它的函数<br>　　在基类中获取它: 许多游戏架构有浅层次但是有宽度的继承体系,通常只有一层继承 面向切面编程<br>　　通过其他全局对象访问它: 我们可以通过将全局对象类包装到现有类里面来减少它们的数量.<br>　　通过服务定位器来访问: 到现在为止, 我们假设全局类就是像Game那样的具体类.另外一个选择就是定义一个类专门用来给对象做全局访问. 这个模式被称为服务定位器模式<br>还有一个问题,我们应该在什么情况下使用真正的单例呢?<br>为了确保只实例化一次,我通常只是简单地使用一个静态类.如果那不起作用,我就会用一个静态的标识位在运行时检查是否只有一个类实例被创建<br>第7章 状态模式<br>允许一个对象在其内部状态改变时改变自身的行为.对象看起来好像是在修改自身类.<br>有限状态机(FSM)可以看作最简单的图灵机<br>整个状态机可以分为: 状态,输入和转换<br>　　你拥有一组状态,并且可以在这组状态之间进行切换<br>　　状态机同一时刻智能处于一种状态<br>　　状态机会接收一组输入或者事件<br>　　每一个状态有一组转换,每一个转换都关联着一个输入并指向另外一个状态<br>层次状态机:一个状态有一个父状态.当有一个事件进来的时候,如果子状态不处理它,那么沿着继承链传给它的父状态来处理.换句话说,它有点像覆盖继承的方法<br>　　你可以把新的状态放入栈里面.当前的状态永远存在栈顶,所以你总能转换到当前状态.但是当前状态会将前一个状态压在栈中自身的下面而不是抛弃掉它<br>　　你可以弹出栈顶的状态,改状态将被抛弃.与此同时,上一个状态就变成了新的栈顶状态了<br>即使有了这些通用的状态机扩展,它们的使用范围仍然是有限的.在游戏的AI领域,最近的趋势是越来越倾向于行为树和规划系统.<br>但是这并不意味着有限状态机,下推自动机和其他简单的状态机没有用.它们对于解决某些特定的问题是一个很好的建模工具.当你的问题满足以下几点要求的时候,有限状态机将会非常有用<br>　　你有一个游戏实体,它的行为基于它的内部状态而改变<br>　　这些状态被严格划分为相对数目较少的小集合<br>　　游戏实体随着时间的变化会响应用户输入和一些游戏事件<br>第8章 双缓冲<br>诸如计算机显示器的显示设备在每一时刻仅绘制一个像素.显示设备从左至右地扫描屏幕屏幕每行中的像素,并如此从上至下地扫描屏幕上的每一行.当它扫描至屏幕的右下角时,它将重定位至屏幕的左上角并如前述那样地重复扫描屏幕.这一扫描过程是如此地快速(大概每秒60次),以至于我们的眼睛无法察觉这一过程.对于我们而言,扫描的结果就是屏幕一块彩色像素组成的静态区域,即一张图片<br>我们的程序一次只渲染一个像素,同时我们要求显示器一次性显示所有的像素—-可能这一帧看不到任何东西,但下一帧显示的就是完整的笑脸.双缓冲模式解决了这一问题<br>双缓冲中的一个缓存用于展示当前帧,于此同时,渲染代码正在另一个缓冲区中写入数据.当渲染代码完成时,通过交换缓冲区,使得显卡驱动开始从第一个缓冲区转向第二个缓冲区以读取其数据进行渲染.只要它掌握好时机在每次刷新显示器结束时进行切换,我们就不会看到任何衔接的裂隙,且整个场景能一次性的瞬间显示出来<br>定义一个缓冲区类来封装一个缓冲区:一块能被修改的状态区域.这块缓冲区能被逐步地修改,但我们希望任何外部的代码将对该缓冲区的修改都视为原子操作.为实现这一点,此类中维护两个缓冲区实例:后台缓冲区和当前缓冲区<br>当要从缓冲区读取信息时,总是从当前缓冲区读取.当要往缓冲区中写入数据时,则总在后台缓冲区上进行.当改动完成后,则执行”交换”操作来将当前缓冲区与后台缓冲区进行瞬时的交换,以便让新的缓冲区为我们所见,同时刚被换下来的当前缓冲区则成为现在的后台缓冲区以供复用<br>当下面这些条件都成立时,使用双缓冲模式:<br>　　我们需要维护一些被逐步改变着的状态量<br>　　同个状态可能会在其被修改的同时被访问到<br>　　我们希望避免访问状态的代码能看到具体的工作过程<br>　　我们希望能够读取状态但不希望等待写入操作的完成<br>双缓冲模式需要在状态写入完成后进行一次交换操作,操作必须是原子性的:也就是说任何代码都无法在这个交换期间对缓冲区内的任何状态进行访问.通常这个交换过程和分配一个指针的速度差不多,但如果交换用去了比修改初始状态更多的时间,那这样模式就毫无助益了<br>我们必须有两份缓冲区，这个模式的另外一个后果就是增加了内存使用.<br>并非只针对图形<br>双缓冲模式所解决的核心问题就是对状态同时进行修改与访问的冲突.造成此问题的原因通常有两个,我们已经通过上述图形示例描述了第一种情况—-状态直接被另一个线程或中断的代码所直接访问<br>而另一种情况同样很常见:进行状态修改的代码访问到了其正在修改的那个状态.这会在很多地方发生:尤其是实体的AI和物理部分,在它与其他实体进行交互时会发生这样的情况,双缓冲模式往往能在此情形下奏效<br>缓冲区如何交换<br>交换缓冲区指针或者引用<br>在两个缓冲区之间进行数据的拷贝<br>第9章 游戏循环<br>实现用户输入和处理器速度在游戏行进时间上的解耦<br>假如有哪个模式是本书最无法删减的,那么非游戏循环模式莫属.游戏循环模式是游戏编程模式种的精髓.几乎所有的游戏都包含着它,无一雷同,相比而言那些非游戏程序中却难见它的身影<br>不同于其他大多数软件,游戏即便在用户不提供任何输入时也一直在运行.加入你坐下来盯着屏幕,游戏也不会卡住.动画依旧在播放,各种效果也在闪动跳跃<br>这是真实的游戏循环的第一个关键点:它处理用户输入,但并不等待输入.游戏循环始终在运转:<br>假如用现实时间来衡量游戏循环的速度,我们就得到了游戏的帧率.<br>两个因素决定了帧率.<br>　　第一个是循环每一帧要处理的信息量.复杂的物理运算,一堆对象的数据更新,许多图形细节等都将让你的CPU和GPU忙个不停,这都会让一帧消耗更多的时间<br>　　第二个是底层平台的速度.速度越快的芯片相同时间内能够处理更多的代码.多核,多GPU,专用声卡以及操作系统的调度器都会影响着你的一帧中所能处理的代码量<br>游戏循环模式的另一个要点:这一模式让游戏在一个与硬件无关的速度常量下运行.<br>一个游戏循环会在游戏过程中持续地运转.每循环一次,它非阻塞地处理用户输入,更新游戏状态,并渲染游戏.它跟踪流逝的时间并控制游戏的速率<br>它的问题在于你无法控制游戏运转的快慢.在较快的机器上游戏循环可能会快得令玩家看不清楚游戏在做什么,在慢的机器上游戏则会变慢变卡<br>你希望游戏运行在60帧,假如你确定每16ms甚至更短的时间就能处理所有的信息<br>对于超过16ms时间的处理时间,则无能为力<br>使用平台的事件循环<br>使用游戏引擎的游戏循环<br>自己编写游戏循环<br>你如何解决能量耗损<br>限制帧率<br>如何控制游戏速度<br>非同步的固定时间步长<br>同步的固定时长<br>变时时长<br>定时更新迭代,变时渲染<br>第10章 更新方法<br>通过对所有对象实例同时进行帧更新来模拟一系列相互独立的游戏对象<br>你会发现这代码的可维护性不高.我们维护着一堆其值不断增长的变量,并不可避免地将所有代码都塞进游戏循环里,每段代码处理一个游戏中特殊的实体.为达到让所有实体同时运行的目的,我们把它们杂糅在一起了.<br>你可能猜到我们所要运用的设计模式该干些什么了? 它要为游戏中的每个实体封装其自身的行为.这将使得游戏循环保持整洁并便于往循环中增加或移除实体<br>为了做到这一点,我们需要一个抽象层,为此定义一个update()的抽象方法.游戏循环维护对象集合,但它并不关心这些对象的具体类型.它只是更新它们.这将每个对象的行为从游戏循环以及其他对象那里分离了出来<br>每一帧,游戏循环遍历游戏对象集合并调用它们的update().这在每帧都给与每个对象一次更新自己行为的机会.通过逐帧调用update方法,使得这些对象的表现得到同步<br>游戏循环维护一个动态对象集合,这使得向关卡里添加或者移除对象十分便捷—-只要往集合里增加或移除就好<br>游戏世界维护一个对象集合.每个对象实现一个更新方法以在每帧模拟自己的行为.而游戏循环在每帧对集合中所有的对象调用其更新方法,以实现和游戏世界同步更新<br>假如把游戏循环比作有史以来最好的东西,那么更新方法模式就会让它锦上添花.<br>更新方法模式在如下情境最为适用:<br>　　你的游戏中含有一系列对象或系统需要同步地运转<br>　　各个对象之间的行为几乎是相互独立的<br>　　对象的行为与时间相关<br>1 将代码划分至单帧之中使其变得更加复杂<br>2 你需要在每帧结束前存储游戏状态以便下一帧继续<br>3 所有对象都在每帧进行模拟,但并非真正同步<br>在本设计模式中,游戏循环在每帧遍历对象集并逐个更新对象.在update()的调用中,多数对象能够访问到游戏世界的其他部分,包括那些正在更新的其他对象.这意味着,游戏循环遍历更新对象的顺序意义重大<br>在更新期间修改对象列表时必须谨慎<br>不要在本帧处理新添加的对象<br>不要在迭代时移除对象<br>一种方法是小心地移除对象并在更新任何计数器时把被移除的对象也算在内.还有一个办法是将移除操作推迟到本次循环遍历结束之后.将要被移除的对象标记为”死亡”,但并不从列表中移除它.在更新期间,确保跳过那些被标记死亡的对象接着等到遍历更新结束,再次遍历列表来移除这些”尸体”<br>你显然必须决定好该把update()方法放在哪一个类中<br>　　实体类中　　假如你已经创建了实体类,那么这是最简单的选项.因为这不会往游戏中增加额外的类.假如你不需要很多种类的实体,那么这种方法可行,但实际项目中很少这么做<br>　　组件类中　　更新方法模式与组件模式享有相同的功能—-让实体/组件独立更新,它们都使得每个实体/组件在游戏世界中能够独立于其他实体/组件.渲染,物理,AI都仅需专注于自己<br>　　代理类中　　将一个类的行为代理给另一个类,设计了其他几种设计模式.状态模式可以让你通过改变一个对象的代理来改变其行为.对象类型模式可以让你在多个相同类型的实体之间共享行为<br>那些未被利用的对象该如何处理<br>你常需要在游戏中维护这样一些对象:不论处于何种原因,它们暂时无需被更新.一种方法是单独维护一个需要被更新的”存活”对象表.<br>这一模式与游戏循环和组件模式共同构成了多数游戏引擎的核心部分<br>当你开始考虑实体集合或循环中组件在更新时的缓存功能,并希望它们更快地运转时,数据局部性模式将会有所帮助<br>Unity 的引擎框架在许多类模块中使用了本模式,比如Monobehaviour类<br>第11章 字节码<br>通过将行为编码成虚拟机指令,而使其具备数据的灵活性<br>指令集定义了一套可以执行的底层操作.一系列指令被编码为字节序列.虚拟机逐条执行指令栈上这些指令.通过组合指令,既可完成很多高级行为<br>这是本书中最复杂的模式,它可不是轻易就能放进你的游戏里的,仅当你的游戏中需要定义大量行为,而且实现游戏的语言出现下列情况才应该使用:<br>　　编程语言太底层了,编写起来繁琐易错<br>　　因编译时间太长或工具问题,导致迭代缓慢<br>　　它的安全性太依赖编码者.你想确保定义的行为不会让程序崩溃,就得把它们从代码库转移至安全沙箱中<br>当然,这个列表复合大多数游戏的情况.谁不想提高迭代速度,让程序更安全?但那是有代价的,字节码比本地码要慢,所以它并不适合用作对性能要求极高的核心部分<br>字节码虚拟机有两种大风格: 基于栈和基于寄存器.在基于栈的虚拟机中,指令总是操作栈顶<br>基于寄存器的虚拟机也有一个堆栈.唯一的区别是指令可以从栈的更深层次中读取输入.它在字节码中存储两个索引来表示应该从堆栈的哪个位置读取操作数<br>如果你想定义一种基于文本的语言<br>　　你得定义一种语法，外部基本操作，内部基本操作，控制流，抽象化<br>　　你要实现一个分析器<br>　　你必须处理语法错误<br>　　对非技术人员没有亲和力<br>如果你设计了一个图形化编辑器<br>　　你要实现一个用户界面，这样不易出错，但可移植性差<br>这个模式是Gof解释器模式的姊妹版.它们都会为你提供一种用数据组合行为的方法.事实上,你经常会将两个模式一起使用.你用来生成字节码的工具通常会有一个内部对象树来表达代码.这正是解释器模式能做的事情.为了将它编译成字节码,你需要递归遍历整棵树,正如你在解释器模式中解析它那样.唯一的不同是你并不是直接执行一段代码而是将它们输出成字节码指令并在以后执行它们<br>Lua编程语言是游戏中广泛使用的编程语言.它内部实现了一个紧凑的基于寄存器的字节码虚拟机<br>第12章 子类沙盒<br>使用基类提供的操作集合来定义子类中的行为<br>一个基类定义了一个抽象的沙盒模式方法和一些预定义的操作集合.通过将它们设置为受保护的状态以确保它们仅供子类使用.每个派生出的沙盒子类根据父类提供的操作来实现沙盒函数<br>沙盒模式适用于以下情况<br>　　你有一个带有大量子类的函数<br>　　基类能够提供所有子类可能需要执行的操作集合<br>　　在子类之间有重叠的代码,你希望在它们之间更简便地共享代码<br>　　你希望使这些继承类与程序其他代码之间的耦合最小化<br>经验法则<br>　　如果所提供的操作仅仅被一个或者少数的子类所使用,那么不必将它加入基类.这只会给基类增加复杂度,同时将影响每个子类,而仅有少数子类从中受益.将该操作与其他提供的操作保持一致或许值得,但让这些特殊子类直接调用外部系统或许更为简单和清晰<br>　　当你在游戏的其他模块进行某个方法调用时,如果它不修改任何状态,那么它就不具备侵入性.它仍然产生了耦合,但这是个”安全”的耦合,因为在游戏中它不带来任何破坏.而另一方面,如果这些调用确实改变了状态,则将与代码库产生更大的耦合,你需要对这些耦合更上心.因此此时这些方法更适合由更可视化的基类提供<br>　　如果提供的操作,其实现仅仅是对一些外部系统调用的二次封装,那么它并没有带来多少价值.在这种情况下,直接调用外部系统更为简单.然而,极其简单的转向调用也仍有用—-这些函数通常访问基类不像直接暴露给子类的状态<br>是直接提供函数,还是由包含它们的对象提供<br>把提供的操作分流到一个像这样的辅助类中能给你带来些好处<br>　　减少了基类的函数数量.<br>　　在辅助类中的代码通常更容易维护<br>　　降低了基类和其他系统之间的耦合<br>基类如何获取其所需的状态<br>把它传递给基类构造函数<br>当你采用更新方法模式的时候,你的更新函数通常也是一个沙盒函数<br>模板方法模式正好与本模式相反.在这两个模式中,你都使用一系列操作原语来实现一个函数.使用子类沙盒模式时,函数在继承类中,原语操作则在基类中.使用模板方法时,基类定义函数骨架,而原语操作被继承类实现<br>你可以将这个模式看作是在外观模式上的一个变种.外观模式将许多不同的系统隐藏在了一个简化的API之下.在子类沙盒模式中,基类对于子类来说充当着隐藏游戏引擎实现细节的角色<br>第13章 类型对象<br>通过创建一个类来支持新类型的灵活创建,其每个实例都代表一个不同的对象类型<br>类型对象模式，定义一个类型对象类和一个持有类型对象类.每个类型对象的实例表示一个不同的逻辑类型.每个持有类型对象类的实例引用一个描述其类型的类型对象<br>实例数据被存储在持有类型对象的实例中,而所有同概念类型所共享的数据和行为被存储在类型对象中.引用同一个类型的对象之间能表现出”同类”的性状.这让我们可以在相似对象集合中共享数据和行为,这与类派生的作用有几分相似,但却无需硬编码出一批派生类<br>当你需要定义一系列不同”种类”的东西,但又不想把那些种类硬编码进你的类型系统时,本模式都适用.尤其是当下面任何一项成立的时候:<br>　　你不知道将来会有什么类型<br>　　你需要在不重新编译或修改代码的情况下,修改或添加新的类型，类型对象必须手动跟踪，为每个类型定义行为更困难<br>通过类型对象去定义类型相关的数据非常容易,但是定义数据类型相关的行为却很难.<br>有几种方法可以跨越这个限制.<br>一个简单的方法是创建一个固定的预定义行为集合,让类型对象中的数据从中任选其一<br>另一个更强大,更彻底的解决方案是支持在数据中定义行为.如果我们能读取数据文件并提供给上述任意一种模式来实现,行为定义就完全从代码中脱离出来,而被放进数据文件内容中.<br>类型对象应该封装还是暴露<br>如果类型对象被封装<br>　　类型对象模式的复杂性对代码库的其他部分不可见.它成为了持有类型对象才需关心的实现细节<br>　　持有类型对象的类可以有选择性地重写类型对象的行为<br>如果类型对象被公开<br>　　外部代码在没有持有类型对象类实例的情况下就能访问类型对象<br>　　类型对象现在是对象公共API的一部分<br>持有类型对象如何创建<br>通过这种模式,每个”对象”现在都成了一对对象:主对象以及它所使用的类型对象.那么我们如何创建并将它们绑定起来呢?<br>　　构造对象并传入类型对象<br>　　在类型对象上调用”构造”函数<br>类型能否改变<br>类型不变<br>　　无论编码还是理解起来都更简单<br>　　易于调试<br>类型可变<br>　　减少对象创建<br>　　做约束时要更加小心<br>没有派生<br>　　简单<br>　　可能会导致重复劳动<br>单继承<br>　　仍然相对简单<br>　　属性查找会更慢<br>多重派生<br>　　能避免绝大多数的数据重复<br>　　复杂<br>这个模式所围绕的高级问题是如何在不同对象之间共享数据.从另一个不同角度尝试解决这个问题的是原型模式<br>类型对象与享元模式很接近.它们都让你在实例间共享数据.享元模式倾向于节约内存,并且共享的数据可能不会以实际的”类型”呈现.类型对象模式的重点在于组织性和灵活性<br>这个模式与状态模式也有诸多相似性.它们都把对象的部分定义工作交给另一个代理对象实现.在类型对象中,我们通常代理的对象是:宽泛地描述对象的静态数据.在状态模式中,我们代理的是对象当前的状态,即描述对象当前配置的临时数据.当我们讨论到可改变类型对象的时候,你可以认为是类型对象在状态模式的基础上身兼二职<br>第14章 组件模式<br>允许一个单一的实体跨越多个不同域而不会导致耦合<br>继承有它的用处,但是对某些代码重用来说实现起来太麻烦了.相反,软件设计的趋势应该是尽可能地使用组合而不是继承.为实现两个类之间的代码共享,我们应该让它们拥有同一个类的实例而不是继承同一个类<br>单一实体跨越了多个域.为了能保持域之间相互隔离,每个域的代码都独立地放在自己的组件类中.实体本身则可以简化为这些组件的容器<br>组件最常见于游戏中定义实体的核心类,但是它们也能够用在别的地方.当如下条件成立时,组件模式就能够发挥它的作用<br>　　你有一个涉及多个域的类,但是你希望让这些域保持相互解耦<br>　　一个类越来越庞大,越来越难以开发<br>　　你希望定义许多共享不同能力的对象,但采用继承的办法却无法令你精确地重用代码<br>组件模式相较直接在类中编码的方式为类本身引入了更多的复杂性.每个概念上的”对象”成为一系列必须被同时实例化,初始化,并正确关联的对象的集群.不同组件之间的通信变得更具挑战性,而且对它们所占用内存的管理将更复杂<br>使用组件的另外一个后果是你经常需要通过一系列间接引用来处理问题,考虑容器对象,首先你必须得到你需要的组件,然后你才可以做你需要做的事情,在一些性能要求较高的内部循环代码中,这个组件指针可能会导致低劣的性能<br>关于这个设计模式的最重要的问题是:你需要的组件集合是什么?答案取决于你的游戏需求与风格.引擎越大越复杂,你就越想要将组件切分得更细<br>对象如何获得组件<br>如果这个类创建了自己的组件<br>　　它确保了这个类一定有它所需要的组件<br>　　但是这么做将导致重新配置这个类变得困难<br>如果由外部代码提供组件<br>　　对象将变得灵活.我们完全可以通过添加不同的组件来改变类的行为<br>　　对象可以从具体的组件类型中解耦出来<br>完美地将组件互相解耦并且保证功能隔离是个很好的想法,但这通常是不现实的.这些组件同属于一个对象的事实暗示了它们都是整体的一部分因此需要相互协作—-亦即通信<br>所以组件之间又是如何传递信息的呢?有好几个选择<br>　　通过修改容器对象的状态<br>　　　　它使得组件间保持解耦<br>　　　　它要求组件间任何需要共享的数据都由容器对象进行共享<br>　　　　这使得信息传递变得隐秘,同时对组件执行的顺序产生依赖<br>直接互相引用<br>通过传递信息的方式<br>这是选项中最复杂的一个.我们可以在容器类中建立一个小的消息传递系统,让需要传递信息的组件通过广播的方式去建立组件间的联系.GoF称之为中介模式,两个或者两个以上的对象通过将信息传递到一个中介的方法来取得相互之间的联系.而本章节中,容器类则充当了中间的角色<br>意料之外的是,没有哪个选择是最好的.你最终有可能将上述所说的三种方法都使用到<br>Unity框架的核心GameObject类完全围绕组件来设计<br>第15章 事件队列<br>对消息或事件的发送与受理进行时间上的解耦<br>事件驱动式编程<br>问题1: 在音效引擎完全处理完播放请求前,API的调用一直阻塞着调用者<br>问题2: 不能批量地处理请求<br>问题3: 请求在错误的线程被处理<br>事件队列是一个按照先进先出顺序存储一系列通知或请求的队列.发出通知时系统会将该请求置入队列并随即返回,请求处理器随后从事件队列中获取并处理这些请求.请求可由处理器直接处理或转交给对其感兴趣的模块.这一模式对消息的发送者与受理者进行了解耦,使消息的处理变得动态且非实时<br>如果你只想对一条消息的发送者和接收者进行解耦,那么诸如观察者模式和命令模式都能以更低的复杂度满足你.需要在某个问题上对时间进行解耦时,一个队列往往足矣<br>按照推送和拉取的方式思考:代码A希望另一个代码块B做一些事情.A发起这一请求最自然的方式就是将它推送给B<br>同时,B在其自身的循环中适时地拉取该请求并进行处理也是十分自然的.当你具备推送端和拉取端之后,在两者之间需要一个缓冲.这正是缓冲队列比简单的解耦模式多出来的优势<br>队列提供给拉取请求的代码块一些控制权:接收者可以延迟处理,聚合请求或者完全废弃它们.但这是通过”剥夺”发送者对队列的控制来实现的.所有的发送端能做的就是往队列里投递消息.这使得队列在发送端需要实时反馈时显得很不适用<br>事件队列会更复杂一些并且对你的游戏框架产生广泛而深远的影响.这意味着你在决定如何使用,是否适用本模式时须三思<br>中心事件队列是个全局变量<br>该模式的一种普遍用法被称为”中央枢纽站”,游戏中所有模块的消息都可以通过它来传递.它是游戏中强大的基础设施,然而强大并不总意味着好用<br>关于”全局变量是糟糕的”这点,大多数人在走过不少弯路后才恍然大悟.当你有一些系统的任何部分都能访问的状态时,各种细小部分不知不觉地产生了相互依赖.本模式将这些状态封装成为一种不错的小协议,但让然是全局性的,故仍具有任何全局变量所包含的危险性da<br>游戏世界的状态任你掌控<br>当你接收到一个事件,你要十分谨慎,不可认为当前世界的状态反映的是消息发出时世界的状态.这就意味着队列事件视图比同步系统中的事件具有更重量级的数据结构.后者只需通知”某事发生了”然后接收者可以检查系统环境来深入细节,而适用队列时,这些细节必须在事件发生时被记录以便稍后处理消息时适用<br>你会在反馈系统循环中绕圈子，任何一个事件或消息系统都得留意循环<br>当你的消息系统是同步的,你很块就能发现死循环—-它们会导致栈溢出并造成游戏崩溃.对于队列来说,异步的放开栈处理会适这些伪事件在系统中来回徘徊,但游戏可能会保持运行.一个常用的规避法则是避免在处理事件末端代码中发送事件<br>许多游戏将事件队列作为通讯架构的一个关键部分,你可以花大量的时间来设计各种复杂的路由和消息过滤机制.但在你准备建立类似于洛杉矶电话交换机系统那样的东西之前,我建议你开始要简单点.下面是入门时要考虑的一些问题<br>“事件”和”消息”总是被我替换着使用,因为这无伤大雅.无论你往队列里塞什么,它都具备相同的解耦与聚合能力,但二者仍然有一些概念上的不同<br>如果队列中是事件<br>　　一个”事件”或”通知”描述已经发生的事情,比如”怪物死亡”.你将它入队,所以其他对象可以响应事件,有几分像一个异步的观察者模式<br>　　你可能会允许多个监听器.由于队列包含的事件已经发生.因此发送者不关心谁会接收到它.从这个角度来看,这个事件已经过去并且已经被忘记了<br>　　可访问队列的域往往更广.事件队列经常用于给任何和所有感兴趣的部分广播事件.为了允许感兴趣的部分有更大的灵活性,这些队列往往有更多的全局可见性<br>如果队列中是消息<br>　　一个”消息”或”请求”描述一种”我们期望”发生在”将来”的行为,类似于”播放音乐”.你可以认为这是一个异步API服务<br>　　你更可能只有单一的监听器.示例中,队列中的消息专门向音频API请求播放声音.如果游戏的其他任何部分开始从队列中偷窃消息,那并不会起到好的作用<br>谁能从队列中读取<br>单播队列　　当一个队列是一个类的API本身的一部分时,单播再合适不过了<br>广播队列　　这是大多数”事件”系统所做的事情.当一个事件进来时,如果你有十个监听器,则它们都能看见该事件，事件可以被删除，可能需要过滤事件<br>工作队列　　类似于一个广播队列,此时你也有多个监听器.不同的是队列中的每一项只会被投递到一个监听器中.这是一种对于并发线程支持不好的系统中常见的工作分配模式<br>　　你必须做好规划<br>谁可以写入队列<br>一个写入者　　这种风格尤其类似于同步式观察者模式.你拥有一个可以生成事件的特权对象,以供其他模块接收<br>　　你隐式地知道事件的来源<br>　　通常允许多个读取者.你可以创造一对一接收者的队列,但是,这样不太像通信系统,而更像是一个普通的队列数据结构<br>多个写入者　　这是我们的音频引擎例子的工作原理.因为”playSound()”函数是一个公共方法,所以任何代码库部分都可以为队列添加一个请求,”全局”或”中央”事件总线工作原理类似，你必须小心反馈循环，你可能会想要一些发送方在事件本身的引用<br>队列中对象的生命周期是什么<br>转移所有权　　这是手动管理内存时的一种传统方法.当一个消息排队时,队列声明它,发送者不再拥有它.当消息处理时,接收者取走所有权并负责释放它<br>共享所有权　　当前,虽然C++程序员能更舒服地进行垃圾回收了,但分享所有权会容易接受.这样一来,只要任何事情对它有一个引用,消息就依然存在.当被忘记时它就会自动释放<br>队列拥有它　　另一个观点是消息总是存在于队列中.不用自己释放消息,发送者会从队列中请求一个新的消息.队列返回一个已经存在于队列内存中的消息引用,接着发送者会填充队列.消息处理时,接收者参考队列中相同消息的操作.<br>但在很多方面,这个模式可以看成是我们所熟知的观察者模式的异步版本<br>和很多模式一样,事件队列有过一些其他别名.其中一个概念叫做”消息队列”,它通常是指一个更高层面的概念.当事件队列应用于应用程序内部时,消息队列通常用于消息之间的通信<br>另一个术语是”发布/订阅”,有时缩写为”订阅”.类似于”消息队列”,它通常在大型分布式系统中被提及,而不专用于像我们例子这阿姨那个简陋的编码模式中<br>第16章 服务定位器<br>为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合<br>在游戏编程中,某些对象或者系统几乎出现在程序的每个角落.在某些时刻,你很难找到一个不需要内存分配,日志记录或者随机数生成的游戏.我们通常认为类似这样的系统是在整个游戏中需要被随时访问的服务<br>尽管我们实现了想要的目的,但整个过程却带来了很多耦合.游戏中每一处调用音频系统的地方,都直接引用了具体的AudioSystem类和访问AudioSystem类的机制—-使用静态类或者单例<br>这些调用音频系统的地方,的确需要耦合到某些东西上以便播放声音,但直接耦合到音频具体实现类上就好像让一百个陌生人知道你家的地址,而仅仅是因为需要它们投递信件.这不仅是隐私问题,而且当你搬家时必须告诉每个人你的新地址,这实在是太痛苦了<br>这里有个更好的解决办法:电话簿.每一个想要联系我们的人能够通过查找名字来得到我们当前的地址.当我们搬家时,我们告诉电话公司,它们更新电话簿,这样每个人都能得到新的地址了.实际上,我们甚至不必给出我们真正的地址.我们能够列出一个邮政信箱,或者其他能够”代表”我们的东西.通过让访问者查询电话簿来找到我们,我们便有了一个方便的可以控制如何查找我们的地方<br>这就是服务定位器模式的简单介绍—-它将一个服务的”是什么(具体实现类型)”和”在什么地方(我们如何得到它的实例)”与需要使用整个服务的代码解耦了<br>一个服务类为一系列操作定义了一个抽象的接口.一个具体的服务提供器实现了这个接口.一个单独的服务定位器通过查找一个合适的提供器来提供这个服务的访问,它同时屏蔽了提供器的具体类型和定位这个服务的过程.<br>每当你将东西变得全局都能访问的时候,你就是在自找麻烦.这就是单例模式存在的主要问题,而这个模式存在的问题也没有什么不同.对于何时使用服务定位器,我的简单建议就是: 谨慎使用<br>与其给需要使用的地方提供一个全局机制来访问一个对象,不如首先考虑将这个对象传递进去.这极其简单易用,而且将耦合变得直观.这可以满足绝大部分需求<br>但是,有时手动地将一个对象传来传去显得毫无理由或者使得代码难以阅读.有些系统,比如日志系统或内存管理系统,不应该是某个模块公开API的一部分.渲染代码的参数应该必须和渲染相关,而不是像日志系统那样的东西<br>同样地,它也适用于一些类似功能的单一系统.你的游戏可能只有一个音频设备或者显示系统让玩家与之打交道.传递的参数是一项环境属性,所以将它传递10层函数以便让一个底层的函数能够访问,为代码增加了毫无意义的复杂度<br>在这些情况下,这个模式能够起到作用.它用起来像一个更灵活,更可配置的单例模式.当被合理地使用时,它能够让你的代码更有弹性,而且几乎没有运行时的损失.<br>服务定位器的关键困难在于,它要有所依赖(连接两份代码),并且在运行时才连接起来.这给与了你弹性,但付出的代价就是阅读代码时比较难以理解依赖的是什么.<br>服务必须被定位<br>当使用单例或者一个静态类时,我们需要的实例不可能变得不可用.但是,既然这个模式需要定位服务,那么我们可能需要处理定位失败的情况<br>服务不知道被谁定位<br>既然定位器是全局可访问的,那么游戏中的任何代码都有可能请求一个服务然后操作它.这意味着这个服务在任何情况下都必须能正确工作.<br>静态函数getAudio()负责定位工作.我们能在代码的任何地方调用它,它能返回一个Audio服务的实例提供我们使用<br>它”定位”的方法十分简单—-在使用这个服务之前它依赖一些外部代码来注册一个服务提供器.<br>这里使用的技术叫做依赖注入,这个术语表示了一个基本的思想.假设你有一个类,依赖另外一个类.在我们的例子中,我们的Locator类需要Audio服务的一个实例.通常,这个定位器应该负责为自己构建这个实例.依赖注入却说外部代码应该负责为这个对象注入它所需要的这个依赖实例<br>这里关键需要注意的地方是调用playSound()的代码对Audio具体实现毫不知情.它只知道Audio的抽象接口,同样重要的是,甚至是定位器本身和具体服务提供器也没有耦合.代码中唯一知道具体实现类的地方,是提供这个服务的初始化代码<br>这里还有更深一层的解耦—-通过服务定位器,Audio接口在绝大多数地方并不知道自己正在被访问.一旦它知道了,它就是一个普通的抽象基类了.这十分有用,因为这意味着我们可以将这个模式应用到一些已经存在的但并不是围绕这个来设计的类上.这和单例有个对比,后者影响了”服务”类本身的设计<br>“时序解耦”—-两份单独的代码必须按正确的顺序调用来保证程序正确工作.每个状态软件都有不同程度的”时序耦合”,但是就像其他耦合那样,消除时序耦合会使得代码易于管理<br>装饰器模式<br>服务是如何被定位的<br>外部代码注册<br>　　它简单快捷<br>　　我们控制提供器如何被构建<br>　　我们可以在游戏运行的时候更换服务提供器<br>　　定位器依赖外部代码<br>在编译时绑定<br>　　你能保证服务可用<br>　　你不能方便地更改服务提供器<br>在运行时配置<br>　　我们不需重编译就能切换服务提供器<br>　　非程序员能够更换服务提供器<br>　　一份代码库能够同时支持多份配置<br>　　不像前几个解决方案,这方案比较复杂且十分重量级<br>　　定位服务需要时间<br>当服务不能被定位时发生了什么<br>让使用者处理<br>　　它让使用者决定如何处理查找失败<br>　　服务使用者必须处理查找失败<br>终止游戏<br>　　使用者不需要处理一个丢失的服务<br>　　如果服务没有被找到,游戏将会中断<br>返回一个空服务<br>　　使用者不需要处理丢失的服务<br>　　当服务不可用时,游戏还能继续<br>服务的作用域多大<br>如果是全局访问<br>　　它鼓励整个代码库使用同一个服务<br>　　我们对何时何地使用服务完全失去了控制<br>如果访问被限制到类中<br>　　我们控制了耦合.<br>　　它可能导致重复的工作<br>我的一般原则是,如果服务被限制在游戏的一个单独域中,那么就把服务的作用域限制到类中.比如,获取网络访问的服务就可能被限制在联网的类中.而更广泛使用的服务,比如日志服务应该是全局的<br>　<br>第17章 数据局部性<br>通过合理组织数据利用CPU的缓存机制来加快内存访问速度<br>RAM的存取速度远远跟不上CPU的速度<br>对刚访问数据的邻近数据进行访问的术语叫做访问局部性<br>当代计算机有多级缓存,也就是你所听到的那些”L1”, “L2”, “L3”等.它们的大小按照其等级递增,但速度却随等级递减<br>当代CPU带有多级缓存以提高内存访问速度.这一机制加快了对最近访问过的数据的邻近内存的访问速度.通过增加数据局部性并利用这一点可以提高性能—-保持数据位于连续的内存中以提供程序进行处理<br>如果多数优化措施,知道我们使用数据局部性模式的第一条准则就是找到出现性能问题的地方.不要在那些代码库里非频繁执行的部分浪费时间,它们不需要本模式.对那些非必要的代码进行优化将使你的人生变得艰难—-因为结果总是更加复杂且笨拙.由于此模式的特殊性,因此你可能还希望确定你的性能问题是否是由缓存未命中引起的,如果不是,那么这个模式也帮不上忙<br>为了做到缓存友好,你可能需要牺牲一些之前所做的抽象化.你越是在程序的数据局部性上下工夫,你就越要牺牲继承,接口以及这些手段所带来的好处.这里并没有高招,只有利弊权衡的挑战.而乐趣便在这里<br>这种设计模式更适合叫做一种思维模式.它提醒着你,数据的组织方式是游戏性能的一个关键部分.这一块的实际拓展空间很大,你可以让你的数据局部性影响到游戏的整个架构,又或者它只是应用在一些核心模块的数据结构上.对这一模式的应用,你最需要关心的就是该何时何地使用它.而随着这个问题我们也会看到一些新的顾虑<br>如何处理多态<br>避开继承<br>　　安全而容易<br>　　速度更快<br>　　灵活性差<br>为不同的对象类型使用相互独立的数组<br>　　这样的一系列集合让对象紧密地封包<br>　　你可以进行静态地调用分发<br>　　你必须时刻追踪这些集合<br>　　你必须注意每一个类型<br>使用指针集合<br>　　这样做灵活性高<br>　　这样做并不缓存友好<br>假如游戏实体通过类中的指针来索引其组件<br>　　你可以将组件存于相邻的数组中<br>　　对于给定实体,你可以很容易地获取它的组件<br>　　在内存中移动组件很困难<br>假如游戏实体通过一系列ID来索引其组件<br>　　这更加复杂<br>　　这样做更慢<br>　　你需要访问组件管理器<br>假如游戏实体本身就只是个ID<br>　　你的游戏实体类完全消失了,取而代之的是一个优雅的数值包装<br>　　实体类本身是空的<br>　　你无须管理其生命周期<br>　　检索一个实体的所有组件会很慢<br>第18章 脏标记模式<br>许多游戏都有一个称之为场景图的东西.这是一个庞大的数据结构,包含了游戏世界中所有的物体.渲染引擎使用它来决定将物体绘制到屏幕的什么地方<br>就最简单的来说,一个场景图只是包含多个物体的列表.每个物体都含有一个模型(或其他图元)和一个”变换”.变换描述了物体在世界中的位置,旋转角度和缩放大小.想要移动或者旋转物体,我们可以简单地修改它的变换<br>当渲染器绘制一个物体时,它将这个物体的变换作用到这个物体的模型上,然后将它渲染出来.如果我们有的是一个场景”袋”而不是场景”图”的话,事情会变得简单很多<br>然而,许多场景图是分层的.场景中的一个物体会绑定在一个父物体上.在这种情况下,它的变换就依赖于其父物体的位置,而不是游戏世界中的一个绝对位置.<br>举个例子,想象我们的游戏中有一艘海盗船在海上.桅杆的顶部是一个瞭望塔,一个海盗靠在这个瞭望塔上,抓在海盗肩膀上的是只鹦鹉.这艘船的局部变换标记了它在海中的位置,瞭望塔的变换标记了它在船上的位置,等等<br>鹦鹉-&gt;海盗-&gt;瞭望塔-&gt;海盗船<br>这样,当一个父物体移动时,它的子物体也会自动地跟着移动.如果我们修改船的局部变换,瞭望塔,海盗,鹦鹉也会随之变动.如果在船移动时我们必须手动调整船上所有物体的变换来防止相对滑动,那会是一件很头疼的事情<br>计算一个物体的世界变换是相当直观的—-只要从根节点沿着它的父链将变换组合起来就行.也就是说鹦鹉的世界变换就是<br>鹦鹉世界变换 = 船的局部变换 x 瞭望塔的局部变换 x 海盗的局部变换 x 鹦鹉的局部变换<br>我们每帧都需要世界中每个物体的世界变换.所以即使每个模型中只有少数的几个矩阵相乘,却也是代码中影响性能的关键所在.保持它们及时更新是棘手的,因为当一个父物体移动,这会影响它自己和它所有的子物体,以及子物体的子物体等的世界变换<br>最简单的途径是在渲染的过程中计算变换.每一帧中,我们从顶层开始递归地遍历场景图.对每个物体,我们计算它们的世界变换并立刻绘制它<br>但是这对我们宝贵的CPU资源是一种可怕的浪费.许多物体并不是每一帧都移动.想想关卡中那些静止的几何体,它们没有移动,但每一帧都要重计算它们的世界变换是一种多么大的浪费<br>一个明显的解决方法是将它”缓存”起来.在每个物体中,我们保存它的局部变换和它派生物体的世界变换.当我们渲染时,我们只使用预先计算好的世界变换.如果物体从不移动,那么缓存的变换始终是最新的,一切都很美好<br>当一个物体缺失移动了,简单的方法就是立即刷新它的世界变换.但是不要忘了继承连!当一个父物体移动时,我们需要重计算它的世界变换并递归地计算它所有子物体的世界变换<br>想象某些比较繁重的游戏场景.在一个单独帧中,船被扔进海里,瞭望塔在风中晃动,海盗斜靠在边上,鹦鹉跳到他的头上.我们修改了4个局部变换.如果我们在每个局部变换变动时都匆忙地重新计算世界变换,结果会发生什么<br>我们只移动了4个物体,但是我们做了10次世界变换计算.这6次无意义的计算在渲染器使用之前就被扔掉了.我们计算了4次鹦鹉的世界变换,但是只渲染了一次<br>问题的关键是一个世界变换可能依赖于好几个局部变换.由于我们在每个这些变换变化时都立刻重计算,所以最后当一帧内有好几个关联的局部变换改变时,我们就将这个变换重新计算了好多遍<br>我们通过将修改局部变换和更新世界变换解耦来解决这个问题.这让我们在单次渲染中修改多个局部变换,然后在所有变动完成之后,在实际渲染器使用之前仅需要计算一次世界变换<br>要做到这点,我们为图中每个物体添加一个”flag”.”flag”和”bit”在编程中是同义词—-它们都表示单个小单元数据,能够存储两种状态中的一个.我们称之为”true”和”false”,有时也叫”set”和”cleared”.<br>我们在局部变换改动时设置它.当我们需要这个物体的世界变换时,我们检查这个flag.如果它被标记为”set”了,我们计算这个世界变换,然后将这个flag置为”clear”.这个flag代表,”这个世界变换是不是过期了?”由于某些原因,传统上这个”过期的”被称作”脏的”.也就是”脏标记”,”Dirty bit”也是这个模式常见的名字.但是我想我会坚持使用那种看起来每那么”污秽”的名字<br>如果我们运用这个模式,然后将我们上个例子中的所有物体都移动,那么游戏看起来如下:<br>这是你能期望的最好的办法.每个被影响的物体的世界变换只需要计算一次.只需要一个简单的位数据,这个模式位我们做了不少事：<br>　　它将父链上物体的多个局部变换的改动分解为每个物体的一次重计算<br>　　它避免了没有移动的物体的重计算<br>　　一个额外的好处: 如果一个物体在渲染之前移除了,那就根本不用计算它的世界变换<br>一组原始数据随时间变化.一组衍生数据经过一些代价昂贵的操作由这些数据确定.一个脏标记跟踪这个衍生数据是否和原始数据同步.它在原始数据改变时被设置.如果它被设置了,那么当需要衍生数据时,它们就会被重新计算并且标记被清除.否则就使用缓存的数据<br>脏位标记设计两个关键词:”计算”和”同步”.在这两种情况下,处理原始数据到衍生数据的过程在时间或其他方面会有很大的开销<br>这里也有些其他的要求:<br>原始数据的修改次数比衍生数据的使用次数多，<br>递增地更新数据十分困难，<br>延时太长会有代价，<br>这个模式把某些耗时的工作推迟到真正需要时才进行,而到有需要时,往往刻不容缓.<br>必须保证每次状态改动时都设置脏标记<br>既然衍生数据是通过原始数据计算而来,那它本质上就是一份缓存.当你获取缓存数据时,棘手的问题是缓存失效—-当缓存和原始数据不同步时,什么都不正确了.在这个模式中,它意味着当任何原始数据变动时,都要设置脏标记<br>必须在内存中保存上次的衍生数据<br>何时清除脏标记<br>当需要计算结果时<br>　　当计算结果从不使用时,它完全避免了计算<br>　　如果计算十分耗时,会造成明显的卡顿<br>在精心设定的检查点<br>　　这些工作并不影响用户体验.<br>　　当工作执行时,你失去了控制权<br>在后台<br>　　你可以调整工作执行的频率<br>　　你可以做更多冗余的工作<br>　　需要支持异步操作<br>脏标记追踪的粒度多大<br>更精细的粒度<br>　　你只需要处理真正变动了的数据,你将船的真正变动的木块数据发送给服务器<br>更粗糙的粒度<br>　　你最终需要处理未变动的数据<br>　　存储脏标记消耗更少的内存<br>　　固定开销花费的时间要更少<br>物理引擎跟踪着物体的运动和空闲状态.一个空闲的物体直到受到力的作用才会移动,它在受力之前不需要处理.这个”是否在移动”就是一个脏标记,用来标记哪些物体收到了力的作用并需要计算它们的物理状态<br>第19章 对象池<br>使用固定的对象池重用对象,取代单独地分配和释放对象,以此来达到提升性能和优化内存使用的目的<br>定义一个保持着可重用对象集合的对象池类.其中的每个对象支持对其”使用(in use)”状态的访问,以确定这一对象目前是否”存活(alive)”.在对象池初始化时,它预先创建整个对象的集合(通常为一块连续堆区域),并将它们都置为”未使用(not in use)”状态<br>当你想要创建一个新对象时就向对象池请求.它将搜索到一个可用的对象,将其初始化未”使用中(in use)”状态并返回给你.当该对象不再被使用时,它将被置回”未使用(not in use)”状态.使用该方法,对象便可以在无需进行内存或其他资源分配的情况下进行任意的创建和销毁<br>对象池模式被广泛地应用于游戏中的可见物体,如游戏实体对象,各种视觉特效,但同时也被使用于非可见的数据结构中,如当前播放的声音.我们在以下情况使用对象池:<br>当你需要频繁地创建和销毁对象时，对象的大小一致时，在堆上进行对象内存分配较慢或者会产生内存碎片时，每个对象封装着获取代价昂贵且可重用的资源,如数据库,网络的连接<br>注意问题：<br>1 对象池可能在闲置的对象上浪费内存<br>2 任意时刻处于存活状态的对象数目恒定<br>3 每个对象的内存大小是固定的<br>4 重用对象不会被自动清理<br>5 未使用的对象将占用内存<br>对象与对象池耦合<br>　　实现很简单,你可以简单地为那些池中的对象增加一个”使用中”的标志位或者函数,这就能解决问题了<br>　　你可以避免存储一个”使用中”的标志位,许多对象已经维护了可以表示自身是否仍然存活的状态<br>对象独立于对象池<br>　　任意类型的对象可以被置入池中.这是个巨大的优点.通过对象与对象池的解绑,你将能够实现一个通用,可重用的对象池类<br>　　“使用中”状态必须能够在对象外部被追踪.最简单的做法是在对象池中额外创建一块独立的空间:<br>对象池模式与享元模式看起来很相似.它们都管理着一系列可重用对象.其差异在于”重用”的含义.享元模式中的对象通过在多个持有者中并发地共享相同的实例以实现重用.它避免了因在不同上下文中使用相同对象而导致的重复内存使用.对象池的对象也被重用,但此”重用”意味着在原对象持有者使用完对象之后,将其内存回收.对象池里的对象在其生命周期中不存在着因为被共享而引致的异常<br>将那些类型相同的对象在内存上整合,能够帮助你在遍历这些对象时利用好CPU的缓存区.数据局部性设计模式阐释了这一点<br>第20章 空间分区<br>将对象存储在根据位置组织的数据结构中来高效地定位它们<br>对于一组对象而言,每一个对象在空间都有一个位置.将对象存储在一个根据对象的位置来组织的数据结构中,该数据结构可以让你高效地查询位于或靠近某处的对象.当对象的位置变化时,应更新该空间数据结构以便可以继续这样查找对象<br>这是一个用来存储活跃的,移动的对象以及静态图像和游戏世界的几何形状等对象的常见模式.复杂的游戏常常有多个空间分区来应对不同类型的存储内容<br>该模式的基本要求是你有一组对象,每个对象都具备某种位置信息,而你因为要根据位置做大量的查询来查找对象从而遇到了性能问题<br>空间分区将O(n)或者O(n2)复杂度的操作拆解为更易于管理的结构.对象越多,模式的价值就越大.相反,如果你的n值很小,则可能不值得使用该模式.由于该模式要根据对象的位置来组织对象,故对象位置的改变就变得难以处理了.你必须重新组织数据结构来跟踪物体的新位置,这会增加代码的复杂性并产生额外的CPU周期开销.你必须确保这么做是值得的<br>空间分区会使用额外的内存来保存数据结构.就像许多的优化一样,它是以空间换取速度的.如果你的内存比时钟周期更吃紧的话,这可能是个亏本生意<br>分区是层级的还是扁平的<br>在网格例子中,我们将网格划分成了一个单一扁平的单元格集合.与此相反,层级空间分区则是将空间划分成几个区域.然后,如果这些区域中仍然包含着许多的对象,就会继续划分.整个递归过程持续到每个区域的对象数目都少于某个约定的最大对象数量为止<br>如果它是一个扁平的分区<br>　　相对简单<br>　　内存使用量恒定<br>　　当对象改变位置时可以更为快速地更新<br>如果它是一个层级的分区<br>　　它可以更有效地处理空白的空间<br>　　它在处理对象稠密区域时更为有效<br>如果分区依赖于对象<br>　　对象可以被逐步地添加<br>　　对象可以快速地移动<br>　　分区可以不平衡<br>如果分区自适应于对象集合<br>　　你可以确保分区间的平衡<br>　　对整个对象集合进行一次性的分区时更为高效<br>如果分区不依赖于对象,而层级却依赖于对象<br>　　可以逐步地增加对象<br>　　对象可以快速地移动<br>　　分区是平衡的<br>如果它是对象唯一存储的地方，这避免了两个集合的内存开销和复杂性<br>如果存在存储对象的另外一个集合，遍历所有的对象会更为快速<br>在这章中我避开对具体空间分区结构的详细讨论,以保持章节的高层次概括性(并且也不会太长),但是下一步你应该要去了解一些常见的结构.尽管它们的名字吓人,但却出奇的简单明了.常见的有网格、四叉树、二叉空间分割、k-d树、层次包围盒<br>每一个空间数据结构基本都是从一个现有已知的一维数据结构扩展到多维,了解它们的线性结构会帮助你判断它们是否适合于解决你的问题:<br>　　网格是一个连续的桶排序<br>　　二叉空间分割,k-d树,以及层次包围盒都是二叉查找树<br>　　四叉树和八叉树都是Trie树</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://droidman.net/2025/06/28/2025-06-28/" data-id="cmcw2i8g60001isz8c9izb88n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/29/2025-06-29/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          xlua-framework框架简介
        
      </div>
    </a>
  
  
    <a href="/2025/06/27/2025-06-27/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">slot 游戏知识</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/" rel="tag">AOP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Assetbundle/" rel="tag">Assetbundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOC/" rel="tag">IOC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Particle-System/" rel="tag">Particle System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shader/" rel="tag">Shader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" rel="tag">Slot, 老虎机，游戏研究</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/" rel="tag">Tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UGUI/" rel="tag">UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-C/" rel="tag">Unity, C#</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" rel="tag">Unity, UI框架, UGUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity%EF%BC%8CAssetBundle/" rel="tag">Unity，AssetBundle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/android/" rel="tag">android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flask/" rel="tag">flask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game/" rel="tag">game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gameframework/" rel="tag">gameframework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http-server/" rel="tag">http.server</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/keyboard/" rel="tag">keyboard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" rel="tag">slot, 老虎机, slot game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket/" rel="tag">socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity/" rel="tag">unity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/unity-python/" rel="tag">unity python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xlua-lua-framework/" rel="tag">xlua, lua, framework</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%B1%E5%BF%97/" rel="tag">励志</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" rel="tag">物理引擎</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" rel="tag">程序员</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AOP/" style="font-size: 10px;">AOP</a> <a href="/tags/Assetbundle/" style="font-size: 10px;">Assetbundle</a> <a href="/tags/C/" style="font-size: 15.71px;">C#</a> <a href="/tags/IOC/" style="font-size: 10px;">IOC</a> <a href="/tags/JVM/" style="font-size: 10px;">JVM</a> <a href="/tags/Java/" style="font-size: 14.29px;">Java</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Particle-System/" style="font-size: 10px;">Particle System</a> <a href="/tags/Shader/" style="font-size: 10px;">Shader</a> <a href="/tags/Slot-%E8%80%81%E8%99%8E%E6%9C%BA%EF%BC%8C%E6%B8%B8%E6%88%8F%E7%A0%94%E7%A9%B6/" style="font-size: 10px;">Slot, 老虎机，游戏研究</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/UGUI/" style="font-size: 11.43px;">UGUI</a> <a href="/tags/Unity/" style="font-size: 18.57px;">Unity</a> <a href="/tags/Unity-C/" style="font-size: 10px;">Unity, C#</a> <a href="/tags/Unity-UI%E6%A1%86%E6%9E%B6-UGUI/" style="font-size: 10px;">Unity, UI框架, UGUI</a> <a href="/tags/Unity%EF%BC%8CAssetBundle/" style="font-size: 10px;">Unity，AssetBundle</a> <a href="/tags/android/" style="font-size: 10px;">android</a> <a href="/tags/flask/" style="font-size: 10px;">flask</a> <a href="/tags/game/" style="font-size: 10px;">game</a> <a href="/tags/gameframework/" style="font-size: 10px;">gameframework</a> <a href="/tags/http-server/" style="font-size: 10px;">http.server</a> <a href="/tags/keyboard/" style="font-size: 10px;">keyboard</a> <a href="/tags/mysql/" style="font-size: 12.86px;">mysql</a> <a href="/tags/python/" style="font-size: 12.86px;">python</a> <a href="/tags/slot-%E8%80%81%E8%99%8E%E6%9C%BA-slot-game/" style="font-size: 10px;">slot, 老虎机, slot game</a> <a href="/tags/socket/" style="font-size: 10px;">socket</a> <a href="/tags/unity/" style="font-size: 17.14px;">unity</a> <a href="/tags/unity-python/" style="font-size: 10px;">unity python</a> <a href="/tags/xlua-lua-framework/" style="font-size: 11.43px;">xlua, lua, framework</a> <a href="/tags/%E5%8A%B1%E5%BF%97/" style="font-size: 10px;">励志</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 10px;">并发</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/" style="font-size: 10px;">物理引擎</a> <a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 10px;">程序员</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.43px;">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 20px;">设计模式</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 11.43px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/13/2025-07-13/">简单的服务器搭建</a>
          </li>
        
          <li>
            <a href="/2025/07/11/2025-07-11/">框架之日志管理系统</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-12/">unity 一键打包</a>
          </li>
        
          <li>
            <a href="/2025/07/10/2025-07-10/">Unity UI框架总结</a>
          </li>
        
          <li>
            <a href="/2025/07/09/2025-07-09/">Unity 打android 包报错总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 OuyangWenyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>